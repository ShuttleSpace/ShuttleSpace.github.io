import{_ as i,c as s,a2 as t,o as e}from"./chunks/framework.CQcFAaaG.js";const c=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"zh-cn/manual/builtin_variables.md","filePath":"zh-cn/manual/builtin_variables.md"}'),h={name:"zh-cn/manual/builtin_variables.md"};function l(r,a,n,d,p,k){return e(),s("div",null,a[0]||(a[0]=[t(`<p>xmake提供了 <code>$(varname)</code> 的语法，来支持内置变量的获取，例如：</p><div class="language-lua vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">lua</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">add_cxflags</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;-I$(buildir)&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>它将会在在实际编译的时候，将内置的 <code>buildir</code> 变量转换为实际的构建输出目录：<code>-I./build</code></p><p>一般内置变量可用于在传参时快速获取和拼接变量字符串，例如：</p><div class="language-lua vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">lua</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">target</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;test&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    -- 添加工程源码目录下的源文件</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    add_files</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;$(projectdir)/src/*.c&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    -- 添加构建目录下的头文件搜索路径</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    add_includedirs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;$(buildir)/inc&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>也可以在自定义脚本的模块接口中使用，例如：</p><div class="language-lua vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">lua</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">target</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;test&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    on_run</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (target)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        -- 复制当前脚本目录下的头文件到输出目录</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        os.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;$(scriptdir)/xxx.h&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;$(buildir)/inc&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    end</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>所有的内置变量，也可以通过<a href="#val">val</a>接口，来获取他们的值。</p><p>这种使用内置变量的方式，使得描述编写更加的简洁易读，下面是一些xmake内置的变量，可以直接获取：</p><table tabindex="0"><thead><tr><th>接口</th><th>描述</th><th>支持版本</th></tr></thead><tbody><tr><td><a href="#varos">$(os)</a></td><td>获取当前编译平台的操作系统</td><td>&gt;= 2.0.1</td></tr><tr><td><a href="#varhost">$(host)</a></td><td>获取本机操作系统</td><td>&gt;= 2.0.1</td></tr><tr><td><a href="#vartmpdir">$(tmpdir)</a></td><td>获取临时目录</td><td>&gt;= 2.0.1</td></tr><tr><td><a href="#varcurdir">$(curdir)</a></td><td>获取当前目录</td><td>&gt;= 2.0.1</td></tr><tr><td><a href="#varbuildir">$(buildir)</a></td><td>获取构建输出目录</td><td>&gt;= 2.0.1</td></tr><tr><td><a href="#varscriptdir">$(scriptdir)</a></td><td>获取工程描述脚本目录</td><td>&gt;= 2.1.1</td></tr><tr><td><a href="#varglobaldir">$(globaldir)</a></td><td>获取全局配置目录</td><td>&gt;= 2.0.1</td></tr><tr><td><a href="#varconfigdir">$(configdir)</a></td><td>获取本地工程配置目录</td><td>&gt;= 2.0.1</td></tr><tr><td><a href="#varprogramdir">$(programdir)</a></td><td>xmake安装脚本目录</td><td>&gt;= 2.1.5</td></tr><tr><td><a href="#varprojectdir">$(projectdir)</a></td><td>获取工程根目录</td><td>&gt;= 2.0.1</td></tr><tr><td><a href="#varshell">$(shell)</a></td><td>执行外部shell命令</td><td>&gt;= 2.0.1</td></tr><tr><td><a href="#varenv">$(env)</a></td><td>获取外部环境变量</td><td>&gt;= 2.1.5</td></tr><tr><td><a href="#varreg">$(reg)</a></td><td>获取windows注册表配置项的值</td><td>&gt;= 2.1.5</td></tr></tbody></table><p>当然这种变量模式，也是可以扩展的，默认通过<code>xmake f --var=val</code>命令，配置的参数都是可以直接获取，例如：</p><div class="language-lua vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">lua</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">target</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;test&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    add_defines</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;-DTEST=$(var)&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p class="tip"> 所有\`xmake f --xxx=...\`配置的参数值，都是可以通过内置变量获取到，例如：\`xmake f --arch=x86\`对应\`$(arch)\`，其他的还有\`$(plat)\`, \`$(mode)\`等等。 具体有哪些参数，可以通过：\`xmake f -h\`才查看。 </p><p>既然支持直接从配置选项中获取，那么当然也就能很方便的扩展自定义的选项，来获取自定义的变量了，具体如何自定义选项见：<a href="#option">option</a></p><h3 id="var-os" tabindex="-1">var.$(os) <a class="header-anchor" href="#var-os" aria-label="Permalink to &quot;var.$(os)&quot;">​</a></h3><h4 id="获取当前编译平台的操作系统" tabindex="-1">获取当前编译平台的操作系统 <a class="header-anchor" href="#获取当前编译平台的操作系统" aria-label="Permalink to &quot;获取当前编译平台的操作系统&quot;">​</a></h4><p>如果当前编译的是iphoneos，那么这个值就是：<code>ios</code>，以此类推。</p><h3 id="var-host" tabindex="-1">var.$(host) <a class="header-anchor" href="#var-host" aria-label="Permalink to &quot;var.$(host)&quot;">​</a></h3><h4 id="获取本机操作系统" tabindex="-1">获取本机操作系统 <a class="header-anchor" href="#获取本机操作系统" aria-label="Permalink to &quot;获取本机操作系统&quot;">​</a></h4><p>指的是当前本机环境的主机系统，如果你是在macOS上编译，那么系统就是：<code>macosx</code></p><h3 id="var-tmpdir" tabindex="-1">var.$(tmpdir) <a class="header-anchor" href="#var-tmpdir" aria-label="Permalink to &quot;var.$(tmpdir)&quot;">​</a></h3><h4 id="获取临时目录" tabindex="-1">获取临时目录 <a class="header-anchor" href="#获取临时目录" aria-label="Permalink to &quot;获取临时目录&quot;">​</a></h4><p>一般用于临时存放一些非永久性文件。</p><h3 id="var-curdir" tabindex="-1">var.$(curdir) <a class="header-anchor" href="#var-curdir" aria-label="Permalink to &quot;var.$(curdir)&quot;">​</a></h3><h4 id="获取当前目录" tabindex="-1">获取当前目录 <a class="header-anchor" href="#获取当前目录" aria-label="Permalink to &quot;获取当前目录&quot;">​</a></h4><p>一般默认是执行<code>xmake</code>命令时的工程根目录，当然如果通过<a href="#os-cd">os.cd</a>改变了目录的话，这个值也会一起改变。</p><h3 id="var-buildir" tabindex="-1">var.$(buildir) <a class="header-anchor" href="#var-buildir" aria-label="Permalink to &quot;var.$(buildir)&quot;">​</a></h3><h4 id="获取当前的构建输出目录" tabindex="-1">获取当前的构建输出目录 <a class="header-anchor" href="#获取当前的构建输出目录" aria-label="Permalink to &quot;获取当前的构建输出目录&quot;">​</a></h4><p>默认一般为当前工程根目录下的：<code>./build</code>目录，也可以通过执行：<code>xmake f -o /tmp/build</code>命令来修改默认的输出目录。</p><h3 id="var-scriptdir" tabindex="-1">var.$(scriptdir) <a class="header-anchor" href="#var-scriptdir" aria-label="Permalink to &quot;var.$(scriptdir)&quot;">​</a></h3><h4 id="获取当前工程描述脚本的目录" tabindex="-1">获取当前工程描述脚本的目录 <a class="header-anchor" href="#获取当前工程描述脚本的目录" aria-label="Permalink to &quot;获取当前工程描述脚本的目录&quot;">​</a></h4><p>也就是对应<code>xmake.lua</code>所在的目录路径。</p><h3 id="var-globaldir" tabindex="-1">var.$(globaldir) <a class="header-anchor" href="#var-globaldir" aria-label="Permalink to &quot;var.$(globaldir)&quot;">​</a></h3><h4 id="全局配置目录" tabindex="-1">全局配置目录 <a class="header-anchor" href="#全局配置目录" aria-label="Permalink to &quot;全局配置目录&quot;">​</a></h4><p>xmake的<code>xmake g|global</code>全局配置命令，数据存储的目录路径，在里面可以放置一些自己的插件、平台脚本。</p><p>默认为：<code>~/.config</code></p><h3 id="var-configdir" tabindex="-1">var.$(configdir) <a class="header-anchor" href="#var-configdir" aria-label="Permalink to &quot;var.$(configdir)&quot;">​</a></h3><h4 id="当前工程配置目录" tabindex="-1">当前工程配置目录 <a class="header-anchor" href="#当前工程配置目录" aria-label="Permalink to &quot;当前工程配置目录&quot;">​</a></h4><p>当前工程的配置存储目录，也就是<code>xmake f|config</code>配置命令的存储目录，默认为：<code>projectdir/.config</code></p><h3 id="var-programdir" tabindex="-1">var.$(programdir) <a class="header-anchor" href="#var-programdir" aria-label="Permalink to &quot;var.$(programdir)&quot;">​</a></h3><h4 id="xmake安装脚本目录" tabindex="-1">xmake安装脚本目录 <a class="header-anchor" href="#xmake安装脚本目录" aria-label="Permalink to &quot;xmake安装脚本目录&quot;">​</a></h4><p>也就是<code>XMAKE_PROGRAM_DIR</code>环境变量所在目录，我们也可以通过设置这个环境量，来修改xmake的加载脚本，实现版本切换。</p><h3 id="var-projectdir" tabindex="-1">var.$(projectdir) <a class="header-anchor" href="#var-projectdir" aria-label="Permalink to &quot;var.$(projectdir)&quot;">​</a></h3><h4 id="工程根目录" tabindex="-1">工程根目录 <a class="header-anchor" href="#工程根目录" aria-label="Permalink to &quot;工程根目录&quot;">​</a></h4><p>也就是<code>xmake -P xxx</code>命令中指定的目录路径，默认不指定就是<code>xmake</code>命令执行时的当前目录，一般用于定位工程文件。</p><h3 id="var-shell" tabindex="-1">var.$(shell) <a class="header-anchor" href="#var-shell" aria-label="Permalink to &quot;var.$(shell)&quot;">​</a></h3><h4 id="执行外部shell命令" tabindex="-1">执行外部shell命令 <a class="header-anchor" href="#执行外部shell命令" aria-label="Permalink to &quot;执行外部shell命令&quot;">​</a></h4><p>除了内置的变量处理，xmake还支持原生shell的运行，来处理一些xmake内置不支持的功能</p><p>例如，现在有个需求，我想用在编译linux程序时，调用<code>pkg-config</code>获取到实际的第三方链接库名，可以这么做：</p><div class="language-lua vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">lua</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">target</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;test&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    set_kind</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;binary&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> is_plat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;linux&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">then</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        add_ldflags</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;$(shell pkg-config --libs sqlite3)&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    end</span></span></code></pre></div><p>当然，xmake有自己的自动化第三库检测机制，一般情况下不需要这么麻烦，而且lua自身的脚本化已经很不错了。。</p><p>但是这个例子可以说明，xmake是完全可以通过原生shell，来与一些第三方的工具进行配合使用。。</p><h3 id="var-env" tabindex="-1">var.$(env) <a class="header-anchor" href="#var-env" aria-label="Permalink to &quot;var.$(env)&quot;">​</a></h3><h4 id="获取外部环境变量" tabindex="-1">获取外部环境变量 <a class="header-anchor" href="#获取外部环境变量" aria-label="Permalink to &quot;获取外部环境变量&quot;">​</a></h4><p>例如，可以通过获取环境变量中的路径：</p><div class="language-lua vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">lua</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">target</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;test&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    add_includedirs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;$(env PROGRAMFILES)/OpenSSL/inc&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><h3 id="var-reg" tabindex="-1">var.$(reg) <a class="header-anchor" href="#var-reg" aria-label="Permalink to &quot;var.$(reg)&quot;">​</a></h3><h4 id="获取windows注册表配置项的值" tabindex="-1">获取windows注册表配置项的值 <a class="header-anchor" href="#获取windows注册表配置项的值" aria-label="Permalink to &quot;获取windows注册表配置项的值&quot;">​</a></h4><p>通过 <code>regpath; name</code> 的方式获取注册表中某个项的值：</p><div class="language-lua vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">lua</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;$(reg HKEY_LOCAL_MACHINE</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\\\</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">SOFTWARE</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\\\</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">Microsoft</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\\\</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">Windows NT</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\\\</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">CurrentVersion</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\\\</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">XXXX;Name)&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div>`,60)]))}const g=i(h,[["render",l]]);export{c as __pageData,g as default};
