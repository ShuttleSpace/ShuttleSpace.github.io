<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Flutter-Column</title>
    <url>/2019/06/04/10/</url>
    <content><![CDATA[<p>以垂直数组方式显示子组件的组件.</p>
<span id="more"></span>
<p>想要某个子组件扩展填充垂直空间,使用 <code>Expanded</code> 组件包装即可.</p>
<p><code>Column</code> 组件不会滑动(通常如果 <code>Column</code> 中的多个子组件超出了可用空间,则会报错).如果有一排组件,而且想要在空间不足时能滑动,考虑使用 <code>ListView</code>.</p>
<p>横向排列考虑使用 <code>Row</code>.</p>
<p>如果只有一个子组件,考虑使用 <code>Align</code> 或 <code>Center</code> 定位组件.</p>
<h4 id="如果传入的垂直约束是无边界的"><a href="#如果传入的垂直约束是无边界的" class="headerlink" title="如果传入的垂直约束是无边界的"></a>如果传入的垂直约束是无边界的</h4><p>如果一个 <code>Column</code> 组件有一个或多个 <code>Expanded</code> 或 <code>Flexible</code> 组件,并且被放在另一个 <code>Column</code> 或 <code>ListView</code> 或其他不提供最大高度约束上下文的组件中,那么将会收到一个运行时异常,表明有非 0 flex 的子组件,但是其垂直约束是无边界的.</p>
<p>正如异常表现出来的问题,使用 <code>Flexible</code> 或 <code>Expanded</code> 意味着接下来布局其他的子组件时必须把剩余的空间平均分配,而如果传入的垂直约束是无边界的话,剩余的空间就变成无限的.</p>
<p>解决该问题的关键在于为什么 <code>Column</code> 会接收到无边界的垂直约束.</p>
<p>一个可能的原因是 <code>Column</code> 被放在了另一个 <code>Column</code> (内部的 <code>Column</code> 没有使用 <code>Expanded</code> 或 <code>Flexible</code> 包装)中.当一个 <code>Column</code> 布局它的非 flex 子组件(没有使用 <code>Expanded</code> 或 <code>Flexible</code> 包装)时,该 <code>Column</code> 就给了其子组件无边界的约束,这样子组件可以自己决定他们的维度(传递无边界的约束意味着该子组件可能需要收缩以包装其内容).对应的解决方案是使用 <code>Expanded</code> 包装内部的 <code>Column</code>,表明内部的 <code>Column</code> 应该填充外部 <code>Column</code> 的剩余空间,而不是去获取它想要的空间大小.</p>
<p>另一个可能的原因是一个 <code>Column</code> 可能嵌套在 <code>ListView</code> 或其他可滑动的垂直布局组件中.在这种场景下,确实存在无限的垂直空间(垂直滑动列表的重点在于允许无限垂直滑动).通常应该检查为什么内部的 <code>Column</code> 会有一个 <code>Expanded</code> 或 <code>Flexible</code> 子组件:它的大小真的是内部子组件的大小吗?解决方案是从包装内部子组件的父组件中移除 <code>Expanded</code> 或 <code>Flexible</code> 组件.</p>
<p>查看 <code>BoxConstraints</code> 获取更多关于约束的信息.</p>
<h4 id="黄黑相间条"><a href="#黄黑相间条" class="headerlink" title="黄黑相间条"></a>黄黑相间条</h4><p>当一个 <code>Column</code> 的内容超过了可用空间,即 <code>Column</code> 溢出,那么内容将被裁剪.在 debug 模式下,在溢出边角上会显示一个黄黑相间条指出该问题,在 <code>Column</code> 下会打印一个溢出多少的信息.</p>
<p>最普遍的解决方案是当垂直空间受限时确保内容滑动使用 <code>ListView</code> 而不是 <code>Column</code>.</p>
<h2 id="布局算法"><a href="#布局算法" class="headerlink" title="布局算法"></a>布局算法</h2><blockquote>
<p>接下来是 framework 如何渲染 <code>Column</code>,查看 <code>BoxConstraints</code> 获取盒布局模型信息.</p>
</blockquote>
<p>布局 <code>Column</code> 需要 6 步.<br>1、使用无边界的水平约束和传入的垂直约束设置每个子组件 flex 因子为 null 或 0.如果 <code>crossAxisAlignment</code> 值为 <code>CrossAxisAlignment.stetch</code>,使用满足传入的垂直约束的最大高度而不是使用准确的垂直约束.<br>2、对非 0 flex 因子的子组件,按照其 flex 因子将剩下的水平空间分割.如一个 flex 因子为 2.0 的子组件在水平空间上将比 flex 因子是 1.0 的子组件宽 2 倍.<br>3、使用相同的垂直约束按照步骤 1 布局剩下的子组件,使用基于步骤 2 申请到的空间作为水平约束而不是无边界水平约束布局.<code>Flexible.fit</code> 属性值为 <code>FlexFit.tight</code> 的子组件受到严格约束(如强制填充申请到的空间),而 <code>Flexible.fit</code> 属性值为 <code>FlexFit.tight</code> 的子组件约束宽松(如不强制填充申请到的空间).<br>4、<code>Row</code> 的高度总是最大子组件的高度(一般满足传入的垂直约束).<br>5、<code>Row</code> 的宽度由 <code>mainAxisSize</code> 属性决定.如果 <code>mainAxisSize</code> 属性值为 <code>MainAxisSize.max</code>,那么 <code>Row</code> 的宽度是传入约束的最大宽度.如果 <code>mainAxisSize</code> 的值为 <code>MainAxisSize.min</code>,那么 <code>Row</code> 的宽度是所有子组件的宽度之和(受传入约束).<br>6、根据 <code>mainAxisAlignment</code> 和 <code>crossAxisAlignment</code> 确定每个子组件的位置.例如,如果 <code>mainAxisAlignment</code>是 <code>MainAxisAlignment.spaceBetween</code>,<br>没有被分配给子组件的空间将会平均分配到各个子组件之间.</p>
<h2 id="继承-🌲"><a href="#继承-🌲" class="headerlink" title="继承 🌲"></a>继承 🌲</h2><p><code>Object &gt; Diagnosticable &gt; DiagnosticableTree &gt; Widget &gt; RenderObjectWidget &gt; MultiChildRenderObjectWidget &gt; Flex &gt; Column</code></p>
]]></content>
  </entry>
  <entry>
    <title>Flutter-Image</title>
    <url>/2019/06/05/47/</url>
    <content><![CDATA[<p>显示图片的组件.</p>
<span id="more"></span>
<p>提供了以下几个不同用途的构造方法:</p>
<ul>
<li><code>new Image</code>: 从 <code>ImageProvider</code> 中获取图片.</li>
<li><code>new Image.asset</code>: 使用 key 从 <code>AssetBundle</code> 中获取图片</li>
<li><code>new Image.network</code>: 从 URL 中获取图片</li>
<li><code>new Image.file</code>: 从 <code>File</code> 中获取图片</li>
<li><code>new Image.memory</code>: 从 <code>Uint8List</code> 中获取图片</li>
</ul>
<p>支持以下图片格式: JPEG,PNG,GIF,Animated GIF,WebP,Animated WebP,BMP,WBMP.</p>
<p>为了自动实现像素密度级的资产管理, 确保在 <code>MaterialApp</code>,<code>WidgetsApp</code>,<code>MediaQuery</code>组件树中使用 <code>AssetImage</code> 指定的 <code>Image</code> 组件.</p>
<p>图片是用 <code>paintImage</code> 画出来的,它包含了 Image 中的不同属性详情描述.</p>
<h2 id="类似组件"><a href="#类似组件" class="headerlink" title="类似组件"></a>类似组件</h2><ul>
<li><code>Icon</code></li>
<li><code>new Ink.Image</code>: 在 material app 中推荐使用(特别是图片在 <code>Material</code> 中,而且上面有 <code>InkWell</code>)</li>
<li><code>Image</code>: <code>dart:ui</code> 提供</li>
</ul>
<h2 id="继承-🌲"><a href="#继承-🌲" class="headerlink" title="继承 🌲"></a>继承 🌲</h2><p><code>Object &gt; Diagnosticable &gt; DiagnosticableTree &gt; Widget &gt; StatefulWidget &gt; Image</code></p>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><ul>
<li><code>alignment</code> -&gt; <code>AlignmentGeometry</code></li>
<li><code>centerSlice</code> -&gt; <code>Rect</code>: .9 图</li>
<li><code>color</code> -&gt; <code>Color</code></li>
<li><code>colorBlendMode</code> -&gt; <code>BlendMode</code>: 混合颜色</li>
<li><code>excludeFromSemantics</code> -&gt; <code>bool</code></li>
<li><code>filterQuality</code> -&gt; <code>FilterQuality</code></li>
<li><code>fit</code> -&gt; <code>BoxFit</code></li>
<li><code>gaplessPlayback</code> -&gt; <code>bool</code>: 当 image provider 改变时是否显示旧的图片.</li>
<li><code>heihgt</code> -&gt; <code>double</code></li>
<li><code>image</code> -&gt; <code>ImageProvider</code></li>
<li><code>matchTextDirection</code> -&gt; <code>bool</code></li>
<li><code>repeat</code> -&gt; <code>ImageRepeat</code></li>
<li><code>semanticLabel</code> -&gt; <code>String</code></li>
<li><code>width</code> -&gt; <code>double</code></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Flutter-Row</title>
    <url>/2019/06/04/18/</url>
    <content><![CDATA[<p>以横向数组的方式显示子组件的组件.</p>
<span id="more"></span>
<p>为了使其一个组件填充剩余可用空间,可以使用 <code>Expanded</code>对其进行包装.</p>
<p><code>Row</code> 组件不会滑动(通常一个<code>Row</code>组件中的子组件过多已经超出了可用空间,则会导致错误).如果在不足的空间中想要一排组件能够滑动,可以考虑使用 <code>ListView</code>.</p>
<p><code>Column</code> 竖向排列.</p>
<p>如果仅有一个子组件,那么可以考虑使用 <code>Align</code> 或 <code>Center</code> 定位该子组件.</p>
<h4 id="为什么我的-row-有一条黄黑相间的条纹"><a href="#为什么我的-row-有一条黄黑相间的条纹" class="headerlink" title="为什么我的 row 有一条黄黑相间的条纹?"></a>为什么我的 row 有一条黄黑相间的条纹?</h4><p>如果 <code>Row</code>的内容是不可伸缩扩展的(没有使用 <code>Expanded</code> 或 <code>Flexible</code> 组件包装),连在一起比 row 本身更宽,那么我们就称 row 溢出了.<br>如果 row 溢出了,那么 row 就没有多余的空间去分配给它的<code>Flexible</code> 和 <code>Expanded</code> 子组件. row 会在边上显示一条黄黑相间的条表示溢出了.如果 row 外有空间,那么溢出亮将会以红色字体打印出来.</p>
<h2 id="布局算法"><a href="#布局算法" class="headerlink" title="布局算法"></a>布局算法</h2><blockquote>
<p>接下来介绍 framework 是如何渲染 <code>Row</code> 的.查看 <code>BoxConstraints</code> 了解盒布局模型.</p>
</blockquote>
<p><code>Row</code> 的布局分以下 6 步:<br>1、使用无边界的水平约束和传入的垂直约束设置每个子组件 flex 因子为 null 或 0.如果 <code>crossAxisAlignment</code> 值为 <code>CrossAxisAlignment.stetch</code>,使用满足传入的垂直约束的最大高度而不是使用准确的垂直约束.<br>2、对非 0 flex 因子的子组件,按照其 flex 因子将剩下的水平空间分割.如一个 flex 因子为 2.0 的子组件在水平空间上将比 flex 因子是 1.0 的子组件宽 2 倍.<br>3、使用相同的垂直约束按照步骤 1 布局剩下的子组件,使用基于步骤 2 申请到的空间作为水平约束而不是无边界水平约束布局.<code>Flexible.fit</code> 属性值为 <code>FlexFit.tight</code> 的子组件受到严格约束(如强制填充申请到的空间),而 <code>Flexible.fit</code> 属性值为 <code>FlexFit.tight</code> 的子组件约束宽松(如不强制填充申请到的空间).<br>4、<code>Row</code> 的高度总是最大子组件的高度(一般满足传入的垂直约束).<br>5、<code>Row</code> 的宽度由 <code>mainAxisSize</code> 属性决定.如果 <code>mainAxisSize</code> 属性值为 <code>MainAxisSize.max</code>,那么 <code>Row</code> 的宽度是传入约束的最大宽度.如果 <code>mainAxisSize</code> 的值为 <code>MainAxisSize.min</code>,那么 <code>Row</code> 的宽度是所有子组件的宽度之和(受传入约束).<br>6、根据 <code>mainAxisAlignment</code> 和 <code>crossAxisAlignment</code> 确定每个子组件的位置.例如,如果 <code>mainAxisAlignment</code>是 <code>MainAxisAlignment.spaceBetween</code>,<br>没有被分配给子组件的空间将会平均分配到各个子组件之间.</p>
<h2 id="继承-🌲"><a href="#继承-🌲" class="headerlink" title="继承 🌲"></a>继承 🌲</h2><p><code>Object &gt; Diagnosticable &gt; DiagnosticableTree &gt; Widget &gt; RenderObjectWidget &gt; MultiChildRenderObjectWidget &gt; Flex &gt; Row</code></p>
]]></content>
  </entry>
  <entry>
    <title>Flutter-Text</title>
    <url>/2019/06/06/46/</url>
    <content><![CDATA[<p>字符串根据布局约束可能跨越多行或者只显示在一行.</p>
<span id="more"></span>
<p><code>style</code> 参数是可选的.如果忽略,默认使用最近的父组件的 <code>DefaultTextStyle</code>.如果给定的样式 <code>TextStyle.inherit</code> 属性为 true(默认),则给定的样式将和最近的父组件的 <code>DefaultTextStyle</code> 合并.这个合并操作很有用,例如使用默认的 font family 和大小使字体 bold.</p>
<p>使用 <code>Text.rich</code> 构造方法,<code>Text</code> 组件可以使用不同的 <code>TextSpan</code> 样式显示一段文字.</p>
<h3 id="交互"><a href="#交互" class="headerlink" title="交互"></a>交互</h3><p>使用 <code>GestureDetector</code> 组件,设置 <code>GestureDetector.onTap</code> 处理器可以使 <code>Text</code> 响应 touch 事件.</p>
<p>在 material design 设计 app 中,可以使用 <code>FlatButton</code> 代替,如果不适合的话,最少都应该使用 <code>InkWell</code> 代替 <code>GestureDetector</code>.</p>
<p>为了使文本分部分交互,使用 <code>RichText</code>,在相关部分文本上指定 <code>TapGestureRecognize</code> 作为 <code>TextSpan.recognizer</code>.</p>
<h3 id="继承-🌲"><a href="#继承-🌲" class="headerlink" title="继承 🌲"></a>继承 🌲</h3><p><code>Object &gt; Diagnosticable &gt; DiiagnosticableTree &gt; Widget &gt; StatelessWidget &gt; Text</code></p>
]]></content>
  </entry>
  <entry>
    <title>GraphQL-Batching</title>
    <url>/2019/05/05/54/</url>
    <content><![CDATA[<p>bactching</p>
<span id="more"></span>
<h2 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h2><h3 id="使用-Dataloader"><a href="#使用-Dataloader" class="headerlink" title="使用 Dataloader"></a>使用 Dataloader</h3><p>如果你正在使用 graphql,那么你可能遇到数据图查询.这可以通过本地数据图加载轻松实现.<br>使用 <code>java-dataloader</code> 将帮助你更高效的处理数据图条目的缓存和批量请求.如果 dataloader 已经发现了一个之前的数据条目,它将会缓存数据并且直接返回不再发起请求.<br>假设我们需要查询一个英雄和他们朋友的名字及他们朋友的朋友的名字.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    hero &#123;</span><br><span class="line">        name &#123;</span><br><span class="line">            friends &#123;</span><br><span class="line">                name &#123;</span><br><span class="line">                    friends &#123;</span><br><span class="line">                        name</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个查询的结果如下.</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">&quot;hero&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;R2-D2&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;friends&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">			<span class="punctuation">&#123;</span></span><br><span class="line">				<span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Luke Skywalker&quot;</span><span class="punctuation">,</span></span><br><span class="line">				<span class="attr">&quot;friends&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">					<span class="punctuation">&#123;</span></span><br><span class="line">						<span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HanSolo&quot;</span></span><br><span class="line">					<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">					<span class="punctuation">&#123;</span></span><br><span class="line">						<span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Leia Organa&quot;</span></span><br><span class="line">					<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">					<span class="punctuation">&#123;</span></span><br><span class="line">						<span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C-3P0&quot;</span></span><br><span class="line">					<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">					<span class="punctuation">&#123;</span></span><br><span class="line">						<span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;R2-D2&quot;</span></span><br><span class="line">					<span class="punctuation">&#125;</span></span><br><span class="line">				<span class="punctuation">]</span></span><br><span class="line">			<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="punctuation">&#123;</span></span><br><span class="line">				<span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Han Solo&quot;</span><span class="punctuation">,</span></span><br><span class="line">				<span class="attr">&quot;friends&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">					<span class="punctuation">&#123;</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Luke Skywalker&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">					<span class="punctuation">&#123;</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Leia Organa&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">					<span class="punctuation">&#123;</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;R2-D2&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line">				<span class="punctuation">]</span></span><br><span class="line">			<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="punctuation">&#123;</span></span><br><span class="line">				<span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Leia Organa&quot;</span><span class="punctuation">,</span></span><br><span class="line">				<span class="attr">&quot;friends&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">					<span class="punctuation">&#123;</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Luke Skywalker&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">					<span class="punctuation">&#123;</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Han Solo&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">					<span class="punctuation">&#123;</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C-3PO&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">					<span class="punctuation">&#123;</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;R2-D2&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line">				<span class="punctuation">]</span></span><br><span class="line">			<span class="punctuation">&#125;</span></span><br><span class="line">		<span class="punctuation">]</span></span><br><span class="line">	<span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>最差的办法是每次调用 <code>DataFetcher</code>获取 person 对象.<br>本例中将发起 15 次网络请求.即使很多人有共同的朋友.使用 <code>dataloader</code>你可以使 graphql 查询变得更高效.<br>当 graphql 降序查询每个层级时(hero -&gt; friends -&gt; friends),dataloader 调用 promise 传递 person 对象.在每个层级中调用 <code>dataloader.dispatch()</code> 批量发起部分查询请求.加上缓存(默认使用),之前的 person 将被返回.<br>上例中只涉及到 5 个独立的 people,合理的使用缓存和批量请求将只有 3 个批量加载函数被调用,3 个网络请求或数据库查询总比 15 个要好.<br>如果你使用了 <code>java.util.concurrent.CompletableFuture.supplyAsync()</code>,那么你可以通过异步调用使查询变得更高效.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  batch loader 可能被调用多次，因为它的无状态性，所以适合作为单例使用</span></span><br><span class="line">BatchLoader&lt;String,Object&gt; characterBatchLoader = <span class="keyword">new</span> <span class="title class_">BatchLoader</span>&lt;String,Object&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> CompletableStage&lt;List&lt;Object&gt;&gt; <span class="title function_">load</span><span class="params">(List&lt;String&gt; keys)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 supplyAsync() 最大化并行执行</span></span><br><span class="line">        <span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; getCharacterDataViaBatchHTTPApi(keys));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个 data laoder 获取关联的人物，把他们放入 graphql schema</span></span><br><span class="line"><span class="type">DataFetcher</span> <span class="variable">heroDataFetcher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataFetcher</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(DataFetchingEnvironment environment)</span> &#123;</span><br><span class="line">        DataLoader&lt;String,Object&gt; dataloader = environment.getDataLoader(<span class="string">&quot;character&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> dataloader.load(<span class="string">&quot;2001&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">DataFetcher</span> <span class="variable">friendsDataFetcher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataFetcher</span>() &#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(DataFetchingEnvironment environment)</span> &#123;</span><br><span class="line">        <span class="type">StarWarsCharacter</span> <span class="variable">starWarsCharacter</span> <span class="operator">=</span> environment.getSource();</span><br><span class="line">        List&lt;String&gt; friendsIds = starWarsCharacter.getFriendIds();</span><br><span class="line">        DataLoader&lt;String,Object&gt; dataloader = environment.getDataLoader(<span class="string">&quot;character&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> dataloader.loadMany(friendsIds);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">DataLoaderDispatcherInstrumentationOptions</span> <span class="variable">options</span> <span class="operator">=</span> DataLoaderDispatcherInstrumentationOptions.newOptions().includeStatistics(<span class="literal">true</span>);</span><br><span class="line"><span class="type">DataLoaderDispatcherInstrumentation</span> <span class="variable">dispatcherInstrumentation</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataLoaderDispatcherInstrumentation</span>(options);</span><br><span class="line"><span class="type">GraphQL</span> <span class="variable">graphql</span> <span class="operator">=</span> GraphQL.newGraphQL(buildSchema())</span><br><span class="line">    .instrumentation(dispatcherInstrumentation)</span><br><span class="line">    .build();</span><br><span class="line"><span class="comment">// 因为 data loader 是有状态的,所以每次请求都会被执行</span></span><br><span class="line">DataLoader&lt;String,Object&gt; characterDataLoader = DataLoader.newDataLoader(characterBatchLoader);</span><br><span class="line"><span class="type">DataLoaderRegistry</span> <span class="variable">registry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataLoaderRegistry</span>();</span><br><span class="line">registry.register(<span class="string">&quot;character&quot;</span>,characterDataLoader);</span><br><span class="line"></span><br><span class="line"><span class="type">ExecutionInput</span> <span class="variable">executionInput</span> <span class="operator">=</span> newExecutionInput()</span><br><span class="line">    .query(getQuery())</span><br><span class="line">    .dataLoaderRegistry(registry)</span><br><span class="line">    .build();</span><br><span class="line"><span class="type">ExecutionResult</span> <span class="variable">executionResult</span> <span class="operator">=</span> graphql.execute(executionInput);</span><br></pre></td></tr></table></figure>

<p>本例中因为我们需要微调 <code>DataLoaderDispatcherInstrumentation</code>选项,所以手动添加.如果不要的话,默认会自动添加的.</p>
<h3 id="仅适用于-AsyncExecutionStrategy-的-Data-Loader"><a href="#仅适用于-AsyncExecutionStrategy-的-Data-Loader" class="headerlink" title="仅适用于 AsyncExecutionStrategy 的 Data Loader"></a>仅适用于 AsyncExecutionStrategy 的 Data Loader</h3><p>这是因为此执行策略知道在最佳时机分发你的 load 调用.它通过深度追踪你有多少个突出的属性及他们是否是列表值等实现.<br>其他策略如 <code>ExecutorServiceExecutionStrategy</code>无法实现这个功能,因为如果 data loader 代码检测到你没有使用 <code>AsyncExecitionStrategy</code>,那么当碰到每个属性时,它将简单的分发 data loader.你可能会得到值的 <code>caching</code>,但你绝对拿不到他们的 <code>batching</code>.</p>
<h3 id="Data-Loader-的每一个请求"><a href="#Data-Loader-的每一个请求" class="headerlink" title="Data Loader 的每一个请求"></a>Data Loader 的每一个请求</h3><p>如果你正在为 web 请求提供服务,那么可以为用户请求指定数据.如果你有用户指定的数据,你可能不会缓存用户 a 的数据,然后在后续的请求中把它传递给用户 b.<br>你的 DataLoader 实例的范围是很重要的.你可能想每个 web 请求创建一个 dataloader 以确保数据只对特定的 web 请求缓存.同时确保 <code>dispatch</code>调用不影响其他的 graphql 执行.<br>DataLoader 默认行为类似缓存.如果发现之前存在某个 key 对应的值,那么会自动返回它.<br>如果你的数据可以跨 web 请求分享,那么你可能需要改变你的 data loader 缓存实现,这样他们就能通过如 memcached 或 redis 这样的缓存层进行数据分享.<br>下例中仍然每个请求创建一个 data loader,然而缓存层允许数据分享.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CacheMap&lt;String,Object&gt; crossRequestCacheMap = <span class="keyword">new</span> <span class="title class_">CacheMap</span>&lt;String,Object&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisIntegration.containsKey(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisIntegration.getValue(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> CacheMap&lt;String,Object&gt; <span class="title function_">set</span><span class="params">(String key,Object value)</span> &#123;</span><br><span class="line">        redisIntegration.setValue(key,value);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> CacheMap&lt;String,Object&gt; <span class="title function_">delete</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        redisIntegration.clearKey(key);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> CacheMap&lt;String,Object&gt; <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        redisIntegration.clearAll();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">DataLoaderOptions</span> <span class="variable">options</span> <span class="operator">=</span> DataLoaderOptions.newOptions().setCacheMap(crossRequestCacheMap);</span><br><span class="line">DataLoader&lt;String,Object&gt; dataloader = DataLoader.newDataLoader(batchLoader,options);</span><br></pre></td></tr></table></figure>

<h3 id="只能异步调用的批量加载功能"><a href="#只能异步调用的批量加载功能" class="headerlink" title="只能异步调用的批量加载功能"></a>只能异步调用的批量加载功能</h3><p>此 dataloader 代码模式整合所有明显的 data loader 调用到一个更有效的批量加载调用.<br>graphql-java 追踪已发起的明显的 data loader 调用,然后在最合适的时机(即所有的 graphql 属性已经校验成功并分发)在后台调用<code>dispatch</code>.<br>然而有些情况下将导致你的 data loader 调用永不会完成,这中情况必须避免.这种情况包括在异步线程调用 <code>DataLoader</code>.<br>下面的 🌰 不会成功(将永远无法完成).</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BatchLoader&lt;String,Object&gt; batchLoader = <span class="keyword">new</span> <span class="title class_">BatchLoader</span>&lt;String,Object&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> CompletionStage&lt;List&lt;Object&gt;&gt; <span class="title function_">load</span><span class="params">(List&lt;String&gt; keys)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> CompletableFuture.completedFuture(getTheseCharacters(keys));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">DataLoader&lt;String,Object&gt; characterDataLoader = DataLoader.newDataLoader(batchLoader);</span><br><span class="line"></span><br><span class="line"><span class="type">DataFetcher</span> <span class="variable">dataFetcherThatCallsTheDataLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataFetcher</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(DataFetchingEnvironment environment)</span> &#123;</span><br><span class="line">        <span class="comment">// 千万要避免这样做</span></span><br><span class="line">        <span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">argId</span> <span class="operator">=</span> environment.getArgument(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">            DataLoader&lt;String,Object&gt; characterLoader = environment.getDataLoader(<span class="string">&quot;characterLoader&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> characterLoader.load(argId);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的 🌰 中,<code>characterDataLoader.load(argId)</code> 可以在另外一个线程的未来某个时刻被调用. graphql-java 引擎不知道何时是最佳时机去分发明显的 <code>DataLoader</code> 调用,因此这个 data loader 可能永远不会如期执行,也不会有结果返回.<br>请记住,data loader 调用仅仅是一个保证,后面会将明显的调用批量调用在合适的时机获取结果.最佳时机是 graphql 属性树已经校验过,且所有的属性值已经被分发.<br>下面的 🌰 依然是异步代码,但是把它放在 <code>BatchLoader</code> 里.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BatchLoader&lt;String,Object&gt; batchLoader = <span class="keyword">new</span> <span class="title class_">BatchLoader</span>&lt;String,Object&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> CompletionStage&lt;List&lt;Object&gt;&gt; <span class="title function_">load</span><span class="params">(List&lt;String&gt; keys)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; getThreseCharacters(keys));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">DataLoader&lt;String,Object&gt; characterDataLoader = DataLoader.newDataLoader(batchLoader);</span><br><span class="line"></span><br><span class="line"><span class="type">DataFetcher</span> <span class="variable">dataFetcherThatCallsTheDataLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataFetcher</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(DataFetchingEnvironment environment)</span> &#123;</span><br><span class="line">        <span class="comment">// 这是阔以滴</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">argId</span> <span class="operator">=</span> environment.getArgument(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">        DataLoader&lt;String,Object&gt; characterLoader = environment.getDataLoader(<span class="string">&quot;characterLoader&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> characterLoader.load(argId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的 🌰 <code>characterDataLoader.load(argId)</code> 会立即返回.这将会把 data 请求入队列,z 当所有的 graphql 属性都分发后再执行.<br>然后当 <code>DataLoader</code> 被分发后,他的 <code>BatchLoader</code> 函数被调用.这个代码可以异步执行,所以你可以有多个批量加载函数,他们可以同时执行.在上例中 <code>CompletableFuture.supplyAsync(() -&gt; getTheseCharacters(keys));</code> 将再另一个线程中返回 <code>getTheseCharacters()</code> 方法.</p>
<h3 id="向你的-data-loader-传递-context"><a href="#向你的-data-loader-传递-context" class="headerlink" title="向你的 data loader 传递 context"></a>向你的 data loader 传递 context</h3><p>data load 库支持传递两个类型的 context 到 batch loader.第一个是每个 dataloader 一个全局的 context 对象,第二个是一个 loaded key 一个 context 对象的 map.<br>这允许你传递下游需要的额外信息.dataloader key 用在缓存结果,而 context 对象可以用在调用中.<br>在下面的 🌰 中,我们有一个全局的安全 context 对象,提供了一个调用 token,同时可以传递 graphql 原对象到每个 <code>dataLoader.load()</code> 调用中.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BatchLoaderWithContext&lt;String,Object&gt; batchLoaderWithCtx = <span class="keyword">new</span> <span class="title class_">BatchLoaderWithContext</span>&lt;String,Object&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> CompletionStage&lt;List&lt;Object&gt;&gt; <span class="title function_">load</span><span class="params">(List&lt;String&gt; keys,BatchLoaderEnvironment loaderContext)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取全局 context 对象</span></span><br><span class="line">        <span class="type">SecurityContext</span> <span class="variable">sercurityCtx</span> <span class="operator">=</span> loaderContext.getContext();</span><br><span class="line">        <span class="comment">// 每个键都有一个 context 对象集</span></span><br><span class="line">        Map&lt;Object,Object&gt; keysToSOurceObjects = loaderContext.getKeyContexts();</span><br><span class="line">        <span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; getTheseCharacters(securityCtx.getToken(),keys,keysToSourceObjects));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">SecurityContext</span> <span class="variable">securityCtx</span> <span class="operator">=</span> SecurityContext.newSecurityContext();</span><br><span class="line"><span class="type">BatchLoaderContextProvider</span> <span class="variable">contextProvider</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BatchLoaderContextProvider</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object getÇontext() &#123;</span><br><span class="line">        <span class="keyword">return</span> securityCtx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">DataLoaderOptions</span> <span class="variable">loaderOptions</span> <span class="operator">=</span> DataLoaderOptions.newOptions().setBatchLoaderContextProvider(contextProvider);</span><br><span class="line">DataLoader&lt;String,Object&gt; characterDataLoader = DataLoader.newDataLoader(batchLoaderWithCtx,loaderOptions);</span><br><span class="line"></span><br><span class="line"><span class="type">DataFetcher</span> <span class="variable">dataFetcherCallsTheDataLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataFetcher</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(DataFetchingEnvironment environment)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">argId</span> <span class="operator">=</span> environment.getArgument(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">source</span> <span class="operator">=</span> environment.getSource();</span><br><span class="line">        <span class="keyword">return</span> characterDataLoader.load(argId,source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>GraphQL-Data mapping</title>
    <url>/2019/05/05/31/</url>
    <content><![CDATA[<p>data mapping</p>
<span id="more"></span>
<h2 id="Mapping-data"><a href="#Mapping-data" class="headerlink" title="Mapping data"></a>Mapping data</h2><h3 id="graphql-是如何把对象数据匹配到类型的"><a href="#graphql-是如何把对象数据匹配到类型的" class="headerlink" title="graphql 是如何把对象数据匹配到类型的"></a>graphql 是如何把对象数据匹配到类型的</h3><p>graphql 内部全部是关于声明类型 schema,然后在运行匹配到数据.<br>作为类型 schema 的设计者,你应该在处理这些元素.</p>
<figure class="highlight graphql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="keyword">Query</span> <span class="punctuation">&#123;</span></span><br><span class="line">	products<span class="punctuation">(</span><span class="symbol">match</span><span class="punctuation">:</span> String<span class="punctuation">)</span><span class="punctuation">:</span> <span class="punctuation">[</span>Product<span class="punctuation">]</span> <span class="comment"># a list of products</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="keyword">type</span> Product <span class="punctuation">&#123;</span></span><br><span class="line">	<span class="symbol">id</span><span class="punctuation">:</span> ID</span><br><span class="line">	<span class="symbol">name</span><span class="punctuation">:</span> String</span><br><span class="line">	<span class="symbol">description</span><span class="punctuation">:</span> String</span><br><span class="line">	<span class="symbol">cost</span><span class="punctuation">:</span> Float</span><br><span class="line">	<span class="symbol">tax</span><span class="punctuation">:</span> Float</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>然后可以执行查询</p>
<figure class="highlight graphql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">query</span> ProductQuery <span class="punctuation">&#123;</span></span><br><span class="line">	products<span class="punctuation">(</span><span class="symbol">match</span><span class="punctuation">:</span> <span class="string">&quot;Paper*&quot;</span><span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">		id</span><br><span class="line">		name</span><br><span class="line">		cost</span><br><span class="line">		tax</span><br><span class="line">	<span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>对于 <code>Query.products</code>属性有一个绑定的 <code>DataFetcher</code>负责查找匹配输入参数的 product s 列表.<br>假设我们有 3 个下游服务.一个获取产品信息,一个获取产品价格信息,一个计算查新税收信息.<br>graphql-java 使用这些对象运行 data fetcher,获取信息然后将其匹配到 schema 指定的类型中.<br>我们的目标是获取到这 3 个源的信息,然后把它们作为一个 unified 类型展示.<br>我们可以对 cost 和 tax 需要计算的属性指定 data fetcher,但这需要更多的维护精力,可能导致 N+1 性能问题.<br>我们最好在 <code>Query.products</code> data fetcher 中获取所有的信息,同时创建一个 unified 数据视图.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DataFetcher</span> <span class="variable">produtctsDataFetcher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataFetcher</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(DataFetchingEnvironment env)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">matchArg</span> <span class="operator">=</span> env.getArgument(<span class="string">&quot;match&quot;</span>);</span><br><span class="line">        List&lt;ProductInfo&gt; productInfos = getMatchingProducts(matchArg);</span><br><span class="line">        List&lt;ProductCostInfo&gt; productConstInfo = getProdutConsts(productInfo);</span><br><span class="line">        List&lt;ProductTaxInfo&gt; productTaxInfo = getProductTax(productInfo);</span><br><span class="line">        <span class="keyword">return</span> mapDataTogether(productInfo,productCostInfo,productTaxInfo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面有 3 个类型的信息需要被整合为一个以便 graphql 查询可以访问 id,name,cost,tax 属性.<br>有 2 中方法可以创建这个映射.一个是使用类型不安全的 <code>List&lt;Map&gt;</code> 结构,另一个是使用类型安全的 <code>List&lt;ProductDTO&gt;</code>封装这些数据.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;Map&gt; <span class="title function_">mapDataTogetherViaMap</span><span class="params">(List&lt;ProductInfo&gt; productInfo,List&lt;ProductCostInfo&gt; productCostInfo,List&lt;ProductTaxInfo&gt; productTaxInfo)</span> &#123;</span><br><span class="line">    List&lt;Map&gt; unifiedView = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; productInfo.size();i++) &#123;</span><br><span class="line">        <span class="type">ProductInfo</span> <span class="variable">info</span> <span class="operator">=</span> productInfo.get(i);</span><br><span class="line">        <span class="type">ProductCostInfo</span> <span class="variable">cost</span> <span class="operator">=</span> productCostInfo.get(i);</span><br><span class="line">        <span class="type">ProductTaxInfo</span> <span class="variable">tax</span> <span class="operator">=</span> productTaxInfo.get(i);</span><br><span class="line"></span><br><span class="line">        Map&lt;String,Object&gt; objectMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        objectMap.put(<span class="string">&quot;id&quot;</span>,info.getId());</span><br><span class="line">        objectMap.put(<span class="string">&quot;name&quot;</span>,info.getName());</span><br><span class="line">        objectMap.put(<span class="string">&quot;descriptioin&quot;</span>,info.getDescription());</span><br><span class="line">        objectMap.put(<span class="string">&quot;cost&quot;</span>,cost.getCost());</span><br><span class="line">        objectMap.put(<span class="string">&quot;tax&quot;</span>,tax.getTax());</span><br><span class="line"></span><br><span class="line">        unifiedView.add(objectMap);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> unifiedView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ProductDTO</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String description;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Float cost;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Float tax;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProductDTO</span><span class="params">(String id, String name, String description, Float cost, Float tax)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.description = description;</span><br><span class="line">        <span class="built_in">this</span>.cost = cost;</span><br><span class="line">        <span class="built_in">this</span>.tax = tax;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Float <span class="title function_">getCost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cost;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Float <span class="title function_">getTax</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> tax;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;ProductDTO&gt; <span class="title function_">mapDataTogetherViaDTO</span><span class="params">(List&lt;ProductInfo&gt; productInfo, List&lt;ProductCostInfo&gt; productCostInfo, List&lt;ProductTaxInfo&gt; productTaxInfo)</span> &#123;</span><br><span class="line">    List&lt;ProductDTO&gt; unifiedView = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; productInfo.size(); i++) &#123;</span><br><span class="line">        <span class="type">ProductInfo</span> <span class="variable">info</span> <span class="operator">=</span> productInfo.get(i);</span><br><span class="line">        <span class="type">ProductCostInfo</span> <span class="variable">cost</span> <span class="operator">=</span> productCostInfo.get(i);</span><br><span class="line">        <span class="type">ProductTaxInfo</span> <span class="variable">tax</span> <span class="operator">=</span> productTaxInfo.get(i);</span><br><span class="line"></span><br><span class="line">        <span class="type">ProductDTO</span> <span class="variable">productDTO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProductDTO</span>(</span><br><span class="line">                info.getId(),</span><br><span class="line">                info.getName(),</span><br><span class="line">                info.getDescription(),</span><br><span class="line">                cost.getCost(),</span><br><span class="line">                tax.getTax()</span><br><span class="line">        );</span><br><span class="line">        unifiedView.add(productDTO);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> unifiedView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>graphql 引擎现在可以使用 object 列表然后运行查询获取 id,name,cost,tax 属性.<br>graphql-java 默认的 data fetcher <code>graphql.schema.PropertyDataFetcher</code> 同时支持 map 和 POJO.<br>对于列表的每一个对象都会通过 id 属性,或使用 name 在 map 里查找,或通过 getId() 方法获取,然后返回给 graphql response.对于查询中的每个类型都会执行这样的操作.<br>通过在高级 data fetcher 中创建一个 unified view,你就可以在运行时数据和 graphql schema 之间建立一个映射.</p>
]]></content>
  </entry>
  <entry>
    <title>GraphQL-Execution</title>
    <url>/2019/05/04/19/</url>
    <content><![CDATA[<p>execution</p>
<span id="more"></span>
<h2 id="Execution"><a href="#Execution" class="headerlink" title="Execution"></a>Execution</h2><h3 id="Queries"><a href="#Queries" class="headerlink" title="Queries"></a>Queries</h3><p>对 schema 执行 query,使用合适的参数构建一个新的 GraphQL 对象,然后调用<code>execute()</code>.<br>query 的结果是包含查询数据或者（并且）一系列错误的<code>ExecutionResult</code> 对象.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">GraphQLSchema</span> <span class="variable">schema</span> <span class="operator">=</span> GraphQLSchema.newSchema().query(queryType).build();</span><br><span class="line"><span class="type">GraphQL</span> <span class="variable">graphQl</span> <span class="operator">=</span> GraphQL.newGraphQL(schema).build();</span><br><span class="line"><span class="type">ExecutionInput</span> <span class="variable">executionInput</span> <span class="operator">=</span> ExecutionInput.newExecutionInput().query(<span class="string">&quot;query &#123; hero &#123; name &#125;&#125;&quot;</span>);</span><br><span class="line"><span class="type">ExectionResult</span> <span class="variable">executionResult</span> <span class="operator">=</span> graphQl.execute(executionInput);</span><br><span class="line"><span class="type">Object</span> <span class="variable">data</span> <span class="operator">=</span> executionResult.getData();</span><br><span class="line">List&lt;GraphQLError&gt; errors = executionResult.getErrors();</span><br></pre></td></tr></table></figure>

<p>更多复杂的查询示例请参考<a href="https://github.com/graphql-java/graphql-java/blob/master/src/test/groovy/graphql/StarWarsQueryTest.groovy">StarWars query tests</a>;</p>
<h3 id="Data-Fetchers"><a href="#Data-Fetchers" class="headerlink" title="Data Fetchers"></a>Data Fetchers</h3><p>每个 graphql 属性类型都有一个 <code>graphql.schema.DataFetcher</code> 与之关联.其他 graphql 实现通常把这个类型成为 <code>resolvers</code>.<br>通常可以使用<code>graphql.schema.PropertyDataFetcher</code>来检查 提供属性值的 Java POJO 对象.如果某个属性未指定 data fetcher,默认会使用这个.<br>然而你可能需要使用自定义的 data fetcehr 获取你的顶级域对象.可能涉及到数据库调用或通过 HTTP 请求其他系统.<br><code>graphql-java</code>不关心你是如何获取你的域对象,这是你需要关心的地方.同时也不关心用户访问数据授权.这些都应该放到你自己的逻辑处理层.<br>data fetcher 示例如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DataFetcher</span> <span class="variable">userDataFetcher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataFetcher</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(DataFetchingEnvironment environment)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fetchUserFromDatabase(environment.getArgument(<span class="string">&quot;userId&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>每个 <code>DataFetcher</code>都会传递一个 <code>graphql.schema.DataFetchingEnvironment</code> 对象(包含了将要获取的属性,获取该属性所需提供的参数和其他信息如属性的父对象,query 根对象或 query 上下文对象).<br>上例中,<code>execution</code>将会在 data fetcher 返回结果后才继续执行.可以通过返回<code>CompletionStage</code> 对象使 <code>DataFetcher</code> 异步执行,详情请继续阅读.</p>
<h3 id="当获取数据时发生异常"><a href="#当获取数据时发生异常" class="headerlink" title="当获取数据时发生异常"></a>当获取数据时发生异常</h3><p>如果在 data fetcher 调用中发生异常,那么默认执行策略将生成<code>graphql.ExceptionWhileDataFetching</code> 错误,然后添加到结果中的错误集中.切记 graphql 允许带错误的部分结果.<br>下面是标准的行为.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleDataFetcherExceptionHandler</span> <span class="keyword">implements</span> <span class="title class_">DataFetcherExceptionhandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(SimpleDataFetcherExceptionHandler.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(DataFetcherExceptionHandlerParameters handlerParameters)</span> &#123;</span><br><span class="line">        <span class="type">Throwable</span> <span class="variable">exception</span> <span class="operator">=</span> handlerParameters.getException();</span><br><span class="line">        <span class="type">SourceLocation</span> <span class="variable">sourceLocation</span> <span class="operator">=</span> handlerParameters.getField().getSourceLocation();</span><br><span class="line">        <span class="type">ExecutionPath</span> <span class="variable">path</span> <span class="operator">=</span> handlerParameters.getPath();</span><br><span class="line"></span><br><span class="line">        <span class="type">ExceptionWhileDataFetching</span> <span class="variable">error</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExceptionWhileDataFetching</span>(path,exception,sourceLocation);</span><br><span class="line">        handlerParameters.getExecutionContext().addError(error);</span><br><span class="line">        log.warn(error.getMessage(),exception);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你抛出的是<code>GraphqlError</code>,那么它会从 exception 中转换 message 和自定义扩展属性到 <code>ExceptionWhileDataFetching</code>对象.此处允许你向调用者返回自定义的属性到 graphql error.<br>例如想象你的 data fetcher 将抛出这个异常.<code>foo</code> 和 <code>fizz</code> 属性将被添加到返回的 graphql error 中.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CustomRuntimeException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> <span class="keyword">implements</span> <span class="title class_">GrapQLError</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String,Object&gt; <span class="title function_">getExtension</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String,Object&gt; customAttributes = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">        customAttributes.put(<span class="string">&quot;foo&quot;</span>,<span class="string">&quot;bar&quot;</span>);</span><br><span class="line">        cutomAttributes.put(<span class="string">&quot;fizz&quot;</span>,<span class="string">&quot;whizz&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> customAttributes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;SourceLocation&gt; <span class="title function_">getLocation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ErrorType <span class="title function_">getErrorType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ErrorType.DataFetchingException;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以通过创建自己的 <code>graphql.execution.DataFetcherExceptionHandler</code>异常处理代码改变此默认行为,给出你自己的执行策略.<br>例如上面的代码记录了基础异常和堆栈跟踪.有的人可能不喜欢在输出错误列表中看到这些.所以你可以使用这个机制改变这个行为.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DataFetcherExceptionHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataFetcherExceptionHandler</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(DataFetcherExceptionHandlerParameters handlerParameters)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">ExecutionStrategy</span> <span class="variable">executionStrategy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AsyncExecutionStrategy</span>(handler);</span><br></pre></td></tr></table></figure>

<h3 id="返回值和错误"><a href="#返回值和错误" class="headerlink" title="返回值和错误"></a>返回值和错误</h3><p>在<code>DataFetcher</code>实现中通过直接或者使用 <code>CompletableFuture</code> 实例包装异步执行返回 <code>graphql.execution.DataFetcherResult</code> 来实现同时返回数据和多个错误.当你的<code>DataFetcher</code> 需要从多个数据源或其他 GraphQL 资源获取数据时特别有用.<br>在这个 🌰 中,<code>DataFetcher</code> 从另一个 GraphQL 资源中获取 user 同时返回数据和错误.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DataFetcher</span> <span class="variable">userDataFetcher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataFetcher</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(DataFetchingEnvironment environment)</span> &#123;</span><br><span class="line">        <span class="type">Map</span> <span class="variable">response</span> <span class="operator">=</span> fetchUserFromRemoteGraphQLResource(environment.getArgument(<span class="string">&quot;userID&quot;</span>));</span><br><span class="line">        List&lt;GralhQLError&gt; errors = response.get(<span class="string">&quot;errors)</span></span><br><span class="line"><span class="string">                                            .stream()</span></span><br><span class="line"><span class="string">                                            .map(MyMapGraphQLError::new)</span></span><br><span class="line"><span class="string">                                            .collect(Collections.toList());</span></span><br><span class="line"><span class="string">        return new DataFetcherResult(response.get(&quot;</span>data<span class="string">&quot;),errors);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="将结果序列化为-JSON"><a href="#将结果序列化为-JSON" class="headerlink" title="将结果序列化为 JSON"></a>将结果序列化为 JSON</h3><p>调用 graphql 最常见的方法是通过 HTTP,返回 JSON 响应.所以你需要将 <code>graphql.ExecutionResult</code> 转为 JSON.<br>最常用的实现是使用 Jackson 或 GSON 这样的 JSON 序列化库.然而它们解析数据的方式有它们自己的一套方式.例如 <code>nulls</code>对 graphql 结果是很重要的,所以你必须在设置 json mapper 时包含它.<br>为了保证你获取的 JSON 结果 100% 符合 graphql 的需求,你应该对结果调用<code>toSpecification</code>,然后将其作为 JSON 返回.<br>这将会确保返回的结果符合<a href="http://facebook.github.io/graphql/#sec-Response">规范</a>.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutionResult</span> <span class="variable">executionResult</span> <span class="operator">=</span> graphQL.execute(executinInput);</span><br><span class="line">Map&lt;String,Object&gt; toSpecificationResult = executionResult.toSpecification();</span><br><span class="line">sendAsJson(toSpecificationResult);</span><br></pre></td></tr></table></figure>

<h3 id="Mutations"><a href="#Mutations" class="headerlink" title="Mutations"></a>Mutations</h3><p><a href="http://graphql.org/learn/queries/#mutations">在这儿</a>学习 mutations.<br>本质上你需要定义一个接收参数作为输入的 <code>GraphQLObjectType</code> .这些参数你可以通过 data fetcher 调用修改你的数据存储.</p>
<figure class="highlight graphql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mutation</span> CreateReviewForEpisode<span class="punctuation">(</span><span class="variable">$ep</span>: Episode<span class="punctuation">!</span>, <span class="variable">$review</span>: ReviewInput<span class="punctuation">!</span><span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">	createReview<span class="punctuation">(</span><span class="symbol">episode</span><span class="punctuation">:</span> <span class="variable">$ep</span>, <span class="symbol">review</span><span class="punctuation">:</span> <span class="variable">$review</span>) <span class="punctuation">&#123;</span></span><br><span class="line">		stars</span><br><span class="line">		commentary</span><br><span class="line">	<span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>在执行 mutation 操作中需要传递参数,本例中是 <code>$ep</code> 和 <code>$review</code> 参数.<br>你可以像这样创建类型处理 mutation 操作.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">GraphQLInputObjectType</span> <span class="variable">episodeType</span> <span class="operator">=</span> newInputObject()</span><br><span class="line">                .name(<span class="string">&quot;Episode&quot;</span>)</span><br><span class="line">                .field(newInputObjectField()</span><br><span class="line">                        .name(<span class="string">&quot;episodeNumber&quot;</span>)</span><br><span class="line">                        .type(Scalars.GraphQLInt))</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line"><span class="type">GraphQLInputObjectType</span> <span class="variable">reviewInputType</span> <span class="operator">=</span> newInputObject()</span><br><span class="line">        .name(<span class="string">&quot;ReviewInput&quot;</span>)</span><br><span class="line">        .field(newInputObjectField()</span><br><span class="line">                .name(<span class="string">&quot;stars&quot;</span>)</span><br><span class="line">                .type(Scalars.GraphQLString)</span><br><span class="line">                .name(<span class="string">&quot;commentary&quot;</span>)</span><br><span class="line">                .type(Scalars.GraphQLString))</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line"><span class="type">GraphQLObjectType</span> <span class="variable">reviewType</span> <span class="operator">=</span> newObject()</span><br><span class="line">        .name(<span class="string">&quot;Review&quot;</span>)</span><br><span class="line">        .field(newFieldDefinition()</span><br><span class="line">                .name(<span class="string">&quot;stars&quot;</span>)</span><br><span class="line">                .type(GraphQLString))</span><br><span class="line">        .field(newFieldDefinition()</span><br><span class="line">                .name(<span class="string">&quot;commentary&quot;</span>)</span><br><span class="line">                .type(GraphQLString))</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line"><span class="type">GraphQLObjectType</span> <span class="variable">createReviewForEpisodeMutation</span> <span class="operator">=</span> newObject()</span><br><span class="line">        .name(<span class="string">&quot;CreateReviewForEpisodeMutation&quot;</span>)</span><br><span class="line">        .field(newFieldDefinition()</span><br><span class="line">                .name(<span class="string">&quot;createReview&quot;</span>)</span><br><span class="line">                .type(reviewType)</span><br><span class="line">                .argument(newArgument()</span><br><span class="line">                        .name(<span class="string">&quot;episode&quot;</span>)</span><br><span class="line">                        .type(episodeType)</span><br><span class="line">                )</span><br><span class="line">                .argument(newArgument()</span><br><span class="line">                        .name(<span class="string">&quot;review&quot;</span>)</span><br><span class="line">                        .type(reviewInputType)</span><br><span class="line">                )</span><br><span class="line">        )</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line"><span class="type">GraphQLCodeRegistry</span> <span class="variable">codeRegistry</span> <span class="operator">=</span> newCodeRegistry()</span><br><span class="line">        .dataFetcher(</span><br><span class="line">                coordinates(<span class="string">&quot;CreateReviewForEpisodeMutation&quot;</span>, <span class="string">&quot;createReview&quot;</span>),</span><br><span class="line">                mutationDataFetcher()</span><br><span class="line">        )</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">GraphQLSchema</span> <span class="variable">schema</span> <span class="operator">=</span> GraphQLSchema.newSchema()</span><br><span class="line">        .query(queryType)</span><br><span class="line">        .mutation(createReviewForEpisodeMutation)</span><br><span class="line">        .codeRegistry(codeRegistry)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure>

<p>请注意输入参数类型是 <code>GraphQLInputObjectType</code>.这是很重要的.输入类型只能是这种类型,绝不能使用输出类型如 <code>GraphQLObjectType</code>.标量类型既可以是输入类型也可以是输出类型.<br>这个 data fetcher 执行 mutation,返回一些有意义的输出值.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> DataFetcher <span class="title function_">mutationDataFetcher</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataFetcher</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Review <span class="title function_">get</span><span class="params">(DataFetchingEnvironment environment)</span> &#123;</span><br><span class="line">            Map&lt;String,Object&gt; episodeInputMap = environemnt.getArugment(<span class="string">&quot;episode&quot;</span>);</span><br><span class="line">            Map&lt;String,Object&gt; reviewInputMap = environment.getArugment(<span class="string">&quot;review&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">EpisodeInput</span> <span class="variable">episodeInput</span> <span class="operator">=</span> EpisodeInput.fromMap(episodeInputMap);</span><br><span class="line">            <span class="type">ReviewInput</span> <span class="variable">reviewInput</span> <span class="operator">=</span> ReviewInput.fromMap(reviewInputMap);</span><br><span class="line">            <span class="type">Review</span> <span class="variable">updatedReview</span> <span class="operator">=</span> reviewStore().update(episodeInput, reviewInput);</span><br><span class="line">            <span class="keyword">return</span> updatedReview;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="异步执行"><a href="#异步执行" class="headerlink" title="异步执行"></a>异步执行</h3><p>graphql-java 执行查询时可以完全支持异步执行.你可以通过调用 <code>executeAsync()</code> 获取 <code>CompletableFuture</code>的结果.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">GraphQL</span> <span class="variable">graphql</span> <span class="operator">=</span> buildSchema();</span><br><span class="line"><span class="type">ExecutionInput</span> <span class="variable">executionInput</span> <span class="operator">=</span> ExecutionInput.newExecutionInput().query(<span class="string">&quot;query &#123; hero &#123; name &#125;&#125;&quot;</span>).build();</span><br><span class="line">CompletableFuture&lt;ExecutionResult&gt; promise = graphql.executeAsync(executionInput);</span><br><span class="line">promise.thenAccept(executinoResult -&gt; &#123;</span><br><span class="line">    encodeResultToJsonAndSendResponse(executionResult);</span><br><span class="line">&#125;);</span><br><span class="line">promise.join();</span><br></pre></td></tr></table></figure>

<p>使用 <code>CompletableFuture</code> 可以在执行完成时组合 action 和 function.最终调用 <code>join()</code> 等待执行完成.<br>graphql-java 使用异步执行的原理是通过 join 调用通过方法<code>execute()</code>.所以下面的代码效果是一样的.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutionResult</span> <span class="variable">executionResult</span> <span class="operator">=</span> graphql.execute(executionInput);</span><br><span class="line">CompletableFuture&lt;ExecutionResult&gt; promise = graphql.executeAsync(executionInput);</span><br><span class="line"><span class="type">ExecutionResult</span> <span class="variable">executionResult</span> <span class="operator">=</span> promise.join();</span><br></pre></td></tr></table></figure>

<p>如果 <code>graphql.schema.DataFetcher</code> 返回的是 <code>CompletableFuture&lt;T&gt;</code> 对象,那么这个结果将被组合进整个异步查询执行中.这意味着你可以并行发起多个属性查询请求.你使用的线程池策略取决于你的 data fetcher 代码.<br>下面的代码采用了标准的 <code>java.util.concurrent.ForkJoinPool.commonPool()</code> 线程执行器在另外一个线程提供数据.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DataFetcher</span> <span class="variable">userDataFetcher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataFetcher</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(DataFetchingEnvironment environment)</span> &#123;</span><br><span class="line">        CompletableFuture&lt;User&gt; userPromise = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> fetchUserViaHttp(environment.getArgument(<span class="string">&quot;userId&quot;</span>));</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> userPromise;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码用 Java8 Lambdas 可以简略为:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DataFetcher</span> <span class="variable">userDataFetcher</span> <span class="operator">=</span> environment -&gt; CompletableFuture.supplyAsync(() -&gt; fetchUserViaHttp(environment.getArgument(<span class="string">&quot;userId&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>graphql-java 引擎确保所有的 <code>CompletableFuture</code> 对象遵照 graphql 规范组合在一起提供执行结果.<br>这是 graphql-java 创建异步 data fetcher 的快捷方式.使用 <code>graphql.schema.AsyncDataFetcher.async(DataFetcher&lt;T&gt;)</code> 包装一个 DataFetcher.可以使用静态导入创建更易读的代码.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DataFetcher</span> <span class="variable">userDataFetcher</span> <span class="operator">=</span> async(environment -&gt; fetchUserViaHttp(environment.getArgument(<span class="string">&quot;userId&quot;</span>)));</span><br></pre></td></tr></table></figure>

<h3 id="执行策略"><a href="#执行策略" class="headerlink" title="执行策略"></a>执行策略</h3><p>继承 <code>graphql.execution.ExecutionStrategy</code> 的类可以用于运行一个查询或修改. graphql-java 提供了大量不同的策略,如果你非常迫切,也可以使用自定义的.<br>当你创建 Graphql 对象时可以确定执行策略.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">GraphQL.newGraphQL(schema)</span><br><span class="line">        .queryExecutionStrategy(<span class="keyword">new</span> <span class="title class_">AsyncExecutionStrategy</span>())</span><br><span class="line">        .mutationExecutionStrategy(<span class="keyword">new</span> <span class="title class_">AsyncSerialExecutionStrategy</span>())</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure>

<p>实际上上面的代码和默认设置一致,大多数情况下是一个明智的策略选择.</p>
<h3 id="异步执行策略"><a href="#异步执行策略" class="headerlink" title="异步执行策略"></a>异步执行策略</h3><p>默认的查询执行策略是 <code>graphql.execution.AsyncExecutionStrategy</code>,会把每一个属性作为 <code>CompletableFuture</code> 对象分发,并且不关心哪个最先完成.此策略是性能最佳的执行策略.<br>data fetchers 本身会返回 <code>CompletionStage</code> 值,这将导致完全异步的行为.</p>
<figure class="highlight graphql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">query</span> <span class="punctuation">&#123;</span></span><br><span class="line">	hero <span class="punctuation">&#123;</span></span><br><span class="line">		enemies <span class="punctuation">&#123;</span></span><br><span class="line">			name</span><br><span class="line">		<span class="punctuation">&#125;</span></span><br><span class="line">		friends <span class="punctuation">&#123;</span></span><br><span class="line">			name</span><br><span class="line">		<span class="punctuation">&#125;</span></span><br><span class="line">	<span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><code>AsyncExecutionStrategy</code> 自由分发 <i>enemies</i> 属性和 <i>friends</i>属性.<i>enemies</i> 属性不必等待 <i>friends</i>属性返回.这是非常低效的.<br>无论如何,最终会将结果按顺序排列.查询结果将遵照 graphql 规范,返回结果对应 query 属性顺序.只有 data fetcher 的执行是随机顺序.</p>
<h3 id="异步序列化执行策"><a href="#异步序列化执行策" class="headerlink" title="异步序列化执行策"></a>异步序列化执行策</h3><p>graphql 规范要求 mutation 必须按照 query 属性的顺序序列化执行.<br>所以 mutation 默认使用 <code>graphql.execution.AsyncSerialExecutionStrategy</code> 策略.它会保证在执行下一个和后面前当前的每个属性执行完毕.也可以在 mutation data fetcher 中返回 <code>CompletionStage</code> 对象,并且会按顺序在下一个 mutation 属性 data fetcher 被分发之前执行完毕.</p>
<h3 id="订阅执行策略"><a href="#订阅执行策略" class="headerlink" title="订阅执行策略"></a>订阅执行策略</h3><p>graphql 允许对 graphql data 创建有状态的订阅.可以使用 <code>SubscriptionExecutionStrategy</code>实现,同时支持 reactive-stream API.<br><a href="https://www.graphql-java.com/documentation/v12/subscriptions">查看</a>了解更多基于 graphql 服务的订阅支持.</p>
<h3 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h3><p>在 graphql-java 引擎执行查询之前必须被解析和检验,并且这个处理过程可能有些耗时.<br>为了避免重复解析&#x2F;校验<code>GraphQL.Builder</code>允许<code>PreparsedDocumentProvider</code>实例复用<code>Document</code>实例.<br>注意 ⚠️,这只缓存解析的 <code>Document</code>,不缓存查询结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cache&lt;String,PreparsedDocumentEntry&gt; cache = Caffeine.newBuilder().maximumSize(<span class="number">10_000</span>).build();</span><br><span class="line"><span class="type">GraphQL</span> <span class="variable">graphql</span> <span class="operator">=</span> GraphQL.newGraphQL(StarWarsSchema.starWarsSchema)</span><br><span class="line">        .preparsedDocumentProvider(cache::get)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure>

<ul>
<li>这个缓存实例应该是线程安全共享的.</li>
<li><code>PreparsedDocumentProvider</code> 是一个只有一个 get 方法的函数接口,我们可以传递一个方法引用到里面以匹配 builder 的签名.</li>
</ul>
<p>为了实现高缓存覆盖率,推荐属性参数通过变量传递而不是直接在 query 中定义.<br>下面的查询:</p>
<figure class="highlight graphql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">query</span> HelloTo <span class="punctuation">&#123;</span></span><br><span class="line">	sayHello<span class="punctuation">(</span><span class="symbol">to</span><span class="punctuation">:</span> <span class="string">&quot;ME&quot;</span><span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">		greeting</span><br><span class="line">	<span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>应该这样写:</p>
<figure class="highlight graphql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">query</span> HelloTo<span class="punctuation">(</span><span class="variable">$to</span>: String<span class="punctuation">!</span><span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">	sayHello<span class="punctuation">(</span><span class="symbol">to</span><span class="punctuation">:</span> <span class="variable">$to</span>) <span class="punctuation">&#123;</span></span><br><span class="line">		greeting</span><br><span class="line">	<span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>和变量</p>
<figure class="highlight graphql"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="string">&quot;to&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Me&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>现在就可以不管提供的变量是什么而重用查询.</p>
]]></content>
  </entry>
  <entry>
    <title>GraphQL-Scalars</title>
    <url>/2019/05/05/08/</url>
    <content><![CDATA[<p>scalars</p>
<span id="more"></span>
<h2 id="graphql-中的常量"><a href="#graphql-中的常量" class="headerlink" title="graphql 中的常量"></a>graphql 中的常量</h2><h3 id="scalars"><a href="#scalars" class="headerlink" title="scalars"></a>scalars</h3><p>graphql 类型系统的叶子节点被称为 scalars.一旦到达了 scalar 类型则无法在沿着类型结构继续向下了.scalar 类型是指不可再分割的值.<br>graphql 规范明确要求所有的语言实现必须具有以下 scalar 类型.</p>
<ul>
<li>String 即 <code>GraphQLString</code>- 一个 UTF-8 字符串序列.</li>
<li>Boolean 即 <code>GraphQLBoolean</code>- true or false.</li>
<li>Int 即 <code>GraphQLInt</code>- 有符号的 32 整型数.</li>
<li>Float 即 <code>GraphQLFloat</code>- 有符号的双精度浮点数.</li>
<li>ID 即 <code>GraphQLID</code>- 类似于 String 的唯一标识符.定义一个 ID 标识符即表示该属性不是人类可识别的用途.<br>graphql-java 为 java 系统添加了以下有用的 scalar 类型.</li>
<li>Long 即 <code>GraphQLLong</code>- 基于 java.lang.Long 的 scalar.</li>
<li>Short 即 <code>GraphQLShort</code>- 基于 java.lang.Short 的 scalar.</li>
<li>Byte 即 <code>GraphQLByte</code>- 基于 java.lang.Byte 的 scalar.</li>
<li>BigDecimal 即 <code>GraphQLBigDicimal</code> 基于 java.math.BigDecimal 的 scalar.</li>
<li>BigInteger 即 <code>GrapQLBigInteger</code> 基于 java.math.BigInteger 的 scalar.</li>
</ul>
<p><code>graphql.Scalars</code>类包含了提供 scalar 类型的单例实例.</p>
<h3 id="自定义-scalars"><a href="#自定义-scalars" class="headerlink" title="自定义 scalars"></a>自定义 scalars</h3><p>你可以实现自定义 scalar.在运行时你需要完成类型强制转换,后面会解释.假设我们需要一个 email 的 scalar 类型.它把 email 地址作为输入输出.<br>我们将创建一个如下的 <code>graphql.schema.GraphQLScalarType</code> 单例实例.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">GraphQLScalarType</span> <span class="variable">EMAIL</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GraphQLScalarType</span>(<span class="string">&quot;email&quot;</span>,<span class="string">&quot;A cusom scalar that handles emails&quot;</span>,<span class="keyword">new</span> <span class="title class_">Coercing</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">serialize</span><span class="params">(Object dataFetcehrResult)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> serilizeEmail(dataFetcherResult);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">parseValue</span><span class="params">(Object input)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> parseEmailFromVariable(input);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">parseLiteral</span><span class="params">(Object input)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> parseEmailFromAstLiteral(input);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p>自定义 scalar 实现的真正作用点在 <code>graphql.schema.Coercing</code>实现.有 3 个函数需要实现</p>
<ul>
<li><code>parseValue</code>- 接收一个输入变量,转换为 java 运行时实现.</li>
<li><code>parseLiteral</code>-接收一个 AST 字符 <code>graphql.language.Value</code> 作为输入,转换为 java 运行时实现.</li>
<li><code>serialize</code>-接收一个 Java 对象,最终转为 scalar 输出类型.<br>所以你自定义的 scalar 实现需要处理 2 中类型的输入(parseValue&#x2F;parseLiteral)和 1 中输出(serialize).<br>如下查询,使用了变量,AST 字符然后输出我们需要的 scalar 类型 email.</li>
</ul>
<figure class="highlight graphql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mutation</span> Contact<span class="punctuation">(</span><span class="variable">$mainContact</span>: Email<span class="punctuation">!</span><span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">	makeContact<span class="punctuation">(</span></span><br><span class="line">		<span class="symbol">mainContactEmail</span><span class="punctuation">:</span> <span class="variable">$mainContact</span></span><br><span class="line">		<span class="symbol">backupContactEmial</span><span class="punctuation">:</span> <span class="string">&quot;backup@company.com&quot;</span></span><br><span class="line">	<span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">		id</span><br><span class="line">		mainContactEmail</span><br><span class="line">	<span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>我们的自定义 email scalar 类型将</p>
<ul>
<li>调用 <code>parseValue</code> 将 <code>$mainContact</code>变量转为运行时对象.</li>
<li>调用 <code>parseLiteral</code> 将 AST <code>graphql.language.StringValue</code> “<a href="mailto:&#98;&#x61;&#x63;&#x6b;&#x75;&#x70;&#x40;&#99;&#111;&#109;&#112;&#x61;&#x6e;&#121;&#46;&#x63;&#x6f;&#x6d;">&#98;&#x61;&#x63;&#x6b;&#x75;&#x70;&#x40;&#99;&#111;&#109;&#112;&#x61;&#x6e;&#121;&#46;&#x63;&#x6f;&#x6d;</a>“ 转换为运行时对象.</li>
<li>调用 <code>serialize</code> 将 mainContactEmial 运行时实现转为输出对象形式.</li>
</ul>
<h3 id="输入输出校验"><a href="#输入输出校验" class="headerlink" title="输入输出校验"></a>输入输出校验</h3><p>例如我们的 email scalar 将会校验输入输出是否是真是的 email 地址.<br><code>graphql.schema.Coercing</code> 协议如下:</p>
<ul>
<li><code>serialize</code> 只允许抛出 <code>graphql.schema.CoercingSerializeException</code>.这表明值无法被序列化为合适的形式.决不允许指定其他运行时异常以取得普通的 graphql 校验行为.必须返回一个非 <code>null</code> 值.</li>
<li><code>parseValue</code> 只允许抛出 <code>graphql.schema.CoercingParseValueException</code>.这表明值无法被作为输入解析为合适的形式..决不允许指定其他运行时异常以取得普通的 graphql 校验行为.必须返回一个非 <code>null</code> 值.</li>
<li><code>parseLiteral</code> 只允许抛出 <code>graphql.schema.CoercingParseLiterialException</code>.这表明 AST 值无法被作为输入解析为合适的形式..决不允许指定其他运行时异常以取得普通的 graphql 校验行为.<br>有的人尝试依赖运行时异常校验以期获取普通的 graphql 错误.这是行不通的.必须遵照 <code>Coercing</code> 方法协议使 graphql-java 引擎按照 grapqhl 的 scalar 类型规范运行.</li>
</ul>
<h3 id="示例实现"><a href="#示例实现" class="headerlink" title="示例实现"></a>示例实现</h3><p>下面是一个简单的 email scalar 类型实现,展示了如何通过继承 <code>Coercing</code> 实现一个 scalar.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">EmailScalar</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">GraphQLScalarType</span> <span class="variable">EMAIL</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GraphQLScalarType</span>(<span class="string">&quot;email&quot;</span>,<span class="string">&quot;A custom scalar that handles emails&quot;</span>,<span class="keyword">new</span> <span class="title class_">Coercing</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">serialize</span><span class="params">(Object dataFetcherResult)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> serializeEmail(dataFetcherResult);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">parseValue</span><span class="params">(Object input)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> parseEmailFromVariable(input);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">parseLiterial</span><span class="params">(Object input)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> parseEmialFromAstLiterial(input);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">looksLikeAnEmailAddress</span><span class="params">(String possibleEmailValue)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Pattern.matches(<span class="string">&quot;[A-Za-z0-9]@[.*]&quot;</span>,possibleEmailValue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title function_">serialzeEmail</span><span class="params">(Object dataFetcherResult)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">possibleEmailValue</span> <span class="operator">=</span> String.valueOf(dataFetcherResult);</span><br><span class="line">        <span class="keyword">if</span> (looksLikeAnEmailAddress(possibleEmailValue)) &#123;</span><br><span class="line">            <span class="keyword">return</span> possibleEmailValue;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CoercingSerializeException</span>(<span class="string">&quot;Unable to serialize&quot;</span> + possibleEmailValue + <span class="string">&quot; as an email address&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title function_">parseEmailFromVariable</span><span class="params">(Object input)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (input <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">possibleEmailValue</span> <span class="operator">=</span> input.toString();</span><br><span class="line">            <span class="keyword">if</span> (looksLikeAnEmailAddress(possibleEmailValue)) &#123;</span><br><span class="line">                <span class="keyword">return</span> possibleEmailValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CoercingParseValueException</span>(<span class="string">&quot;Unable to parse variable value &quot;</span> + input + <span class="string">&quot; as an email address&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title function_">parseEmailFromAstLiterial</span><span class="params">(Object input)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (input <span class="keyword">instanceof</span> StringValue) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">possibleEmailValue</span> <span class="operator">=</span> ((StringValue)input).getValue();</span><br><span class="line">            <span class="keyword">if</span> (looksLikeAnEmailAddress(possibleEmailValue)) &#123;</span><br><span class="line">                <span class="keyword">return</span> possibleEmailValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CoercingParseLiterialException</span>(<span class="string">&quot;Unable to parse variable value &quot;</span> + input + <span class="string">&quot; as an email address&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>GraphQL-DataFetcher</title>
    <url>/2019/04/27/22/</url>
    <content><![CDATA[<p>data fetcher</p>
<span id="more"></span>
<h2 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h2><h3 id="graphql-如何获取数据"><a href="#graphql-如何获取数据" class="headerlink" title="graphql 如何获取数据"></a>graphql 如何获取数据</h3><p>graphql 中的每个属性都关联了一个 graphql.schema.DataFetcher.<br>一些属性会使用专用的 data fetcher 从数据库获取该属性的相关信息.而大多数简单的使用属性名和 Plain Old Java Object(POJO)模式 从内存中获取数据.<br><code>在其他 graphql 实现中，Data fetcher 被称为 resolver</code><br>现在声明一个类型定义:</p>
<figure class="highlight graphql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="keyword">Query</span> <span class="punctuation">&#123;</span></span><br><span class="line">	products<span class="punctuation">(</span><span class="symbol">match</span><span class="punctuation">:</span> String<span class="punctuation">)</span><span class="punctuation">:</span> <span class="punctuation">[</span>Product<span class="punctuation">]</span> <span class="comment"># a list of products</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Product <span class="punctuation">&#123;</span></span><br><span class="line">	<span class="symbol">id</span><span class="punctuation">:</span> ID</span><br><span class="line">	<span class="symbol">name</span><span class="punctuation">:</span> String</span><br><span class="line">	<span class="symbol">description</span><span class="punctuation">:</span> String</span><br><span class="line">	<span class="symbol">cost</span><span class="punctuation">:</span> Float</span><br><span class="line">	<span class="symbol">tax</span><span class="punctuation">:</span> Float</span><br><span class="line">	launchDate<span class="punctuation">(</span><span class="symbol">dateFormat</span><span class="punctuation">:</span> String <span class="punctuation">=</span> <span class="string">&quot;dd,MM,yyyy&quot;</span><span class="punctuation">)</span><span class="punctuation">:</span> String</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>DataFetcher</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter desktop support</title>
    <url>/2020/02/18/49/</url>
    <content><![CDATA[<p>当前 Flutter 对桌面开发环境的支持正在开发中.</p>
<span id="more"></span>
<h3 id="macOS"><a href="#macOS" class="headerlink" title="macOS"></a>macOS</h3><p>macOS 是当前最成熟的桌面开发平台(仅 flutter 而言),已经进入 alpha 阶段.</p>
<h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>Windows shell 处于 technical preview.当前是基于 Win32 的,但计划后续探索 UWP 支持.<br>注意:最终定型版本的 API 可能和当前有明显差异.</p>
<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p>当前 Linux shell 仅仅是 GLFW 的替代品,来探索 Linux 桌面实现,未来可能会被替换成其他实现.<br>将来你的应用无论是使用 GTK+,Qt,WxWidgets,Motif 或其他任意开发工具套件都可以通过 Flutter 来创建 library,但是当前还没想好如何规划.当前计划先无条件支持 GTK+,然后慢慢支持其他.</p>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h3 id="create"><a href="#create" class="headerlink" title="create"></a><code>create</code></h3><p>当前,只有 macOS 支持<code>flutter create</code>.对于 Windows 和 Linux,推荐参考 <code>flutter-desktop-embedding project</code>.</p>
<h4 id="覆盖目标平台"><a href="#覆盖目标平台" class="headerlink" title="覆盖目标平台"></a>覆盖目标平台</h4><p>大部分应用需要覆盖支持的应用平台对应的值，否则会出现<code>Unknown platform</code> 异常.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#x27;package:flutter/foundation.dart&#x27; show debugDefaultTargetPlatformOverride;</span><br><span class="line"></span><br><span class="line">void _setTargetPlatformForDesktop() &#123;</span><br><span class="line">    if (Platform.isLiinux || Platform.isWindows) &#123;</span><br><span class="line">        debugDefaultTargetPlatformOverride = TargetPlatform.fuchsia;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()&#123;</span><br><span class="line">    _setTargetPlatformForDesktop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>JGit</title>
    <url>/2019/03/16/07/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>JGit 是一个基于 EDL(BSD 协议的变种)授权的轻量级、实现 Git 版本控制系统功能(常规仓库访问,网络协议,版本控制核心算法)的纯 Java 库.</p>
<span id="more"></span>
<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><h3 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h3><p>在<a href="https://mvnrepository.com/">仓库搜索引擎</a>中搜索 jgit 即可获取各种添加依赖的方式.我现在基本使用的是 gradle 依赖</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">implementation(<span class="string">&quot;org.eclipse.jgit:org.eclipse.jgit:5.3.0.201903130848-r&quot;</span>)</span><br><span class="line">implementation(<span class="string">&quot;org.eclipse.jgit:org.eclipse.jgit.http.server:5.3.0.201903130848-r&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>JGit 也具有 CLI(功能比 git CLI 少),可以试一下 JGit 的功能.</p>
<h4 id="手动编译-JGit-CLI"><a href="#手动编译-JGit-CLI" class="headerlink" title="手动编译 JGit CLI"></a>手动编译 JGit CLI</h4><p>假设已经 clone EGit 仓库. <code>git clone https://git.eclipse.org/r/jgit/jgit.git</code> <a href="https://wiki.eclipse.org/EGit/Contributor_Guide#JGit">具体查看</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~/src/jgit$ mvn clean install</span><br><span class="line"><span class="comment"># 进入 jgit 可执行文件所在文件夹</span></span><br><span class="line">org.eclipse.jgit.pgm/target/jgit</span><br><span class="line"><span class="comment"># 查看 version 命令</span></span><br><span class="line">prompt$ ./jgit version</span><br><span class="line">jgit version xxxxx</span><br><span class="line"><span class="comment"># 如果经常使用 jgit 命令,可以添加执行链接(通常在 /usr/local/bin)</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">ln</span> -s /path/to/jgit /usr/local/bin/jgit</span><br></pre></td></tr></table></figure>

<h4 id="在-JGit-CLI-运行命令"><a href="#在-JGit-CLI-运行命令" class="headerlink" title="在 JGit CLI 运行命令"></a>在 JGit CLI 运行命令</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">prompt$ ./git</span><br><span class="line"><span class="comment"># 会列出最常用的命令</span></span><br><span class="line">jgit --git-dir GIT_DIR --<span class="built_in">help</span> (-h) --show-stack-trace <span class="built_in">command</span> [ARG ...]</span><br><span class="line"></span><br><span class="line">The most commonly used commands are:</span><br><span class="line"> branch   List, create, or delete branches</span><br><span class="line"> <span class="built_in">clone</span>    Clone a repository into a new directory</span><br><span class="line"> commit   Record changes to the repository</span><br><span class="line"> daemon   Export repositories over git://</span><br><span class="line"> diff     Show diffs</span><br><span class="line"> fetch    Update remote refs from another repository</span><br><span class="line"> init     Create an empty git repository</span><br><span class="line"> <span class="built_in">log</span>      View commit <span class="built_in">history</span></span><br><span class="line"> push     Update remote repository from <span class="built_in">local</span> refs</span><br><span class="line"> <span class="built_in">rm</span>       Stop tracking a file</span><br><span class="line"> tag      Create a tag</span><br><span class="line"> version  Display the version of jgit</span><br><span class="line"></span><br><span class="line"> <span class="comment"># 常用的 debug test 命令</span></span><br><span class="line"> prompt$ ./jgit debug-show-commands</span><br></pre></td></tr></table></figure>

<h5 id="查看仓库"><a href="#查看仓库" class="headerlink" title="查看仓库"></a>查看仓库</h5><p>在查看最常用的命令之前，你可能想知道该仓库包含了多少分支，当前分支是那个.使用 branch -v 可以获取所有分支的简略信息，版本号，版本号提交信息的第一行.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">prompt$ ./jgit branch -v</span><br><span class="line"><span class="comment">#  master       4d4adfb Git Project import: don&#x27;t hide but gray out existing projects</span></span><br><span class="line"><span class="comment"># * traceHistory 6b9fe04 [historyView] Add trace instrumentation</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 和 git-log 一样 log 命令显示提交信息</span></span><br><span class="line">jgit <span class="built_in">log</span> --author Math --grep tycho master</span><br><span class="line"><span class="comment"># 显示 master 分钟中，作者名包含 Math,提交信息包含 tycho 的搜有提交信息.</span></span><br><span class="line"><span class="comment"># commit xxxx</span></span><br><span class="line"><span class="comment"># Author: Math xxxx</span></span><br><span class="line"><span class="comment"># Date: xxx</span></span><br><span class="line"><span class="comment"># Update build to use tycho x.xx.x</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="comment"># 大多数的搜索都会精确过滤提交日志，如提交者姓名等</span></span><br></pre></td></tr></table></figure>

<h5 id="历史图形化"><a href="#历史图形化" class="headerlink" title="历史图形化"></a>历史图形化</h5><p><code>jgit glog</code></p>
<h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><h4 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h4><p>Repository 管理所有的项目和引用，管理代码</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> repository = FileRepositoryBuilder()</span><br><span class="line">    .setGitDir(File(<span class="string">&quot;/my/git/directory&quot;</span>))</span><br><span class="line">    .readEnvironment() <span class="comment">// 扫描 GIT_* 环境变量</span></span><br><span class="line">    .findGitDir() <span class="comment">// 扫描文件系统</span></span><br><span class="line">    .build()</span><br></pre></td></tr></table></figure>

<h4 id="Git-对象"><a href="#Git-对象" class="headerlink" title="Git 对象"></a>Git 对象</h4><p>在 Git object model 所有的对象都是由 SHA-1 id 表示.在 JGit 中是由 <code>AnyObjectId</code> 和 <code>ObjectId</code>类表示.<br>在 Git object model 中定义了四种对象类型:</p>
<ul>
<li>blob: 用于存储文件对象</li>
<li>tree: 可以看作一个文件夹，指向其他的 tree 或 blob</li>
<li>commit: 指向一个 tree 的提交信息</li>
<li>tag: 突出提交信息,通常用来标记特殊的 release 版本.</li>
</ul>
<p>为了从一个仓库中识别一个对象，只要传入一个正确的 revision 字符串即可</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> head = repository.resolve(<span class="string">&quot;HEAD&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h4><p>ref 是一个包含单个对象标识符的变量.对象标识符可以是任何 Git 合法对象(blob,tree,commit,tag)<br>例如,获取 head 的引用.</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> HEAD = repository.findRef(<span class="string">&quot;refs/heads/master&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="RevWalk"><a href="#RevWalk" class="headerlink" title="RevWalk"></a>RevWalk</h4><p>RevWalk 遍历 commit graph，并按顺序生成匹配的 commit</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> revWalk = RevWalk(repository)</span><br></pre></td></tr></table></figure>

<h4 id="RevCommit"><a href="#RevCommit" class="headerlink" title="RevCommit"></a>RevCommit</h4><p>RevCommit 表示 Git object model 中的一个 commit</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> commit = walk.parseCommit(objectIdOfCommit);</span><br></pre></td></tr></table></figure>

<h4 id="RevTag"><a href="#RevTag" class="headerlink" title="RevTag"></a>RevTag</h4><p>RevCommit 表示 Git object model 中的一个 Tag</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> tag = walk.parseCommit(objectIdOfTag);</span><br></pre></td></tr></table></figure>

<h4 id="RevTree"><a href="#RevTree" class="headerlink" title="RevTree"></a>RevTree</h4><p>RevCommit 表示 Git object model 中的一个 tree</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> tree = walk.parseCommit(objectIdOfTree);</span><br></pre></td></tr></table></figure>

<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>虽然 JGit 包含了许多和 Git 仓库交互的低级代码，同时还有一些参考<code>org.eclipse.jgit.apit</code>包中 Git porcelain 命令的高级 API.</p>
<h4 id="添加命令-git-add"><a href="#添加命令-git-add" class="headerlink" title="添加命令(git-add)"></a>添加命令(git-add)</h4><p>add 命令可以向索引中添加文件，同时可以通过 setter 方法配置</p>
<ul>
<li>addFilepattern()</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> git = Git(repository)</span><br><span class="line">git.add()</span><br><span class="line">    .addFilepattern(<span class="string">&quot;/dir&quot;</span>)</span><br><span class="line">    .call()</span><br></pre></td></tr></table></figure>

<h4 id="提交命令-git-commit"><a href="#提交命令-git-commit" class="headerlink" title="提交命令(git-commit)"></a>提交命令(git-commit)</h4><ul>
<li>setAuthor()</li>
<li>setCommitter()</li>
<li>setAll()</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">git.commit()</span><br><span class="line">    .setAuthor(<span class="string">&quot;author&quot;</span>,<span class="string">&quot;email&quot;</span>)</span><br><span class="line">    .setMessage(<span class="string">&quot;message&quot;</span>)</span><br><span class="line">    .call()</span><br></pre></td></tr></table></figure>

<h4 id="tag-命令-git-tag"><a href="#tag-命令-git-tag" class="headerlink" title="tag 命令(git-tag)"></a>tag 命令(git-tag)</h4><ul>
<li>setName()</li>
<li>setMessage()</li>
<li>setTagger()</li>
<li>setObjectId()</li>
<li>setForceUpdate()</li>
<li>setSigned(): 暂不支持，会抛异常</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">git.tag()</span><br><span class="line">    .setName(<span class="string">&quot;tag&quot;</span>)</span><br><span class="line">    .call()</span><br></pre></td></tr></table></figure>

<h4 id="log-命令-git-log"><a href="#log-命令-git-log" class="headerlink" title="log 命令(git-log)"></a>log 命令(git-log)</h4><ul>
<li>add(AnyObjectId start)</li>
<li>addRange(AnyObjectId since,AnyObjectId until)</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">git.log()</span><br><span class="line">    .add(head)</span><br><span class="line">    .call()</span><br></pre></td></tr></table></figure>

<h4 id="merge-命令-git-merge"><a href="#merge-命令-git-merge" class="headerlink" title="merge 命令(git-merge)"></a>merge 命令(git-merge)</h4><p>TODO</p>
<h4 id="Ant-任务"><a href="#Ant-任务" class="headerlink" title="Ant 任务"></a>Ant 任务</h4><p>JGit 在 <code>org.eclipse.jgit.ant</code> 包中提供了 Ant 任务功能.<br>添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">taskdef</span> <span class="attr">resource</span>=<span class="string">&quot;org/eclipse/jgti/ant/ant-tasks.properties&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">classpath</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pathelement</span> <span class="attr">location</span>=<span class="string">&quot;path/to/org.eclipse.jgit.ant-VERSION.jar&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pathelement</span> <span class="attr">location</span>=<span class="string">&quot;path/to/org.eclipse.jgit-VERSION.jar&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pathelement</span> <span class="attr">location</span>=<span class="string">&quot;path/to/jsch-0.1.44-1.jar&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">classpath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">taskdef</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>提供了 <code>git-clone、git-init、git-checkout</code>任务.</p>
<h4 id="git-clone"><a href="#git-clone" class="headerlink" title="git-clone"></a>git-clone</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">git-clone</span> <span class="attr">uri</span>=<span class="string">&quot;http://egit.eclipse.org/jgit.git&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>uri(必须)</li>
<li>dest(可选): 克隆的目标文件地址.默认使用基于 uri 路径最后一个组件作为可识别的名称的文件夹.</li>
<li>bare(可选): true&#x2F;false&#x2F;yes&#x2F;no 表示是否克隆 bare 仓库. 默认 false</li>
<li>branch(可选): 默认 HEAD</li>
</ul>
<h4 id="git-init"><a href="#git-init" class="headerlink" title="git-init"></a>git-init</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">git-init</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>dest(可选): 默认 $GIT_DIR 或当前文件夹</li>
<li>bare(可选)</li>
</ul>
<h4 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git-checkout"></a>git-checkout</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">git-checkout</span> <span class="attr">src</span>=<span class="string">&quot;path/to/repo&quot;</span> <span class="attr">branch</span>=<span class="string">&quot;origin/experimental&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>src(必须)</li>
<li>branch(必须)</li>
<li>createbranch(可选): true&#x2F;false&#x2F;yes&#x2F;no 是否会创建新 branch。默认 false.</li>
<li>force(可选): true&#x2F;false&#x2F;yes&#x2F;no 如果 true&#x2F;yes,命名的 branch 已存在，已存在 branch 的起点将会被设置到新的起点。如果 false,存在的 branch 不会被改变.默认 false.</li>
</ul>
<h4 id="git-add"><a href="#git-add" class="headerlink" title="git-add"></a>git-add</h4><p>TODO</p>
<h3 id="代码片段"><a href="#代码片段" class="headerlink" title="代码片段"></a>代码片段</h3><h4 id="获取某一提交记录的子记录"><a href="#获取某一提交记录的子记录" class="headerlink" title="获取某一提交记录的子记录"></a>获取某一提交记录的子记录</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">PlotWalk</span> <span class="variable">revWalk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PlotWalk</span>(repo());</span><br><span class="line"><span class="type">ObjectId</span> <span class="variable">rootId</span> <span class="operator">=</span> (branch == <span class="literal">null</span>) ? repo().resolve(HEAD) : branch.getObjectId();</span><br><span class="line"><span class="type">RevComment</span> <span class="variable">root</span> <span class="operator">=</span> revWalk.parseCommit(rootId);</span><br><span class="line">revWalk.markStart(root);</span><br><span class="line">PlotCommitList&lt;PlotLane&gt; plotCommitList = <span class="keyword">new</span> <span class="title class_">PlotCommitList</span>&lt;PlotLane&gt;();</span><br><span class="line">plotCOmmitList.source(revWalk);</span><br><span class="line">plotCommitList.fillTo(Integer.MAX_VALUE);</span><br><span class="line"><span class="keyword">return</span> revWalk;</span><br></pre></td></tr></table></figure>

<h3 id="高级主题"><a href="#高级主题" class="headerlink" title="高级主题"></a>高级主题</h3><h4 id="使用-RevWalk-减少内存使用"><a href="#使用-RevWalk-减少内存使用" class="headerlink" title="使用 RevWalk 减少内存使用"></a>使用 RevWalk 减少内存使用</h4><p>revision walk 接口和 RevWalk，RevCommit 类轻量级设计。然而当面对相当大的仓库时它们可能仍然需要很多内存。接下来提供了一些方法在遍历修订图(walking the revision graph)时减少内存。</p>
<h4 id="限制遍历修订图-Restrict-the-walked-revision-graph"><a href="#限制遍历修订图-Restrict-the-walked-revision-graph" class="headerlink" title="限制遍历修订图(Restrict the walked revision graph)"></a>限制遍历修订图(Restrict the walked revision graph)</h4><p>仅遍历那些必要的图.即如果查找 refs&#x2F;heads&#x2F;master 而不是 refs&#x2F;remotes&#x2F;origin&#x2F;master 的提交记录,确保对 refs&#x2F;heads&#x2F;master 调用 markStart(),对 refs&#x2F;remotes&#x2F;origin&#x2F;master 调用 markUninteresting(). RevWalk traversal 讲只解析对你有用的提交记录,而且会避免在历史记录中查询.这讲减少内部 object map 的大小,因此减少整体内存占用.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">RevWalk</span> <span class="variable">walk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RevWalk</span>(repository);</span><br><span class="line"><span class="type">ObjectId</span> <span class="variable">from</span> <span class="operator">=</span> repository.resolve(<span class="string">&quot;refs/heads/master&quot;</span>);</span><br><span class="line"><span class="type">ObjectId</span> <span class="variable">to</span> <span class="operator">=</span> repository.resolve(<span class="string">&quot;refs/remotes/origin/master&quot;</span>);</span><br><span class="line"></span><br><span class="line">walk.markStart(walk.parseCommit(from));</span><br><span class="line">walk.markUnInteresting(walk.parseCommit(to));</span><br></pre></td></tr></table></figure>

<h4 id="丢弃提交记录内容"><a href="#丢弃提交记录内容" class="headerlink" title="丢弃提交记录内容"></a>丢弃提交记录内容</h4><p><code>setRetainBody(false)</code> 可以用来丢弃提交记录内容，如果你不需要作者，提交者，或信息等.不需要该数据的例子如只使用 RevWalk 完成 branch merge 或使用 git rev-list 完成相关功能.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">RevWalk</span> <span class="variable">walk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RevWalk</span>(repository);</span><br><span class="line">walk.setRetainBody(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>如果确实需要这些信息，可以考虑拆分你需要的数据然后对 RevCommit 调用 dispose().如果需要长时间使用这些信息,你会发现 JGit 内部使用的内存比你自己处理占用的内存要少，特别是需要全部的信息时。这是因为 JGit 内部使用 byte 数组保存 UTF-8 编码的信息.如果使用 UTF-16 编码的 Java String 占内存将会变大，假设大部分的消息是 US-ASCII 编码的.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">RevWalk</span> <span class="variable">walk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RevWalk</span>(repository);</span><br><span class="line">Set&lt;String&gt; authorEmails = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line"><span class="keyword">for</span> (RevCommit commit : walk) &#123;</span><br><span class="line">    authorEmails.add(commit.getAuthorIdent().getEmailAddress());</span><br><span class="line">    commit.dispose();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RevWalk-和-RevCommit-的子类"><a href="#RevWalk-和-RevCommit-的子类" class="headerlink" title="RevWalk 和 RevCommit 的子类"></a>RevWalk 和 RevCommit 的子类</h4><p>如果需要获取某个提交记录的更多信息，可以考虑使用 RevWalk RevCommit 的子类, RevWalk.createCommit() 构建 RevCommit 子类的实例。然后将更多的信息存入 RevCommit 子类,这样就不需要额外的 HashMap 将 RevCommit 或 ObjectId 转换为 自定义的数据属性.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReviewedRevision</span> <span class="keyword">extends</span> <span class="title class_">RevCommit</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Date reviewDate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">ReviewedRevision</span><span class="params">(AnyObjectId id,Date reviewDate)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(id);</span><br><span class="line">        <span class="built_in">this</span>.reviewDate = reviewDate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">getReviewedBy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getFooterLines(<span class="string">&quot;Reviewed-by&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">getReviewDate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> reviewDate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Walk</span> <span class="keyword">extends</span> <span class="title class_">RevWalk</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Walk</span><span class="params">(Repository repo)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(repo);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> RevCommit <span class="title function_">createCommit</span><span class="params">(AnyObjectId id)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReviewedRevision</span>(id,getReviewDate(id));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Date <span class="title function_">getReviewDate</span><span class="params">(AnyObjectId id)</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="遍历修订后清理"><a href="#遍历修订后清理" class="headerlink" title="遍历修订后清理"></a>遍历修订后清理</h4><p>RevWalk 无法缩小内部的 object map.如果刚完成了遍历仓库的所有历史，这将会将所有东西加载到 object map，并且无法被释放.如果再不需要这些数据，好的习惯是丢弃这个 RevWalk，然后为下次遍历重新申请新的 RevWalk。这样 GC 就会回收垃圾。另外，重用一个存在 的 object map 比完全重新创建一个新的更快.所以你需要平衡内存回收和用户渴望更快的操作之间的关系.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">RevWalk</span> <span class="variable">walk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RevWalk</span>(repository);</span><br><span class="line"><span class="keyword">for</span> (RevCommit commit : walk) &#123;&#125;</span><br><span class="line">walk.repository();</span><br></pre></td></tr></table></figure>

<h3 id="功能列表"><a href="#功能列表" class="headerlink" title="功能列表"></a>功能列表</h3><ul>
<li>通用仓库操作<ul>
<li><a href="">打开存在的 git 仓库</a></li>
<li><a href="">创建新的 git 仓库</a></li>
</ul>
</li>
<li>git 命令支持<ul>
<li><a href="">初始化新的仓库</a></li>
<li><a href="">添加新文件到索引中</a></li>
<li><a href="">向存在的仓库提交文件</a></li>
<li><a href="">提交所有更改</a></li>
<li><a href="">列出提交记录,如 Log</a></li>
<li><a href="">列出仓库的所有标签</a></li>
<li><a href="">列出仓库的所有分支</a></li>
<li><a href="">列出仓库的所有提交记录</a></li>
<li><a href="">列出仓库所有未提交的更改</a></li>
<li><a href="">创建&#x2F;删除分支</a></li>
<li><a href="">创建&#x2F;删除标签</a></li>
<li><a href="">回退被修改的追踪文件到最近提交记录中的初始状态</a></li>
<li><a href="">返回两个分支的 diff</a></li>
<li><a href="">显示两个 revs 中同一个文件的改变 diff</a></li>
<li><a href="">显示两个提交记录中所有文件的改变 diff</a></li>
<li><a href="">显示两个提交记录中同一个文件的改变 diff,当文件被重命名后</a></li>
<li><a href="">显示状态</a></li>
<li><a href="">把分支中的内容存储到一个压缩文件中</a></li>
<li><a href="">使用自定义的打包格式将分支中的内容写入到一个压缩文件中</a></li>
<li><a href="">Blame,例如查找那个提交记录改变了某个文件的特定行</a></li>
<li><a href="">添加&#x2F;列出提交记录附带的笔记</a></li>
<li><a href="">列出所有可用的笔记</a></li>
<li><a href="">清理所有未追踪的文件</a></li>
<li><a href="">创建&#x2F;列出&#x2F;提交&#x2F;丢弃 stashes</a></li>
<li><a href="">运行垃圾回收</a></li>
<li><a href="">Blame,如查找谁最后修改了某文件的特定行</a></li>
<li><a href="">合并某一分支的修改</a></li>
<li><a href="">列出两个提交记录修改的所有文件</a></li>
</ul>
</li>
<li>供远程仓库使用的命令<ul>
<li><a href="">复制远程仓库到本地的新文件夹中</a></li>
<li><a href="">在一个仓库中迭代远程引用</a></li>
<li><a href="">不克隆列出远程仓库的所有 heads&#x2F;tags</a></li>
<li><a href="">fetch from remote repository</a></li>
<li><a href="">fetch from remote repository 且使用 <code>prune</code> 移除过期的远程 branches&#x2F;tags</a></li>
<li><a href="">使用 SSH 协议&#x2F;用户名密码验证克隆远程仓库</a></li>
<li><a href="">对一个 upstream 分支执行 Rebase</a></li>
<li><a href="">使用 InMemoryRepository 在内存中克隆一个仓库，并且在内存中完成操作</a></li>
</ul>
</li>
<li>底层 API<ul>
<li><a href="">从一个命名 ref (refs&#x2F;heads&#x2F;master) 中获取 SHA-1</a></li>
<li><a href="">从一个名称或 SHA-1 获取提交记录对象</a></li>
<li><a href="">获取提交信息</a></li>
<li><a href="">从提交记录对象，名称，SHA-1 获取 tree 对象</a></li>
<li><a href="">读取 file&#x2F;blob 的内容</a></li>
<li><a href="">从名称，SHA-1 获取 tag 对象</a></li>
<li><a href="">解析复杂的引用(如 HEAD^^)为 SHA-1</a></li>
<li><a href="">迭代一个分支的所有提交记录</a></li>
<li><a href="">迭代某个范围内的提交记录</a></li>
<li><a href="">从特定的提交记录中读取特定文件的内容</a></li>
<li><a href="">列出当前仓库的远程配置</a></li>
<li><a href="">从 Git 中打印出用户的信息</a></li>
<li><a href="">读取文件属性，如可执行状态，是文件还是文件夹，大小等</a></li>
<li><a href="">使用 BranchTrackingStatus 类获取当前分支相对于远程分支超前&#x2F;落后的提交记录</a></li>
<li><a href="">检查其他分支的某个提交是否被合并到了给出的分支</a></li>
<li><a href="">列出作为某个特定提交记录或标签的文件夹中的所有文件</a></li>
<li><a href="">循环迭代某个提交的文件</a></li>
<li><a href="">非循环迭代某个提交的文件</a></li>
<li><a href="">查找所有可以通过 tags,branches,remotes,HEADs…等可访问的提交记录</a></li>
</ul>
</li>
<li>缺失的代码片段<ul>
<li><a href="https://gerrit.googlesource.com/plugins/branch-network/+log/refs/heads/master/src/main/java/com/googlesource/gerrit/plugins/branchnetwork/data/JGitFacade.java">迭代仓库的所有提交</a></li>
<li><a href="https://github.com/eclipse/jgit/tree/master/org.eclipse.jgit.test/tst/org/eclipse/jgit/api">单元测试</a></li>
<li><a href="http://www.codeaffine.com/2014/04/16/how-to-manage-git-submodules-with-jgit/">子模块</a>(<a href="http://stackoverflow.com/questions/13426798/jgit-read-gitmodules">http://stackoverflow.com/questions/13426798/jgit-read-gitmodules</a>)</li>
<li><a href="http://stackoverflow.com/questions/12987364/how-to-diff-with-two-files-by-jgit-without-creating-repo">diffing</a></li>
<li><a href="http://stackoverflow.com/questions/4772142/jgit-unstaging-files-removing-files-from-the-index-and-ammending-a-commit">修改之前的提交</a></li>
<li><a href="http://stackoverflow.com/questions/4803462/jgit-java-git-library-unstaging-files">从索引中移除一个文件</a></li>
<li><a href="http://www.fancybeans.com/blog/2012/08/24/how-to-use-s3-as-a-private-git-repository/">Amazon S3 上的 git 仓库</a></li>
<li><a href="http://stackoverflow.com/questions/18300898/how-to-cherry-pick-a-commit-that-has-more-than-one-parent">cherrypick</a></li>
<li><a href="http://www.lordofthejars.com/2016/09/authenticating-with-jgit.html">更多授权</a></li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Groovy template</title>
    <url>/2019/08/16/58/</url>
    <content><![CDATA[<p>Groovy MarkupTemplateEngine 主要面向生成类 XML(XML,XHTML,HTML5…)的标记语言,但是也支持其他基于内容的文本.和传统的模版引擎相比,此引擎支持基于 DSL 的 builder 语法.</p>
<span id="more"></span>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">xmlDeclaration()</span><br><span class="line">cars &#123;</span><br><span class="line">  carsh.each &#123;</span><br><span class="line">    car(<span class="attr">make:</span>it.make,<span class="attr">model:</span>it.model)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><code>MarkupTemplateEngine</code>支持引用来自另一个文件的内容.</p>
<ul>
<li>另一份模版</li>
<li>原生内容</li>
<li>需要转义的内容</li>
</ul>
]]></content>
      <tags>
        <tag>译</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发和多线程指南</title>
    <url>/2019/08/26/52/</url>
    <content><![CDATA[<span id="more"></span>]]></content>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin/Native</title>
    <url>/2020/02/14/53/</url>
    <content><![CDATA[<span id="more"></span>]]></content>
  </entry>
  <entry>
    <title>Kotlin 参数不能为 var</title>
    <url>/2020/02/15/04/</url>
    <content><![CDATA[<p>从 Kotlin M5.1 之后不再支持函数参数可变(var).</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fun foo(var x: Int) &#123;</span><br><span class="line">    x = 5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要是这回导致歧义:可能认为传递的是引用参数(此特性不支持,需要在 runtime 修改).<br>另一个原因是主构造函数:主构造函数使用 <code>val</code> 或 <code>var</code>声明不同性质的属性,而普通函数却不需要这样的功能.<br>同时可变参数可不是一个好习惯,所以在函数支持可变参数或<code>for-loop</code>块都不再支持.</p>
<p><a href="https://blog.jetbrains.com/kotlin/2013/02/kotlin-m5-1/">origin</a></p>
]]></content>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>LiveData</title>
    <url>/2019/02/28/39/</url>
    <content><![CDATA[<p>LiveData</p>
<span id="more"></span>
<h3 id="LiveData-的优势"><a href="#LiveData-的优势" class="headerlink" title="LiveData 的优势"></a>LiveData 的优势</h3><ul>
<li>确保 UI 和数据状态匹配<blockquote>
<p>LiveData 遵循观察者模式。</p>
</blockquote>
</li>
<li>无内存泄漏</li>
<li>不会因为 Activity 被终止而崩溃<blockquote>
<p>如果观察者处于 inactive 状态，例如 activity 处于回退栈中，那么它不会接收到任何 LiveData 事件.</p>
</blockquote>
</li>
<li>不用手动处理生命周期事件</li>
<li>时刻更新数据状态<blockquote>
<p>如果一个观察者的变为 inactive，那么它会在重新 active 时获取最新的数据状态。比如，一个 activiy 如果处于后台，那么它将在重新返回前台时获取到最新的数据。</p>
</blockquote>
</li>
<li>应对 configuration change<blockquote>
<p>如果一个 activity 或 fragment 由于 configuration change(设备旋转) 导致重新创建，它会立即获取最新可用的数据.</p>
</blockquote>
</li>
<li>共享资源<blockquote>
<p>可以使用单例模式扩展 LiveData，封装系统服务在 app 内共享。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>在 ViewModel 对象中保存可以更新 UI 的 LiveData 对象，而不是在 activity 或 fragment 的原因是：</p>
<ul>
<li>避免 activty 或 framgent 过度膨胀。UI controller 仅负责展示数据而不是保存数据状态</li>
<li>从特性的 activity 或 fragment 中剥离 LiveData 实例，使得 LiveData 对象可以在 configuration change 中存活。</li>
</ul>
</blockquote>
<p><em>请在主线程中调用 setValue(T) 更新 LiveData 对象.如果是在工作线程，请调用 postValue(T).</em></p>
]]></content>
      <tags>
        <tag>Architecture Components</tag>
      </tags>
  </entry>
  <entry>
    <title>ObjectBox入门-10-关联</title>
    <url>/2019/02/25/13/</url>
    <content><![CDATA[<p>objectbox</p>
<span id="more"></span>
<p>Object 之间的关联具有方向性.关联是延迟初始化的：实际的引用对象只有在调用时才会从数据库中加载。一旦加载过，就会缓存起来.</p>
<h3 id="To-One-关联"><a href="#To-One-关联" class="headerlink" title="To-One 关联"></a>To-One 关联</h3><p><img src="http://qiniu.picbed.dang8080.cn/20190225232506.png" alt="To-One示意图"><br>使用 ToOne 会智能的对目标对象创建关联。同时获取目标对象缓存。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Customer.java</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span> <span class="keyword">public</span> <span class="type">long</span> id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Order.java</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span> <span class="keyword">public</span> <span class="type">long</span> id;</span><br><span class="line">    <span class="keyword">public</span> ToOne&lt;Customer&gt; customer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为了绑定 customer 对象，对 ToOne 实例调用 setTarget() 然后就存入 order 对象</span></span><br><span class="line"><span class="type">Customer</span> <span class="variable">customer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Customer</span>();</span><br><span class="line"><span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">order.customer.setTarget(customer);</span><br><span class="line"><span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> boxStore.boxFor(Order.class).put(order);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果 customer 在数据库中不存在，ToOne 将会存储。如果已经存在，那么 ToOne 只会创建关联,不会存储.<br>如果关联 Entity 使用的是自定义 IDs(@Id(assignable &#x3D; true)),则该 Entity 不会被存储.</p>
</blockquote>
<p>在 ToOne 实例中，可通过 Order 对象的 getTarget() 获取 customer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> boxStore.boxFor(Order.class).get(orderId);</span><br><span class="line"><span class="type">Customer</span> <span class="variable">customer</span> <span class="operator">=</span> order.customer.getTarget(customer);</span><br></pre></td></tr></table></figure>

<p>如果只是想要获取 ID 而不是整个目标对象，getTargetId() 值得拥有，此方法根本不会接触数据库，所以高效。</p>
<p>移除关联: 仅移除关联关系，而不会从数据库中移除目标对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">order.customer.setTarget(<span class="literal">null</span>);</span><br><span class="line">boxStore.boxFor(Order.class).put(order);</span><br></pre></td></tr></table></figure>

<p>查看 <code>objectbox-models/default.json</code> 会发现，ToOne 属性根本没有保存。仅仅只是目标对象的 ID 保存在一个名称和 ToOne 属性后拼接 Id 的虚拟属性.</p>
<h3 id="初始化魔术"><a href="#初始化魔术" class="headerlink" title="初始化魔术"></a>初始化魔术</h3><p>注意到 ToOne 属性 customer 从没初始化，然而调用时却不会抛出空指针异常。因为该初始化已经执行过了。<br>ObjectBox 插件会对 entity 类(仅支持纯 Java 项目和 Android 项目) 在调用前正确的初始化。所以在自定义构造方法时，你可以假设 ToOne&#x2F;ToMany&#x2F;List 属性已经初始化过了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    ToOne&lt;Order&gt; order;</span><br><span class="line">    ToMany&lt;Order&gt; orders;</span><br><span class="line">    <span class="keyword">transient</span> BoxStore __boxStore;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Example</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="built_in">this</span>.order = <span class="keyword">new</span> <span class="title class_">ToOne</span>&lt;&gt;(<span class="built_in">this</span>, Example_.order);</span><br><span class="line">        <span class="built_in">this</span>.orders = <span class="keyword">new</span> <span class="title class_">ToMany</span>&lt;&gt;(<span class="built_in">this</span>, Example_.orders);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Example</span><span class="params">(String value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="提升性能"><a href="#提升性能" class="headerlink" title="提升性能"></a>提升性能</h3><p>为了提高性能，请提供全参数构造方法。<br>对于 ToOne 属性，请添加一个名为 ToOne 属性名加 Id 的 id 参数。可以参考 objectbox-models&#x2F;default.json 里的命名.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span> <span class="keyword">public</span> <span class="type">long</span> id;</span><br><span class="line">    <span class="keyword">public</span> ToOne&lt;Customer&gt; customer;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Order</span><span class="params">()</span> &#123; <span class="comment">/* default constructor */</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Order</span><span class="params">(<span class="type">long</span> id, <span class="type">long</span> customerId <span class="comment">/* virtual ToOne id property */</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.customer.setTargetId(customerId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ToMany-关联"><a href="#ToMany-关联" class="headerlink" title="ToMany 关联"></a>ToMany 关联</h3><p>可以使用 List 或 ToMany 类型实现 ToMany 关联.相对 ToOne 来说，ToMany 可以实现追踪数据变化并将其写入操作中，而 List 必须自己实现.</p>
<h3 id="1-N"><a href="#1-N" class="headerlink" title="1:N"></a>1:N</h3><p><img src="http://qiniu.picbed.dang8080.cn/20190226000315.png" alt="1:N"></p>
<p>使用 @Backlink 注解 1:N 关联属性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Customer.java</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span> <span class="keyword">public</span> <span class="type">long</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &#x27;to&#x27; is optional if only one relation matches</span></span><br><span class="line">    <span class="meta">@Backlink(to = &quot;customer&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ToMany&lt;Order&gt; orders;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Order.java</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span> <span class="keyword">public</span> <span class="type">long</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ToOne&lt;Customer&gt; customer;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Customer</span> <span class="variable">customer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Customer</span>();</span><br><span class="line">customer.orders.add(<span class="keyword">new</span> <span class="title class_">Order</span>());</span><br><span class="line">customer.orders.add(<span class="keyword">new</span> <span class="title class_">Order</span>());</span><br><span class="line"><span class="type">long</span> <span class="variable">customerId</span> <span class="operator">=</span> boxStore.boxFor(Customer.class).put(customer); <span class="comment">// puts customer and orders</span></span><br><span class="line"></span><br><span class="line"><span class="type">Customer</span> <span class="variable">customer</span> <span class="operator">=</span> boxStore.boxFor(Customer.class).get(customerId);</span><br><span class="line"><span class="keyword">for</span> (Order order : customer.orders) &#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> customer.orders.remove(<span class="number">0</span>);</span><br><span class="line">boxStore.boxFor(Customer.class).put(customer);</span><br><span class="line"><span class="comment">// optional: also remove the order from its box</span></span><br><span class="line"><span class="comment">// boxStore.boxFor(Order.class).remove(order);</span></span><br></pre></td></tr></table></figure>

<h3 id="N-N"><a href="#N-N" class="headerlink" title="N:N"></a>N:N</h3><p><img src="http://qiniu.picbed.dang8080.cn/20190226000708.png" alt="N:N"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Teacher.java</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span> <span class="keyword">public</span> <span class="type">long</span> id;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Student.java</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span> <span class="keyword">public</span> <span class="type">long</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ToMany&lt;Teacher&gt; teachers;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Teacher</span> <span class="variable">teacher1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br><span class="line"><span class="type">Teacher</span> <span class="variable">teacher2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">Student</span> <span class="variable">student1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">student1.teachers.add(teacher1);</span><br><span class="line">student1.teachers.add(teacher2);</span><br><span class="line"></span><br><span class="line"><span class="type">Student</span> <span class="variable">student2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">student2.teachers.add(teacher2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// puts students and teachers</span></span><br><span class="line">boxStore.boxFor(Student.class).put(student1, student2);</span><br><span class="line"></span><br><span class="line"><span class="type">Student</span> <span class="variable">student1</span> <span class="operator">=</span> boxStore.boxFor(Student.class).get(student1.id);</span><br><span class="line"><span class="keyword">for</span> (Teacher teacher : student1.teachers) &#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">student1.teachers.remove(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// boxStore.boxFor(Student.class).put(student1);</span></span><br><span class="line"><span class="comment">// more efficient than using put:</span></span><br><span class="line">student1.teachers.applyChangesToDb();</span><br></pre></td></tr></table></figure>

<p>上面可以通过 student 知道 teacher 的信息，当然可以反过来</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Teacher.java</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span> <span class="keyword">public</span> <span class="type">long</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Backlink(to = &quot;teachers&quot;)</span> <span class="comment">// backed by the to-many relation in Student</span></span><br><span class="line">    <span class="keyword">public</span> ToMany&lt;Student&gt; students;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Student.java</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span> <span class="keyword">public</span> <span class="type">long</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ToMany&lt;Teacher&gt; teachers;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="更新关联"><a href="#更新关联" class="headerlink" title="更新关联"></a>更新关联</h3><p>ToOne 和 ToMany 可以追踪变化（只要存入拥有关联属性的 entity）并将其存入数据库中，<br>如果 ID !&#x3D; 0 或者 @Id(assignable &#x3D; true) 那么可以通过 Box 来更新关联</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// update a related entity using its box</span></span><br><span class="line"><span class="type">Order</span> <span class="variable">orderToUpdate</span> <span class="operator">=</span> customer.orders.get(<span class="number">0</span>);</span><br><span class="line">orderToUpdate.text = <span class="string">&quot;Revised description&quot;</span>;</span><br><span class="line"><span class="comment">// DOES NOT WORK</span></span><br><span class="line"><span class="comment">// boxStore.boxFor(Customer.class).put(customer);</span></span><br><span class="line"><span class="comment">// WORKS</span></span><br><span class="line">boxStore.boxFor(Order.class).put(orderToUpdate);</span><br></pre></td></tr></table></figure>

<h4 id="更新-ToOne"><a href="#更新-ToOne" class="headerlink" title="更新 ToOne"></a>更新 ToOne</h4><p>ToOne 类提供了如下方法更新关联:</p>
<ul>
<li><code>setTarget(entity)</code>: 创建关联；传入 null 清除关联</li>
<li><code>setTargetId(entityId)</code>: 对存在的目标 entity 创建关联；传入 0 清除关联.</li>
<li><code>setAndPutTarget(entity)</code>:</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">order.customer.setTarget(customer); <span class="comment">// or order.customer.setCustomerId(customer.getId());</span></span><br><span class="line">orderBox.put(order);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果 entity 在调用 setAndPutTarget() 之前还没存储,那么需要先绑定它的 box</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>(); <span class="comment">// new entity</span></span><br><span class="line">orderBox.attach(order); <span class="comment">// need to attach box first</span></span><br><span class="line">order.customer.setAndPutTarget(customer);</span><br></pre></td></tr></table></figure>

<p>如果目标 entity 使用自定义 IDs,必须在更新 ToOne 关联时存储它</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">customer.id = <span class="number">12</span>; <span class="comment">// self-assigned id</span></span><br><span class="line">customerBox.put(customer); <span class="comment">// need to put customer first</span></span><br><span class="line">order.customer.setTarget(customer); <span class="comment">// or order.customer.setCustomerId(customer.getId());</span></span><br><span class="line">orderBox.put(order);</span><br></pre></td></tr></table></figure>

<p>这是因为 ObjectBox 只保存 id 为 0 的关联对象.</p>
<h4 id="更新-ToMany"><a href="#更新-ToMany" class="headerlink" title="更新 ToMany"></a>更新 ToMany</h4><p>ToMany 实现了 java.lang.List 接口。如果向 ToMany 实例添加对象，这些对象就会被存储进数据库。移除也一样。（仅仅是关联被移除而已）.不要忘记把追踪 ToMany 改变的 own entity 对象存储.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">customer.orders.add(order1);</span><br><span class="line">customer.orders.remove(order2);</span><br><span class="line">customerBox.put(customer);</span><br></pre></td></tr></table></figure>

<p>如果使用自定义 IDs(@Id(assignable &#x3D; true)) 请在修改 ToMany 前绑定它的 box</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">customer.id = <span class="number">12</span>; <span class="comment">// self-assigned id</span></span><br><span class="line">customerBox.attach(customer); <span class="comment">// need to attach box first</span></span><br><span class="line">customer.orders.add(order);</span><br><span class="line">customerBox.put(customer);</span><br></pre></td></tr></table></figure>

<p>如果 entity 是自定义 IDs,那么需要先存入该 entity,然后再更新关联并存储 own entity.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">order.id = <span class="number">42</span>; <span class="comment">// self-assigned id</span></span><br><span class="line">orderBox.put(order); <span class="comment">// need to put order first</span></span><br><span class="line">customer.orders.add(order);</span><br><span class="line">customerBox.put(customer); <span class="comment">// put customer, add relation to order</span></span><br></pre></td></tr></table></figure>

<h3 id="树形关联"><a href="#树形关联" class="headerlink" title="树形关联"></a>树形关联</h3><p>可以使用 ToOne,ToMany 处理指向自身的树形关联</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span> <span class="type">long</span> id;</span><br><span class="line"></span><br><span class="line">    ToOne&lt;TreeNode&gt; parent;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BackLink</span></span><br><span class="line">    ToMany&lt;TreeNode&gt; children;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生成的 entity 可以获取它的 parent 和 children</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">TreeNode</span> <span class="variable">parent</span> <span class="operator">=</span> entity.parent.getTarget();</span><br><span class="line">List&lt;TreeNode&gt; children = entity.children;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>ObjectBox</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>ObjectBox入门-1-简介</title>
    <url>/2019/02/24/55/</url>
    <content><![CDATA[<p>objectbox</p>
<span id="more"></span>
<h2 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h2><p>ObjectBox 定位是: 针对移动端和 IoT 超快的 <code>(superfast edge database)</code> 面向对象的数据库 .为小型设备提供了边缘计算能力，使得数据可以快速高效地在本地存储、处理、安全管理.ObjectBox 小于 <code>1MB</code>,最适合移动 APP、小型 IoT 设备及路由。并且 ObjectBox 也是第一个在边缘设备上兼容 ACID 的高性能的 NoSQL 数据库.所有的产品都是基于工程师思维开发的，所以可以使用最少的代码去实现想要的功能。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>比同类竟品快 10 倍以上。<a href="https://github.com/objectbox/objectbox-performance">BenchMark</a></li>
<li>跨平台。支持 Linux、Windows、Mac&#x2F;iOS、Android、Raspberry Pi、ARM 等嵌入式设备和容器。</li>
<li>小于 1MB,特别针对小型设备设计和优化。</li>
<li>易使用。</li>
<li>支持 reactive.</li>
<li>无缝结合 greenDAO.(同一家公司出品)</li>
<li>更好地支持关系型数据. 提供了改变追踪(change tracking)，级联添加(cascading puts)，灵活的加载策略(eager,lazy)</li>
<li>无需掌握 SQL:ObjectBox 设计简单，使用方便，不需要掌握 SQL 即可上手.</li>
<li>支持 kotlin: 包括 data class.</li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="Android-Java"><a href="#Android-Java" class="headerlink" title="Android(Java)"></a>Android(Java)</h3><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// root 目录 build.gradle</span></span><br><span class="line">buildscript &#123;</span><br><span class="line">    ext.objectboxVersion = <span class="string">&#x27;2.3.3&#x27;</span></span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        <span class="comment">// Android Gradle plugin 最低版本为 3.0.0</span></span><br><span class="line">        classpath <span class="string">&#x27;com.android.tools.build:gradle:3.3.1&#x27;</span></span><br><span class="line">        classpath <span class="string">&quot;io.objectbox:objectbox-gradle-plugin:$objectboxVersion&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app 或其他 module build.gradle</span></span><br><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;com.android.application&#x27;</span></span><br><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;io.objectbox&#x27;</span> 放在最下面</span><br></pre></td></tr></table></figure>

<h4 id="Android-Kotlin"><a href="#Android-Kotlin" class="headerlink" title="Android(Kotlin)"></a>Android(Kotlin)</h4><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app 或其他 module build.gradle</span></span><br><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;com.android.application&#x27;</span></span><br><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;kotlin-android&#x27;</span></span><br><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;kotlin-kapt&#x27;</span> 如果使用 kotlin-android 插件，必须加 kotlin -kapt 插件</span><br><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;io.objectbox&#x27;</span> 放在最下面</span><br></pre></td></tr></table></figure>

<p>Sync gradle 即可自动添加 ObjectBox 依赖.</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>1、首先添加 ObjectBox 插件.<br>2、如果 ObjectBox 插件没有自动添加依赖库和注解处理器，请手动添加依赖。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Android(Java)</span></span><br><span class="line"><span class="comment">// /app/build.gradle</span></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile <span class="string">&quot;io.objectbox:objectbox-androoid:$objectboxVersion&quot;</span></span><br><span class="line">    annotationProcessor <span class="string">&quot;io.objectbox:objectbox-processor:$objectboxVersion&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Android(kotlin)</span></span><br><span class="line"><span class="comment">// /app/build.gradle</span></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile <span class="string">&quot;io.objectbox:objectbox-android:$objectboxVersion&quot;</span></span><br><span class="line">    kapt <span class="string">&quot;io.objectbox:objectbox-processor:$objectboxVersioni&quot;</span></span><br><span class="line">    <span class="comment">// 针对 kotlin 的扩展函数(可选)</span></span><br><span class="line">    compile <span class="string">&quot;io.objectbox:objectbox-kotlin:$objectboxVersion&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、改变 Model 文件的路径</p>
<p>ObjectBox Model 文件默认保存在 <code>module-name/objectbox-models/default.json</code>。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Android(Java)</span></span><br><span class="line"><span class="comment">// /app/build.gradle</span></span><br><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        javaCompileOptions &#123;</span><br><span class="line">            annotationProcessorOptions &#123;</span><br><span class="line">                arguments = [<span class="string">&quot;objectbox.modelPath&quot;</span>:<span class="string">&quot;$projectDir/schemas/objectbox.json&quot;</span>.toString()]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Android(Kotlin)</span></span><br><span class="line"><span class="comment">// /app/build.gradle</span></span><br><span class="line">kapt &#123;</span><br><span class="line">    arguments &#123;</span><br><span class="line">        arg(<span class="string">&quot;objectbox.modelPath&quot;</span>:<span class="string">&quot;$projectDir/schemas/objectbox.json&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、改变 <code>MyObjectBox</code> 的包名</p>
<p>MyObjectBox 类的包名默认和 entitiy 类的包名或其上一级报名一致。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Android(Java)</span></span><br><span class="line"><span class="comment">// /app/build.gradle</span></span><br><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        javaCompileOptions &#123;</span><br><span class="line">            annotationProcessorOptions &#123;</span><br><span class="line">                arguments = [<span class="string">&quot;objectbox.myObjectBoxPackage&quot;</span>:<span class="string">&quot;com.example.custom&quot;</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Android(Kotlin)</span></span><br><span class="line"><span class="comment">// /app/build.gradle</span></span><br><span class="line">kapt &#123;</span><br><span class="line">    arguments &#123;</span><br><span class="line">        arg(<span class="string">&quot;objectbox.myObjectBoxPackage&quot;</span>, <span class="string">&quot;com.example.custom&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5、开启 Debug 模式</p>
<p>在 &#x2F;app&#x2F;build.gradle 中添加必要的选项后，运行 <code>./gradlew --info</code> 即可查看 debug 输出</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Android(Java)</span></span><br><span class="line"><span class="comment">// /app/build.gradle</span></span><br><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        javaCompileOptions &#123;</span><br><span class="line">            annotationProcessorOptions &#123;</span><br><span class="line">                arguments = [<span class="string">&#x27;objectbox.debug&#x27;</span> : <span class="string">&#x27;true&#x27;</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Android(Kotlin)</span></span><br><span class="line"><span class="comment">// /app/build.gradle</span></span><br><span class="line">kapt &#123;</span><br><span class="line">    arguments &#123;</span><br><span class="line">        arg(<span class="string">&quot;objectbox.debug&quot;</span>, <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6、开启 DaoCompat 兼容模式</p>
<p>从 greenDAO 迁移过来，生成和 greenDAO 相似的 API,使 ObjectBox 看起来就像 SQLite 一样。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// /app[module]/build.gradle</span></span><br><span class="line">depdendencies &#123;</span><br><span class="line">    compile <span class="string">&quot;org.greenrobot:objectbox-daocompat:1.10&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后开启 DaoCompat 模式</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Android(Java)</span></span><br><span class="line"><span class="comment">// /app[module]/build.gradle</span></span><br><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        javaCOmpileOptions &#123;</span><br><span class="line">            annotationProcessorOptions &#123;</span><br><span class="line">                arguments = [<span class="string">&#x27;objectbox.daoCompat&#x27;</span>:<span class="string">&#x27;true&#x27;</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Android(Kotlin)</span></span><br><span class="line"><span class="comment">// /app[module]/build.gradle</span></span><br><span class="line">kapt &#123;</span><br><span class="line">    arguments &#123;</span><br><span class="line">        arg(<span class="string">&quot;objectbox.daoCompat&quot;</span>:<span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你计划从 greenDAO 迁移到 ObjectBox,那么你可能会保留原来的 greenDAO entity 类（复制这些类到另外的包中）然后按如下修改。</p>
<ul>
<li>首先改变注解。请注意：不是所有的 greenDAO 注解都支持无缝迁移到 ObjectBox,支持的如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// greenDAO</span></span><br><span class="line"><span class="keyword">import</span> org.greenrobot.greendao.annotation.Entity;</span><br><span class="line"><span class="keyword">import</span> org.greenrobot.greendao.annotation...</span><br><span class="line"></span><br><span class="line"><span class="comment">// ObjectBox</span></span><br><span class="line"><span class="keyword">import</span> io.objectbox.annotation.Entity;</span><br><span class="line"><span class="keyword">import</span> io.objectbox.annotation...</span><br></pre></td></tr></table></figure>

<ul>
<li>ObjectBox 当前不支持 unique indexes,naming indexes,或者在多个属性间 indexes.</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// greenDAO</span></span><br><span class="line"><span class="meta">@Entity(indexes = ...)</span></span><br><span class="line"><span class="meta">@Index(name = &quot;idx1&quot;, unique = true)</span> <span class="keyword">private</span> String name;</span><br><span class="line"><span class="meta">@Unqiue</span> <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ObjectBox</span></span><br><span class="line"><span class="meta">@Index</span> <span class="keyword">private</span> String name;</span><br></pre></td></tr></table></figure>

<ul>
<li>自定义类型。修改父类,当然也可同时继承，这样该自定义类型就可同时在 greenDAO 和 ObjectBox 间使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// greenDAO</span></span><br><span class="line"><span class="keyword">import</span> org.greenrobot.greendao.converter.PropertyConverter;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ObjectBox</span></span><br><span class="line"><span class="keyword">import</span> io.objectbox.converter.PropertyConverter;</span><br></pre></td></tr></table></figure>

<p>修改 @Convert 注解里的 columnType 改为 dbType</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// greenDAO</span></span><br><span class="line"><span class="meta">@Convert(converter = NoteTypeConverter.class, columnType = String.class)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ObjectBox</span></span><br><span class="line"><span class="meta">@Convert(converter = NoteTypeConverter.class, dbType = String.class)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>关系。ObjectBox 使用 <code>ToOne</code> 和 <code>ToMany</code>类型替代 greenDAO 的 <code>@ToOne</code> 和 <code>@ToMany</code> 注解。</li>
<li>使用 BoxStore.<br>修改完 entity 后，设置 BoxStore 创建 DaoSession.</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通常在 Application 类中</span></span><br><span class="line">boxStore = MyObjectBox.builder().androidContext(<span class="built_in">this</span>).build();</span><br><span class="line">daoCompatSession = <span class="keyword">new</span> <span class="title class_">DaoSession</span>(boxStore);</span><br><span class="line"><span class="comment">// 在迁移完成后，你可能想移除这些迁移操作。</span></span><br><span class="line"><span class="comment">// 那么通过 greenDAO session 获取 entities,把他们转为 ObjectBox entities,</span></span><br><span class="line"><span class="comment">// 然后使用 DaoCompat session 插入。</span></span><br><span class="line">List&lt;com.example.app.daos.greendao.Note&gt; notes = daoSession.getNoteDao().loadAll();</span><br><span class="line">List&lt;Note&gt; convertedNotes = convertToObjectBoxNotes(notes);</span><br><span class="line">daoCompatSession.getNoteDao().insertInTx(convertedNotes);</span><br></pre></td></tr></table></figure>

<p>默认没有设置 ID (即 id &#x3D;&#x3D; 0),ObjectBox 会为插入的数据生成一个新的 ID.如果想保留原来的 ID,请修改 <code>@Id(assignable = true)</code></p>
<ul>
<li>使用 DaoCompat DaoSession<br>在使用新 compat session 替换原来的 API 后，可以通过在 <code>Application</code> 类中的一个方法返回 <code>DaoSession</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> DaoSession <span class="title function_">getDaoSession</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// greenDAO</span></span><br><span class="line">    <span class="comment">// return daoSession;</span></span><br><span class="line">    <span class="comment">// ObjectBox</span></span><br><span class="line">    <span class="keyword">return</span> daoCompatSession;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>表面上 compat DaoSession 是 greenDAO DaoSession 的替代品，其实它内部是使用 BoxStore 代替了 greenDAO 数据库.<br>如果还使用了 greenDAO 的额外特性，比如 queries,那么还需如下修改:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// greenDAO</span></span><br><span class="line"><span class="keyword">import</span> org.greenrobot.greendao.query.Query;</span><br><span class="line"><span class="keyword">import</span> org.greenrobot.greendao...</span><br><span class="line"><span class="comment">// ObjectBox</span></span><br><span class="line"><span class="keyword">import</span> org.greenrobot.daocompat.query.Query;</span><br><span class="line"><span class="keyword">import</span> org.greenrobot.daocompat...</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Queries<br>DaoCompat 支持以下的 Query 功能:<br>– <code>remove()</code> 替代 <code>DeleteQuery</code><br>– <code>count()</code> 替代 <code>CountQuery</code><br>– 不支持 <code>CursorQuery</code></p>
</li>
<li><p>DaoCompat 和 greenDAO 的不同<br>– 不支持 <code>NotNull</code><br>– 不支持 <code>Joins</code> 和 <code>原生 SQL 查询</code>.<br>– 不支持异步 sessions: <code>startAsyncSession()</code><br>– 不支持加密<br>– 仅支持简单的 <code>AbstractDaoTest</code> 和 <code>AbstractDaoBasicTest</code></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>ObjectBox</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>ObjectBox入门-11-Data Browser</title>
    <url>/2019/02/26/52/</url>
    <content><![CDATA[<p>objectbox</p>
<span id="more"></span>
<p>Data Browser 具有如下功能:</p>
<ul>
<li>查看数据库的 entities 和 schema</li>
<li>下载 JSON 格式的 entities</li>
</ul>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    debugImplementation <span class="string">&quot;io.objectbox:objectbox-android-objectbrowser:$objectboxVersion&quot;</span></span><br><span class="line">    releaseImplementation <span class="string">&quot;io.objectbox:objectbox-android:$objectboxVersion&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// apply the plugin after the dependencies block</span></span><br><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;io.objectbox&#x27;</span></span><br></pre></td></tr></table></figure>

<p>不这样设置可能出现 <code>Duplicate files copied in APK lib/armeabi-v7a/libobjectbox.so</code> 这样的错误.因为 ObjectBox 插件又添加了一次 objectbox-android 库</p>
<p>在 AndroidManifest.xml 添加如下权限(2.2.0 后需要)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- Required to provide the web interface --&gt;</span><br><span class="line">&lt;uses-permission android:name=<span class="string">&quot;android.permission.INTERNET&quot;</span> /&gt;</span><br><span class="line">&lt;!-- Required to run keep-alive service when targeting API <span class="number">28</span> or higher --&gt;</span><br><span class="line">&lt;uses-permission android:name=<span class="string">&quot;android.permission.FOREGROUND_SERVICE&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>

<p>建议在 Application 类中添加</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">boxStore = MyObjectBox.builder().androidContext(<span class="built_in">this</span>).build();</span><br><span class="line"><span class="keyword">if</span> (BuildConfig.DEBUG) &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">started</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AndroidObjectBrowser</span>(boxStore).start(<span class="built_in">this</span>);</span><br><span class="line">    Log.i(<span class="string">&quot;ObjectBrowser&quot;</span>, <span class="string">&quot;Started: &quot;</span> + started);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>ObjectBox</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>ObjectBox入门-12-事务</title>
    <url>/2019/02/26/55/</url>
    <content><![CDATA[<p>objectbox</p>
<span id="more"></span>
<p>ObjectBox 是一个满足 ACID 特性的交易型数据库.一个事务可以包含一组操作，要么执行成功，要么全部失败。<br>几乎所有的 ObjectBox 的操作都包含了事务。比如 <code>put(),read()</code>。普通情况下，不用关心这些底层的事务。但某些复杂的情况下，手动处理事务操作可以使你的 app 更加高效一致。</p>
<h3 id="手动事务"><a href="#手动事务" class="headerlink" title="手动事务"></a>手动事务</h3><p>ObjectBox 提供了如下方法实现手动事务：</p>
<ul>
<li>runInTx: 在事务中运行指定的 runnable</li>
<li>runInReadTx: 在一个只读的事务中运行指定的 runnable.不同于写入事务，多个只读事务可以同时运行。</li>
<li>runInTxAsync: 在另一个线程中运行指定的 runnable.一旦事务执行完毕，callback(可为 null) 将被调用.</li>
<li>callInTx: 类似 runInTx(Runnable),但是有返回值或抛出异常.</li>
</ul>
<p>对批量存入操作进行手动事务的优势是你可以实现任意数量的操作，使用多个 box 对象。同时，在事务执行过程中，可以对数据有一个直观的认知。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写入事务</span></span><br><span class="line">boxStore.runInTx(() -&gt; &#123;</span><br><span class="line">  <span class="keyword">for</span> (User user: allUsers) &#123;</span><br><span class="line">    <span class="keyword">if</span> (modify(user)) box.put(user);</span><br><span class="line">    <span class="keyword">else</span> box.remove(user);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="事务代价"><a href="#事务代价" class="headerlink" title="事务代价"></a>事务代价</h3><p>理解事务可以很好的帮助掌握数据库性能。请注意: 写入事务代价大.<br>提交事务包含了将数据同步到物理存储中的操作，这对数据库是一个相对昂贵的操作。只有文件系统确认所有的数据都存储，事务操作才会被认为是成功的。事务同步该文件可能需要几毫秒。请记住：尽量把多个操作(put 等)放入同一个事务中.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">for</span>(User user: allUsers) &#123;</span><br><span class="line">   modify(user); <span class="comment">// modifies properties of given user</span></span><br><span class="line">   box.put(user);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">for</span>(User user: allUsers) &#123;</span><br><span class="line">   modify(user); <span class="comment">// modifies properties of given user</span></span><br><span class="line">&#125;</span><br><span class="line">box.put(allUsers);</span><br></pre></td></tr></table></figure>

<h3 id="读取事务"><a href="#读取事务" class="headerlink" title="读取事务"></a>读取事务</h3><p>ObjectBox 的读取事务很快。相对于写入事务，没有 commit 操作，所以没有昂贵的同步文件系统。请注意：在一个读取事务中 put 操作是非法的，会抛出一个异常。get,count,queries 等操作没有手动声明事务(读写),默认会运行在一个读取事务.<br>虽然读取事务比写入事务代价小，但是还是最好把它放入读取事务中。</p>
<h3 id="多版本的并发"><a href="#多版本的并发" class="headerlink" title="多版本的并发"></a>多版本的并发</h3><p>ObjectBox 提供了语义化的多版本并发控制(Multiversion concurrency control MVCC).多个并发读取(读取事务)可以立即执行，无需阻塞或等待。这是通过存储多个版本的（提交）数据来实现的。即便一个写入事务正在运行，读取事务也可以立即获取到最新的同步状态。写入事务按顺序执行以便状态一致。所以保证写入事务短小可以避免阻塞其他写入事务。因此在一个写入事务中执行网络操作或复杂计算不推荐。尽量在写入事务前完成这些操作。</p>
<p>注意不需要自己手动维持写入事务序列。如果多线程想同时执行写入事务(put,runInTx),同一时刻只有一个线程可以执行，其他必须等待。类似 Java 中的 lock 或 synchronized。</p>
<h4 id="深入写入事务"><a href="#深入写入事务" class="headerlink" title="深入写入事务"></a>深入写入事务</h4><p>尽量避免在写入事务中使用锁(<code>synchronized</code> 或 <code>java.util.concurrent.locks</code>).因为写入事务运行费时，所以 ObjectBox 内部会获取一个写入锁。当设计多个锁时，请提高警惕。<br>始终以相同的顺序获取锁可以避免死锁。如果在一个事务获取了 X 锁，请保证你的代码在持有 X 锁时没有在另外一个写入事务中执行.</p>
]]></content>
      <tags>
        <tag>ObjectBox</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>ObjectBox入门-2-基本操作</title>
    <url>/2019/02/24/15/</url>
    <content><![CDATA[<p>objectbox</p>
<span id="more"></span>
<h3 id="Entity"><a href="#Entity" class="headerlink" title="Entity"></a>Entity</h3><p>在一个类中至少需要 <code>@Entity</code> 和 <code>@Id</code> 两个注解才能定义一个 ObjectBox model.例如:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// User.java</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span> <span class="keyword">public</span> <span class="type">long</span> id;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后 make 就可生成 model.</p>
<p>| @Id 的类型必须为 long.<br>| 如果 entity 发生了很大的变动（如移动类或修改注解）,必须 rebuild 项目以便 ObjectBox 生成的代码得到更新.</p>
<h3 id="核心类"><a href="#核心类" class="headerlink" title="核心类"></a>核心类</h3><ul>
<li>MyObjectBox: 基于 entity 类生成。提供 <code>builder</code> 配置 BoxStore.</li>
<li>BoxStore: ObjectBox 的入口。操作数据库，管理 Boxes 的工具.</li>
<li>Box: 对 entity 保存和查询。每一个 entity 都有一个对应的 Box（由 BoxStore 提供).</li>
</ul>
<h3 id="核心初始化"><a href="#核心初始化" class="headerlink" title="核心初始化"></a>核心初始化</h3><p>实例化 BoxStore 的最好时机是在 app 启动时。推荐在 Application 类的 onCreate 方法中进行.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> BoxStore boxStore;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate();</span><br><span class="line">        boxStore = MyObjectBox.builder().androidContext(<span class="built_in">this</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BoxStore <span class="title function_">getBoxStore</span><span class="params">()</span> &#123; <span class="keyword">return</span> boxStore; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 然后在 app 生命周期内就可以使用了</span></span><br><span class="line">notesBox = ((App) getApplicationi()).getBoxStore().boxFor(User.class);</span><br></pre></td></tr></table></figure>

<h3 id="Box-基本操作"><a href="#Box-基本操作" class="headerlink" title="Box 基本操作"></a>Box 基本操作</h3><ul>
<li>put: 存入一个对象，可能会覆盖具有相同 ID 的对象。即使用 <code>put</code> 插入或更新对象。返回 ID。</li>
<li>get,getAll: 提供一个对象的 ID，可快速的通过 <code>get</code>获取它。<code>getAll</code> 获取指定的所有的对象。</li>
<li>remove,removeAll: 从 box 中删除一个对象。<code>removeAll</code> 删除指定的所有对象.</li>
<li>count: 返回该 box 存储的对象数量.</li>
<li>query: 返回一个 <code>query builder</code>.</li>
</ul>
<h3 id="Object-IDs"><a href="#Object-IDs" class="headerlink" title="Object IDs"></a>Object IDs</h3><ul>
<li><p>Entity 必须具有一个类型为 <code>long</code>,由 @Id 注解属性。当然可以使用可空的 <code>java.lang.Long</code>类型，但不推荐。<br>如果需要使用另外一种类型的 ID(服务器返回的 String 类型的 UID),把它作为普通属性即可，然后可以通过此 ID 查询.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span> <span class="keyword">class</span> <span class="title class_">StringIdEntity</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span> priavte <span class="type">long</span> id;</span><br><span class="line">    <span class="keyword">private</span> String uid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">StringIdEntity</span> <span class="variable">entity</span> <span class="operator">=</span> box.query().equal(StringIdEntity_.uid,uid).findUnique();</span><br></pre></td></tr></table></figure>
</li>
<li><p>指定 ID<br>ObjectBox 默认会为新对象指定 IDs.ID 自增.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line"><span class="comment">// user.id == 0</span></span><br><span class="line">box.put(user);</span><br><span class="line"><span class="comment">// user.id != 0</span></span><br><span class="line"><span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> user.id</span><br></pre></td></tr></table></figure>
<p>如果插入的对象的 ID 比 box 里的 ID 最大值还大，ObjectBox 将抛出错误.</p>
</li>
<li><p>保留 Object IDs<br>Object IDs 不能：<br>– 0,null(使用 java.lang.Long)。<br>– 0xFFFFFFFFFFFFFFFF（java 中的 -1）:内部保留</p>
</li>
</ul>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><ul>
<li><code>put</code> 运行在隐式事务中</li>
<li>优先使用 <code>put</code> 批量操作列表 （<code>put(entities)</code>）</li>
<li>如果在循环中操作大量数据，考虑明确使用事务，如<code>runInTx()</code></li>
</ul>
]]></content>
      <tags>
        <tag>ObjectBox</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>ObjectBox入门-4-本地单元测试</title>
    <url>/2019/02/24/35/</url>
    <content><![CDATA[<p>objectbox</p>
<span id="more"></span>
<h2 id="安卓本地单元测试"><a href="#安卓本地单元测试" class="headerlink" title="安卓本地单元测试"></a>安卓本地单元测试</h2><h3 id="设置测试环境"><a href="#设置测试环境" class="headerlink" title="设置测试环境"></a>设置测试环境</h3><p>| 此配置仅针对 ObjectBox 1.4 及之前版本.新版本已经自动添加了 native ObjectBox 依赖库。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// /app/build.gradle</span></span><br><span class="line">depdendencies &#123;</span><br><span class="line">    <span class="comment">// 必备 JUnit 4</span></span><br><span class="line">    testImplementation <span class="string">&#x27;junit:unit:4.12&#x27;</span></span><br><span class="line">    <span class="comment">// 手动添加平台独立的 native Objectbox 依赖库.(可选)</span></span><br><span class="line">    testImplementation <span class="string">&quot;io.objectbox:objectbox-linux:$objectboxVersion&quot;</span></span><br><span class="line">    testImplementation <span class="string">&quot;io.objectbox:objectbox-macos:$objectboxVersion&quot;</span></span><br><span class="line">    testImplementation <span class="string">&quot;io.objectbox:objectbox-windows:$objectboxVersion&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>| 本地单元测试仅支持 64 位系统.<br>| windows 可能需要安装 <code>Microsoft Visual C++ 2015 Redistributable(x64)</code></p>
<h3 id="创建本地单元测试类"><a href="#创建本地单元测试类" class="headerlink" title="创建本地单元测试类"></a>创建本地单元测试类</h3><ul>
<li>可以使用 BoxStore builder 的<code>directory(File)</code> 指定数据库保存在本地设备上。</li>
<li>为保证数据不交叉污染，可以使用 <code>BoxStore.deleteAllFiles(File)</code> 删除已经存在的数据库</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NoteTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">File</span> <span class="variable">TEST_DIR</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;objectbox-example/test-db&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> BoxStore store;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 删除之前的数据库</span></span><br><span class="line">        BoxStore.deleteAllFiles(TEST_DIR);</span><br><span class="line">        store = MyObjectBox.builder()</span><br><span class="line">                <span class="comment">// 指定数据库存放路径</span></span><br><span class="line">                .directory(TEST_DIR)</span><br><span class="line">                <span class="comment">// 添加 debug 标记打印日志</span></span><br><span class="line">                .debugFlags(DebugFlags.LOG_QUERIES | DebugFlags.LOG_QUERY_PARAMETERS)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (store != <span class="literal">null</span>) &#123;</span><br><span class="line">            store.close();</span><br><span class="line">            store = <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">        BoxStore.deleteAllFiles(TEST_DIR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exampleTest</span><span class="params">()</span> &#123;</span><br><span class="line">        Box&lt;Note&gt; noteBox = store.boxFor(Note.class);</span><br><span class="line">        assertEquals(...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关系测试"><a href="#关系测试" class="headerlink" title="关系测试"></a>关系测试</h3><ul>
<li>ObjectBox 1.4.4 及之后</li>
<li>为了测试具有 ToOne,ToMany 属性的 entity,必须在本地 JVM 初始化 entity 并且添加一个 transient 的 BoxStore 属性.</li>
</ul>
]]></content>
      <tags>
        <tag>ObjectBox</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>ObjectBox入门-3-注解</title>
    <url>/2019/02/24/55/</url>
    <content><![CDATA[<p>objectbox</p>
<span id="more"></span>
<h2 id="Entity-注解"><a href="#Entity-注解" class="headerlink" title="Entity 注解"></a>Entity 注解</h2><h3 id="entity-数据可访问"><a href="#entity-数据可访问" class="headerlink" title="entity 数据可访问"></a>entity 数据可访问</h3><ul>
<li>ObjectBox 需要访问 entity 的属性(生成 Cursor 类).<ul>
<li>属性包内可见。kotlin 中使用 <code>JvmField</code></li>
<li>提供标准 <code>getters</code></li>
</ul>
</li>
<li>为了提升性能，请提供具有全部属性的构造方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span> <span class="keyword">private</span> <span class="type">long</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Transient</span> <span class="keyword">private</span> <span class="type">int</span> tempUsageCount;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span>&#123;<span class="comment">/* 默认构造方法 */</span>&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(id,name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// getters and setters for properties...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="entity-属性的注解"><a href="#entity-属性的注解" class="headerlink" title="entity 属性的注解"></a>entity 属性的注解</h3><ul>
<li><code>@NameInDb</code> 可以在数据库中为属性命名。<ul>
<li>应该使用 <code>@Uid</code> 注解来代替重命名属性和 entity</li>
<li><code>@NameInDb</code> 仅支持内联常量来指定列名。</li>
</ul>
</li>
<li><code>@Transient</code> 保证属性不被持久化，transient，static 修饰符也一样.</li>
</ul>
<h3 id="属性索引-Index"><a href="#属性索引-Index" class="headerlink" title="属性索引 @Index"></a>属性索引 @Index</h3><ul>
<li><code>@Index</code> 当前不支持 <code>byte[] float double</code></li>
<li>Index typs(String).<ul>
<li>ObjectBox 2.0 引入了 index types.之前对每一个索引，使用属性的值来完成查询。<br>现在 ObjectBox 可以使用 hash 来生成 index.<br>由于 String 属性明显比标量值更占空间，ObjectBox 对 strings 使用默认的 index type 完成 hash.<br>可以针对 String 类型的属性明确指定 index type 为基于值构建索引。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Index( type = IndexType.VALUE)</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br></pre></td></tr></table></figure></li>
<li>请注意：对于 String 类型的属性，基于值的索引可能比默认基于 hash 的索引更占空间,这种结论取决于该值的长度。</li>
<li>ObjectBox 支持以下索引属性:<ul>
<li>未指定或默认: 根据属性的类型决定(HASH for String,VALUE for others)</li>
<li>VALUE: 使用属性值生成索引。例如 String,可能更占空间</li>
<li>HASH: 使用属性值的 32 位 hash 生成索引。偶尔可能发生 hash 碰撞，但实际概率很小。通常比 HASH64 更佳，因为占空间小</li>
<li>HASH64: 使用属性值的长 hash 生成索引。比 HASH 占空间大，所以一般情况下不是首选.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Unique-约束"><a href="#Unique-约束" class="headerlink" title="Unique 约束"></a>Unique 约束</h3><p>如果 unique 约束的属性值冲突，<code>put()</code> 操作将被终止且抛出 <code>UniqueViolationException</code> 的异常.<br>Unique 基于 Index,所以可以同时给属性添加 @Index 注解。</p>
<h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3>]]></content>
      <tags>
        <tag>ObjectBox</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>ObjectBox入门-6-Java桌面应用.md</title>
    <url>/2019/02/24/24/</url>
    <content><![CDATA[<p>objectbox</p>
<span id="more"></span>
<h2 id="Java-桌面应用"><a href="#Java-桌面应用" class="headerlink" title="Java 桌面应用"></a>Java 桌面应用</h2><h3 id="嵌入式数据库"><a href="#嵌入式数据库" class="headerlink" title="嵌入式数据库"></a>嵌入式数据库</h3><p>ObjectBox 不仅仅适用于 Android 项目，同时也适用于运行在 Windows Linux macOS 上的纯 Java(JVM) 桌面应用.</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>请使用 Gradle 作为构建工具，因为 ObjectBox 使用了 Gradle 插件.</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    ext.objectboxVersion = <span class="string">&#x27;2.3.3&#x27;</span></span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">        maven&#123; url <span class="string">&quot;https://plugins.gradle.org/m2/&quot;</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="string">&quot;net.ltgt.gradle:gradle-apt-plugin:0.20&quot;</span></span><br><span class="line">        classpath <span class="string">&quot;io.objectbox:objectbox-gradle-plugin:$objectboxVersion&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">repositories &#123;</span><br><span class="line">    jcenter()</span><br><span class="line">&#125;</span><br><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;java&#x27;</span></span><br><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;net.ltgt.apt-idea&#x27;</span> <span class="comment">// 注解处理器插件</span></span><br><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;io.objectbox&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="Native-库"><a href="#Native-库" class="headerlink" title="Native 库"></a>Native 库</h3><p>ObjectBox 是由 C&#x2F;C++写成的可以运行大多数 native code 的对象数据库。</p>
<h3 id="改变-Model-文件位置"><a href="#改变-Model-文件位置" class="headerlink" title="改变 Model 文件位置"></a>改变 Model 文件位置</h3><p>默认 model 文件存储在 <code>module-name/objectbox-models/default.json</code>.可以通过修改 objectbox.modelPath 来改变</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在项目 build.gradle 文件， apply plugin: &#x27;java&#x27; 之后添加</span></span><br><span class="line">tasks.withType(JavaCompile) &#123;</span><br><span class="line">    options.compilerArgs += [<span class="string">&quot;-Aobjectbox.modelPath=$projectDir/schemas/object.json]</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="改变-MyObjectBox-包名"><a href="#改变-MyObjectBox-包名" class="headerlink" title="改变 MyObjectBox 包名"></a>改变 MyObjectBox 包名</h3><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">tasks.withType(JavaCompile) &#123;</span><br><span class="line">    options.compilerArgs += [ <span class="string">&quot;-Aobjectbox.modelPath=$projectDir/schemas/objectbox.json&quot;</span> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="开启-debug-模式"><a href="#开启-debug-模式" class="headerlink" title="开启 debug 模式"></a>开启 debug 模式</h3><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// enable debug output for plugin</span></span><br><span class="line">objectbox &#123;</span><br><span class="line">    debug <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// enable debug output for annotation processor</span></span><br><span class="line">tasks.withType(JavaCompile) &#123;</span><br><span class="line">    options.compilerArgs += [ <span class="string">&quot;-Aobjectbox.debug=true&quot;</span> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="可以使用-BoxStore-builder-的-name-String-来改变数据库存储的位置。"><a href="#可以使用-BoxStore-builder-的-name-String-来改变数据库存储的位置。" class="headerlink" title="可以使用 BoxStore builder 的 name(String) 来改变数据库存储的位置。"></a>可以使用 BoxStore builder 的 name(String) 来改变数据库存储的位置。</h4><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>添加 junit 4 库</p>
]]></content>
      <tags>
        <tag>ObjectBox</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>ObjectBox入门-5-LiveData</title>
    <url>/2019/02/24/57/</url>
    <content><![CDATA[<p>objectbox</p>
<span id="more"></span>
<h2 id="LiveData-Arch-Comp"><a href="#LiveData-Arch-Comp" class="headerlink" title="LiveData (Arch.Comp.)"></a>LiveData (Arch.Comp.)</h2><p>从 1.2.0 开始支持 <code>Android Architecture Components</code><br>ObjectBox 提供 <code>ObjectBoxLiveData</code> 可以在 ViewModel 中使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NoteViewModel</span> <span class="keyword">extends</span> <span class="title class_">ViewModel</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ObjectBoxLiveData&lt;Note&gt; noteLiveData;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ObjectBoxLiveData&lt;Note&gt; <span class="title function_">getNoteLiveData</span><span class="params">(Box&lt;Note&gt; notesBox)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (noteLiveData == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 查询所有的 notes, text 按 a-z 的顺序排列</span></span><br><span class="line">            noteLiveData = <span class="keyword">new</span> <span class="title class_">ObjectBoxLiveData</span>(notesBox.query().order(Note_.text).build());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> noteLiveData;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>上一种方法需要传入 Box.可以使用 <code>AndroidViewModel</code> 代替，它可以访问 Application context,然后会在 ViewModel 中调用 <code>((App)getApplication()).getBoxStore().boxFor()</code>.第一种的优势在于没有引用 Android 类，所以可以进行单元测试。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">NoteViewModel</span> <span class="variable">model</span> <span class="operator">=</span> ViewModelProviders.of(<span class="built_in">this</span>).get(NoteViewModel.class);</span><br><span class="line">model.getNoteLiveData(notesBox).observe(<span class="built_in">this</span>,<span class="keyword">new</span> <span class="title class_">Observer</span>&lt;List&lt;Note&gt;&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onChanged</span><span class="params">(<span class="meta">@Nullable</span> List&lt;Node&gt; notes)</span> &#123;</span><br><span class="line">        notesAdapter.setNotes(notes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="Paging-Arch-Comp"><a href="#Paging-Arch-Comp" class="headerlink" title="Paging (Arch.Comp.)"></a>Paging (Arch.Comp.)</h2><p>从 2.0.0 开始支持.ObjectBox 提供了 <code>ObjectBoxDataSource</code> 类.它继承了 paging 库的 <code>PositionalDataSource</code><br>在 ViewModel 中，类似创建 LiveData,先创建 ObjectBox query.然后构造并使用 ObjectBoxDataSource 工厂代替 LiveData.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotePageViewModel</span> <span class="keyword">extends</span> <span class="title class_">ViewModel</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> LiveData&lt;PagedList&lt;Note&gt;&gt; noteLiveDataPaged;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> LiveData&lt;PagedList&lt;Note&gt;&gt; <span class="title function_">getNoteLiveDataPaged</span><span class="params">(Box&lt;Note&gt; notesBox)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(noteLiveDataPaged == <span class="literal">null</span>) &#123;</span><br><span class="line">            Query&lt;Note&gt; query = notesBox.query().order(Note_.text).build();</span><br><span class="line">            noteLiveDataPaged = <span class="keyword">new</span> <span class="title class_">LivePagedListBuilder</span>(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ObjectBoxDataSource</span>.Factory(query),</span><br><span class="line">                <span class="number">20</span> <span class="comment">// 页数</span></span><br><span class="line">            ).build();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> noteLiveDataPaged;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>ObjectBox</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>ObjectBox入门-7-kotlin支持</title>
    <url>/2019/02/24/41/</url>
    <content><![CDATA[<p>objectbox</p>
<span id="more"></span>
<h2 id="Kotlin-支持"><a href="#Kotlin-支持" class="headerlink" title="Kotlin 支持"></a>Kotlin 支持</h2><h3 id="kotlin-Entity"><a href="#kotlin-Entity" class="headerlink" title="kotlin Entity"></a>kotlin Entity</h3><ul>
<li>在 kotlin 中，ID 属性应该这样定义 <code>@Id var id: Long = 0</code>.ID 必须是 var.</li>
</ul>
<h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><ul>
<li>ObjectBox 优先调用全参的构造方法。如果自定义属性或 transient 属性 或关联属性是构造方法的一部分参数，ObjectBox 将不会调用此构造方法.所以应该提供为这些参数提供默认值以确保无参构造方法存在。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Note</span>(</span><br><span class="line">    <span class="meta">@Id</span> <span class="keyword">var</span> id: <span class="built_in">Long</span> = <span class="number">0</span>,</span><br><span class="line">    <span class="keyword">val</span> text: String = <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="meta">@Convert( converter = StringsConverter::class, dbType = String::class)</span></span><br><span class="line">    <span class="keyword">val</span> strings: List&lt;String&gt; = listOf()</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="kotlin-Entity-中定义关联属性"><a href="#kotlin-Entity-中定义关联属性" class="headerlink" title="kotlin Entity 中定义关联属性"></a>kotlin Entity 中定义关联属性</h3><p>在 kotlin 中定义关联属性可能比较麻烦。但请注意：关联属性必须为 <code>var</code>. 否则 <code>initialization magic</code> 将不起作用.<br>通常可以使用 <code>lateinit</code> 修饰关联属性</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span> <span class="keyword">var</span> id: <span class="built_in">Long</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> customer: ToOne&lt;Customer&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span> <span class="keyword">var</span> id: <span class="built_in">Long</span> = <span class="number">0</span></span><br><span class="line">    <span class="meta">@Backlink( to = <span class="string">&quot;customer&quot;</span>)</span></span><br><span class="line">    latelinit <span class="keyword">var</span> orders: List&lt;Order&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="kotlin-扩展函数"><a href="#kotlin-扩展函数" class="headerlink" title="kotlin 扩展函数"></a>kotlin 扩展函数</h3><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">&quot;io.objectbox:objectbox-kotlin:$objectboxVersion&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>kotlin</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> box: Box&lt;DataClassEntity&gt; = store.boxFor()</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> query = box.query &#123;</span><br><span class="line">    equal(property,value)</span><br><span class="line">    order(property)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> query = box.query().inValues(property,array).build()</span><br><span class="line"></span><br><span class="line">toMany.applyChangesToDb(resetFirst = <span class="literal">true</span>) &#123; <span class="comment">// 默认 false</span></span><br><span class="line">    add(entity)</span><br><span class="line">    removeById(id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>ObjectBox</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>ObjectBox入门-8-查询</title>
    <url>/2019/02/24/51/</url>
    <content><![CDATA[<p>objectbox</p>
<span id="more"></span>
<h2 id="Queries"><a href="#Queries" class="headerlink" title="Queries"></a>Queries</h2><ul>
<li>使用 QueryBuilder 定义查询标准，Query 类运行查询并返回匹配结果</li>
</ul>
<h3 id="QueryBuilder"><a href="#QueryBuilder" class="headerlink" title="QueryBuilder"></a>QueryBuilder</h3><ul>
<li>QueryBuilder 使用编译生成的元信息类来指定要匹配的属性值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;user&gt; joes = userBox.query().equal(User_.firstName,<span class="string">&quot;Joe&quot;</span>).build().find();</span><br><span class="line"></span><br><span class="line">QueryBuilder&lt;User&gt; builder = userBox.query();</span><br><span class="line">builder.equal(User_.firstName,<span class="string">&quot;Joe&quot;</span>)</span><br><span class="line">        .greater(User_.yearOfBirth,<span class="number">1970</span>)</span><br><span class="line">        .startsWith(User_.lastName,<span class="string">&quot;O&quot;</span>);</span><br><span class="line">List&lt;User&gt; youngJoes = builder.build().find();</span><br></pre></td></tr></table></figure>

<h3 id="边界条件"><a href="#边界条件" class="headerlink" title="边界条件"></a>边界条件</h3><ul>
<li><code>equal(),notEqual(),greater(),less()</code></li>
<li><code>isNull(),notNull()</code></li>
<li><code>between()</code></li>
<li><code>in(),notIn()</code></li>
<li><code>startsWith(),endsWith(),contains()</code></li>
<li><code>and(),or()</code></li>
</ul>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">userBox.query().equal(User_.firstName,<span class="string">&quot;Joe&quot;</span>)</span><br><span class="line">        .order(User_.lastName) <span class="comment">// 升序排列,忽略大小写</span></span><br><span class="line">        .find();</span><br><span class="line"></span><br><span class="line">userBox.query().equal(User_.firstName,<span class="string">&quot;Joe&quot;</span>)</span><br><span class="line">        .order(User_.lastName,QueryBuilder.DESCENDING | QueryBuilder.CASE_SENSITIVE)</span><br><span class="line">        .find();</span><br></pre></td></tr></table></figure>

<h3 id="Query"><a href="#Query" class="headerlink" title="Query"></a>Query</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Query&lt;User&gt; query = builder. build();</span><br><span class="line"><span class="comment">// 返回所有匹配的对象</span></span><br><span class="line">List&lt;User&gt; joes = query.find();</span><br><span class="line"><span class="comment">// 返回第一个匹配的对象，如果不存在返回 null</span></span><br><span class="line"><span class="type">User</span> <span class="variable">joe</span> <span class="operator">=</span> query.findFirst();</span><br><span class="line"><span class="comment">// 返回唯一一个匹配的对象，如果不存在返回 null,如果有多个值抛出异常</span></span><br><span class="line"><span class="type">User</span> <span class="variable">joe</span> <span class="operator">=</span> query.findUnique();</span><br></pre></td></tr></table></figure>

<ul>
<li>如果是不断的执行 Query,那么应该缓存 Query 对象，重复使用。为了复用 Query 对象，可以改变它的属性值，或查询参数，或添加的各种边界条件。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设已经构建了一个 Query 对象，但是为了后面复用，此处 equal 边界条件的值设置为 &quot;&quot;</span></span><br><span class="line">Query&lt;User&gt; query = userBox.query().equal(User_.firstName,<span class="string">&quot;&quot;</span>).build();</span><br><span class="line"><span class="comment">// 接下来可以根据具体情况改变参数值</span></span><br><span class="line">List&lt;User&gt; joes = query.setParameter(User_.firstName,<span class="string">&quot;Joe&quot;</span>).find();</span><br><span class="line">List&lt;User&gt; jakes = query.setParameter(User_.firstName,<span class="string">&quot;Jake&quot;</span>).find();</span><br></pre></td></tr></table></figure></li>
<li>如果是多个边界条件，可以在边界条件后给每一个参数设置一个别名</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 给 equal() 查询参数设置 name 别名</span></span><br><span class="line">Query&lt;User&gt; query = userBox.query().equal(User_.firstName,<span class="string">&quot;&quot;</span>).parameterAlias(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="comment">// 然后可以传入键值对来代替属性</span></span><br><span class="line">List&lt;User&gt; joes = query.setParameter(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;Joe&quot;</span>).find();</span><br></pre></td></tr></table></figure>

<h3 id="Limit-Offset-Pagination"><a href="#Limit-Offset-Pagination" class="headerlink" title="Limit,Offset,Pagination"></a>Limit,Offset,Pagination</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Query&lt;User&gt; query = userBox.query().equal(User_.firstName,<span class="string">&quot;Joe&quot;</span>).build();</span><br><span class="line">List&lt;User&gt; joes = query.find(<span class="comment">/*offset*/</span><span class="number">10</span>,<span class="comment">/*limit*/</span><span class="number">5</span>,<span class="comment">/*results*/</span>);</span><br></pre></td></tr></table></figure>

<h3 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h3><ul>
<li><code>findLazy(),findLazyCached()</code> 返回 <code>LazyList</code> 查询结果。</li>
<li><code>LazyList</code> 是线程安全的，不可修改的只读 list,只有在访问时才会加载数据。缓存 LazyList 可以保留之前访问过的数据以避免重复加载。</li>
</ul>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p><code>query.remove()</code> 删除所有匹配的结果</p>
<h3 id="属性查询"><a href="#属性查询" class="headerlink" title="属性查询"></a>属性查询</h3><p>如果只想返回某个指定属性的值而不是匹配的全部对象列表，那么请使用 <code>PropertyQuery</code>.在构建 query 后调用 <code>property(Property)</code> 即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] emails = userBox.query().build()</span><br><span class="line">        .property(User_.mail)</span><br><span class="line">        .findStrings();</span><br></pre></td></tr></table></figure>

<ul>
<li><code>findString()</code> 返回第一条结果，<code>findStrings()</code> 返回所有结果</li>
<li>返回的是没有排序的结果，即使在构建 query 时指定了排序规则.</li>
</ul>
<h3 id="处理-null-值"><a href="#处理-null-值" class="headerlink" title="处理 null 值"></a>处理 null 值</h3><p>默认不返回 null 值。如果属性为 null，可以指定一个替代返回值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果 email 为 null,返回 unknown</span></span><br><span class="line">String[] emails = userBox.query()</span><br><span class="line">        .property(UserBox_.mail)</span><br><span class="line">        .nullValue(<span class="string">&quot;unknown&quot;</span>)</span><br><span class="line">        .findStrings();</span><br></pre></td></tr></table></figure>

<h3 id="distinct，unique"><a href="#distinct，unique" class="headerlink" title="distinct，unique"></a>distinct，unique</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回 ‘joe&#x27;</span></span><br><span class="line">String[] names = userBox.query()</span><br><span class="line">        .property(User_.firstName)</span><br><span class="line">        .distinct()</span><br><span class="line">        .findStrings();</span><br></pre></td></tr></table></figure>

<p>默认 strings 忽略大小写。当然可以定制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回 &#x27;joe&#x27; &#x27;Joe&#x27; &#x27;JOE&#x27;</span></span><br><span class="line">String[] names = userBox.query()</span><br><span class="line">        .property(User_.firstName)</span><br><span class="line">        .distinct(StringOrder.CASE_SENSITIVE)</span><br><span class="line">        .findStrings();</span><br></pre></td></tr></table></figure>

<p>只查询一个值，没有则抛出异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] names = userBox.query().build().equal(User_.isAdmin, <span class="literal">true</span>)</span><br><span class="line">    .property(User_.firstName)</span><br><span class="line">    .unique()</span><br><span class="line">    .findStrings();</span><br></pre></td></tr></table></figure>

<ul>
<li>distinct 和 unique 可以组合</li>
</ul>
<h3 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h3><p>属性查询同时提供了统计函数。</p>
<ul>
<li><code>min(),minDouble()</code></li>
<li><code>max(),maxDouble()</code></li>
<li><code>sum,sumDouble()</code>: sum() 可能溢出并抛出异常</li>
<li><code>avg()</code>: 返回 double</li>
<li><code>count()</code>: 比查询到对象列表然后求列表长度要快。可以和 distinct() 组合</li>
</ul>
<h3 id="为关联属性添加查询条件"><a href="#为关联属性添加查询条件" class="headerlink" title="为关联属性添加查询条件"></a>为关联属性添加查询条件</h3><p>创建关联属性后，可能想为只存在于关联 entity 的属性添加查询条件。SQL 中使用 JOIN.</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span> <span class="keyword">var</span> id: <span class="built_in">Long</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> name: String? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> address: ToManay&lt;Address&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span> <span class="keyword">var</span> id: <span class="built_in">Long</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> street: String? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">var</span> zip: String? = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查询住在指定街道(Address)的 xxx(Person)。可以使用<code>link(RelationInfo</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取所有名为 elmo 的对象</span></span><br><span class="line"><span class="type">val</span> <span class="variable">builder</span> <span class="operator">=</span> box.query().equal(Person_.name,<span class="string">&quot;Elmo&quot;</span>);</span><br><span class="line"><span class="comment">// 住在 Sesame 街道</span></span><br><span class="line">builder.link(Person_.address).equal(Address_.street,<span class="string">&quot;Sesame Street&quot;</span>);</span><br><span class="line"><span class="type">val</span> <span class="variable">elmosOnSesameStreet</span> <span class="operator">=</span> builder.build().find()</span><br></pre></td></tr></table></figure>

<p>如果想获取到 Address 列表呢？那么可以在 Address 中添加 @Backlint 注解</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="meta">@Backlint(to = <span class="string">&quot;addresses&quot;</span>)</span></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> persons: ToMany&lt;Person&gt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取所有 Sesame 街道对象</span></span><br><span class="line"><span class="keyword">val</span> builder = box.query().equal(Address_.street,<span class="string">&quot;Sesame Street&quot;</span>);</span><br><span class="line"><span class="comment">// 名为 elmo</span></span><br><span class="line">builder.link(Address_.persons).equal(Person_.name,<span class="string">&quot;Elmo&quot;</span>);</span><br><span class="line"><span class="keyword">val</span> sesameStreetsWithElmo = builder.build().find();</span><br></pre></td></tr></table></figure>

<p>当然，也可以不用修改 Address,使用 <code>backlink(RelationInfo)</code> 即可实现查询</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> builder = box.query().equal(Address_.street,<span class="string">&quot;Sesame Street&quot;</span>);</span><br><span class="line">builder.backlink(Person_.address).equal(Person_.name,<span class="string">&quot;Elmo&quot;</span>);</span><br><span class="line"><span class="keyword">val</span> sesameStreetWithElmos = builder.build().find();</span><br></pre></td></tr></table></figure>

<h3 id="关系属性的激进加载"><a href="#关系属性的激进加载" class="headerlink" title="关系属性的激进加载"></a>关系属性的激进加载</h3><p>默认关系属性是懒加载的。第一次访问 ToOne ,ToMany 属性时会到数据库中查询数据，然后都会使用缓存过的数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">val</span> <span class="variable">customers</span> <span class="operator">=</span> customerBox.query().build().find()</span><br><span class="line">customers[<span class="number">0</span>].orders[<span class="number">0</span>]; <span class="comment">// 第一次访问触发数据库查询</span></span><br></pre></td></tr></table></figure>

<p>如果想在查询结果返回时实现预读取 ToOne,ToMany 数据,请使用 QueryBuilder.eager</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">val</span> <span class="variable">customers</span> <span class="operator">=</span> customerBox.query()</span><br><span class="line">           .eager(Customer_.orders)</span><br><span class="line">           .build()</span><br><span class="line">           .find();</span><br></pre></td></tr></table></figure>

<p>eager 加载仅支持一层深度。如果有嵌套的关联层级，可以使用下面的 query filter 实现。</p>
<h3 id="query-filters"><a href="#query-filters" class="headerlink" title="query filters"></a>query filters</h3><p>应用于复杂的边界条件，QueryBuilder 类不能实现。使用如下规则将会非常高效：</p>
<ul>
<li>使用标准的数据库边界条件缩小目标范围。(使用 QueryBuilder 获取目标)</li>
<li>然后使用 QueryFilter 过滤<br>QueryFilter 一次检查一个目标对象，符合返回 true</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 缩小范围</span></span><br><span class="line">songBox.query().equal(Song_.bandId,bandId)</span><br><span class="line">        .filter((song) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> song.starCount * <span class="number">2</span> &gt; song.downloads;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<p>关注一下性能:</p>
<ul>
<li>ObjectBox 创建对象非常快</li>
<li>虚拟机会回收短期对象。<br>此处回收将比创建快，所以性能不是问题。</li>
</ul>
<h4 id="query-filters-和-ToMany"><a href="#query-filters-和-ToMany" class="headerlink" title="query filters 和 ToMany"></a>query filters 和 ToMany</h4><p>ToMany 提供了很多函数可以方便的转为 query filters:</p>
<ul>
<li><code>hasA</code></li>
<li><code>hasAll</code></li>
<li><code>getById</code></li>
</ul>
]]></content>
      <tags>
        <tag>ObjectBox</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>ObjectBox入门-9-订阅观察</title>
    <url>/2019/02/25/36/</url>
    <content><![CDATA[<p>objectbox</p>
<span id="more"></span>
<h2 id="Data-Observers-Reactive-Extensions"><a href="#Data-Observers-Reactive-Extensions" class="headerlink" title="Data Observers, Reactive Extensions"></a>Data Observers, Reactive Extensions</h2><p>订阅观察模式，Rx 支持</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Query&lt;Task&gt; query = taskBox.query().equal(Task_.complete,<span class="literal">false</span>).build();</span><br><span class="line">query.subscribe(subscriptions)</span><br><span class="line">    .on(AndroidScheduler.mainThread())</span><br><span class="line">    .observer(data -&gt; updateUi(data));</span><br></pre></td></tr></table></figure>

<h3 id="Data-Observers"><a href="#Data-Observers" class="headerlink" title="Data Observers"></a>Data Observers</h3><p>当数据改变时，ObjectBox 会通知所有的订阅者.他们可以订阅确定的数据类型(通过 BoxStore)或查询结果集。实现 <code>io.objectbox.reactive.DataObserver</code> 即可创建观察者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">DataObserver</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onData</span><span class="params">(T data)</span>;</span><br><span class="line">&#125;</span><br><span class="line">| onData() 异步调用，不用关心线程</span><br></pre></td></tr></table></figure>

<h4 id="订阅普通改变"><a href="#订阅普通改变" class="headerlink" title="订阅普通改变"></a>订阅普通改变</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DataObserver&lt;Class&lt;Task&gt;&gt; taskObserver = <span class="keyword">new</span> <span class="title class_">DataObserver</span>&lt;Class&lt;Task&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onData</span><span class="params">(Class&lt;Note&gt; data)</span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">boxStore.subscribe(Task.class).observer(taskObserver);</span><br><span class="line">| subscribe() 会接受所有可用的对象类型改变通知。</span><br></pre></td></tr></table></figure>

<h4 id="订阅查询"><a href="#订阅查询" class="headerlink" title="订阅查询"></a>订阅查询</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Query&lt;Task&gt; query = taskBox.query().equal(Task_.completed, <span class="literal">false</span>).build();</span><br><span class="line">subscription = query.subscribe().observer(data -&gt; updateUi(data));</span><br></pre></td></tr></table></figure>

<h4 id="取消订阅"><a href="#取消订阅" class="headerlink" title="取消订阅"></a>取消订阅</h4><p>当调用 observer() 时，返回 <code>io.objectbox.reactive.DataSubscription</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">DataSubscription</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">cancel</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCanceled</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DataSubscription</span> <span class="variable">subscription</span> <span class="operator">=</span> boxStore.subscribe().observer(myObserver);</span><br><span class="line"></span><br><span class="line"><span class="comment">// At some later point:</span></span><br><span class="line">subscription.cancel();</span><br></pre></td></tr></table></figure>

<p>通常情况下建议使用 DataSubscriptionList</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">DataSubscriptionList</span> <span class="variable">subscriptions</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSubscriptionList</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onStart</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">super</span>.onStart();</span><br><span class="line">  Query&lt;X&gt; query = box.query()... .build();</span><br><span class="line">  query.subscribe(subscriptions)... .observe(...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onStop</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">super</span>.onStop();</span><br><span class="line">  subscriptions.cancel();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="订阅，事务"><a href="#订阅，事务" class="headerlink" title="订阅，事务"></a>订阅，事务</h4><p>当事务提交时发出订阅通知。单独调用<code>box.put(),remove()</code> ，默认的事务会开启提交。例如如下将触发两次 User.class 通知；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">box.put(firendUser);</span><br><span class="line">box.put(myUser);</span><br></pre></td></tr></table></figure>

<p>使用 <code>runInTx(),callInTx()</code> 可以将多个操作在同一个十五中提交.如上可以修改为:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">box.put(friendUser,myUser);</span><br></pre></td></tr></table></figure>

<h4 id="响应式扩展"><a href="#响应式扩展" class="headerlink" title="响应式扩展"></a>响应式扩展</h4><h5 id="线程切换"><a href="#线程切换" class="headerlink" title="线程切换"></a>线程切换</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Query&lt;Task&gt; query = taskBox.query().equal(Task_.complete, <span class="literal">false</span>).build();</span><br><span class="line">query.subscribe().on(AndroidScheduler.mainThread()).observer(data -&gt; updateUi(data));</span><br></pre></td></tr></table></figure>

<p>当然可以使用自定义 Looper 创建 AndroidScheduler,或者实现 <code>io.objectbox.reactive.Scheduler</code></p>
<ul>
<li>查询在后台线程执行</li>
<li>DataTransformer 运行在后台线程</li>
<li>DataObserver 和 ErrorObserver 运行在后台线程，除非通过 on() 指定</li>
</ul>
<h5 id="数据转换"><a href="#数据转换" class="headerlink" title="数据转换"></a>数据转换</h5><p>如何订阅实际的对象数量:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">boxStore.subscribe()</span><br><span class="line">    .transform(clazz -&gt; <span class="keyword">return</span> boxStore.boxFor(clazz).count())</span><br><span class="line">    .observer(count -&gt; updateCount(count));</span><br></pre></td></tr></table></figure>

<h5 id="异常订阅"><a href="#异常订阅" class="headerlink" title="异常订阅"></a>异常订阅</h5><p>transformer 可能抛出各种异常，DataObserver 可能抛出 RuntimeException.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ErrorObserver</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Throwable th)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 subscribe() 后调用 onError() 即可.</p>
<h5 id="一次通知-vs-改变即通知"><a href="#一次通知-vs-改变即通知" class="headerlink" title="一次通知 vs. 改变即通知"></a>一次通知 vs. 改变即通知</h5><p>当订阅 query 后，DataObserver 具有如下行为：</p>
<ul>
<li>初始化查询结果(就在订阅后)</li>
<li>更新查询结果(在数据改变后)</li>
</ul>
<p>有时候仅对其中一种行为感兴趣.single() 和 onlyChange() 应运而生(在 subscribe() 后调用)<br>single() 只响应一次通知即自动取消。</p>
<h5 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h5><p>一般情况下，为了避免内存泄露，通常尽可能在不需要的时候取消订阅。当然，你不在乎的话，在 subscribe() 后调用 weak() 也可以.</p>
<h4 id="ObjectBox-RxJava-扩展库"><a href="#ObjectBox-RxJava-扩展库" class="headerlink" title="ObjectBox RxJava 扩展库"></a>ObjectBox RxJava 扩展库</h4><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">&quot;io.objectbox:objectbox-rxjava:$objectboxVersion&quot;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>ObjectBox</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>ObjectBox高级-1-配置</title>
    <url>/2019/02/26/48/</url>
    <content><![CDATA[<p>objectbox</p>
<span id="more"></span>
<h3 id="手动添加依赖库"><a href="#手动添加依赖库" class="headerlink" title="手动添加依赖库"></a>手动添加依赖库</h3><p>如果 ObjectBox 插件没有自动添加依赖库和注解处理器，那么手动添加。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    <span class="comment">// all below should be added automatically by the plugin</span></span><br><span class="line">    compile <span class="string">&quot;io.objectbox:objectbox-android:$objectboxVersion&quot;</span></span><br><span class="line">    annotationProcessor <span class="string">&quot;io.objectbox:objectbox-processor:$objectboxVersion&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    <span class="comment">// all below should be added automatically by the plugin</span></span><br><span class="line">    compile <span class="string">&quot;io.objectbox:objectbox-android:$objectboxVersion&quot;</span></span><br><span class="line">    kapt <span class="string">&quot;io.objectbox:objectbox-processor:$objectboxVersion&quot;</span></span><br><span class="line">    <span class="comment">// some useful Kotlin extension functions</span></span><br><span class="line">    compile <span class="string">&quot;io.objectbox:objectbox-kotlin:$objectboxVersion&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="改变-model-文件位置"><a href="#改变-model-文件位置" class="headerlink" title="改变 model 文件位置"></a>改变 model 文件位置</h3><p>默认 model 文件位于 module-name&#x2F;objectbox-models&#x2F;default.json.</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        javaCompileOptions &#123;</span><br><span class="line">            annotationProcessorOptions &#123;</span><br><span class="line">                arguments = [ <span class="string">&quot;objectbox.modelPath&quot;</span> : <span class="string">&quot;$projectDir/schemas/objectbox.json&quot;</span>.toString() ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">kapt &#123;</span><br><span class="line">    arguments &#123;</span><br><span class="line">        arg(<span class="string">&quot;objectbox.modelPath&quot;</span>, <span class="string">&quot;$projectDir/schemas/objectbox.json&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="改变-MyObjectBox-的包名"><a href="#改变-MyObjectBox-的包名" class="headerlink" title="改变 MyObjectBox 的包名"></a>改变 MyObjectBox 的包名</h3><p>默认 MyObjectBox 类包名和 entity 类或其父类的包名相同.</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        javaCompileOptions &#123;</span><br><span class="line">            annotationProcessorOptions &#123;</span><br><span class="line">                arguments = [ <span class="string">&quot;objectbox.myObjectBoxPackage&quot;</span> : <span class="string">&quot;com.example.custom&quot;</span> ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">kapt &#123;</span><br><span class="line">    arguments &#123;</span><br><span class="line">        arg(<span class="string">&quot;objectbox.myObjectBoxPackage&quot;</span>, <span class="string">&quot;com.example.custom&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="开启-debug-模式"><a href="#开启-debug-模式" class="headerlink" title="开启 debug 模式"></a>开启 debug 模式</h3><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        javaCompileOptions &#123;</span><br><span class="line">            annotationProcessorOptions &#123;</span><br><span class="line">                arguments = [ <span class="string">&#x27;objectbox.debug&#x27;</span> : <span class="string">&#x27;true&#x27;</span> ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">kapt &#123;</span><br><span class="line">    arguments &#123;</span><br><span class="line">        arg(<span class="string">&quot;objectbox.debug&quot;</span>, <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="greenDAO-兼容"><a href="#greenDAO-兼容" class="headerlink" title="greenDAO 兼容"></a>greenDAO 兼容</h3><p>查看<a href="https://blog.dang8080.cn/2019/02/24/ObjectBox%E5%85%A5%E9%97%A8-1-%E7%AE%80%E4%BB%8B/#%E9%85%8D%E7%BD%AE">greenDAO 兼容配置</a></p>
]]></content>
      <tags>
        <tag>ObjectBox</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>ObjectBox高级-2-Object IDs</title>
    <url>/2019/02/26/19/</url>
    <content><![CDATA[<p>objectbox</p>
<span id="more"></span>
<p>Object 必须具有一个类型为 <code>long</code> 的属性.当然可以使用它的包装类 <code>java.lang.Long</code>,但是不建议使用包装类.<br>其他类型的 ID ( UID 等)可以自由定义，查询等操作。</p>
<h3 id="news-vs-persisted-entities"><a href="#news-vs-persisted-entities" class="headerlink" title="news vs. persisted entities"></a>news vs. persisted entities</h3><p>当创建一个对象时，还没有存入，它们的 ID 是 0.一旦该对象存入，ObjectBox 将为该对象指定 ID.可以通过 <code>put()</code>返回值拿到该 ID.</p>
<p>所以在 ObjectBox 内部通常把 ID 作为一个状态指示器,如果为 0 表示新创建，不为 0 表示已经存储。关联特别依赖这个特性.</p>
<h3 id="特殊的-Object-IDs"><a href="#特殊的-Object-IDs" class="headerlink" title="特殊的 Object IDs"></a>特殊的 Object IDs</h3><p>Object IDs 可能是任意 <code>long</code> 值，除了以下两种:</p>
<ul>
<li>0: 或者当类型为 <code>Long</code> 时为 null,被认为是新创建，还未存储。<code>put</code>这个对象总是会插入一个新对象，并指定一个未使用过的 ID.</li>
<li>0xFFFFFFFFFFFFFFFF (-1 in Java): ObjectBox 保留。</li>
</ul>
<h3 id="ObjectBox-指定-ID"><a href="#ObjectBox-指定-ID" class="headerlink" title="ObjectBox 指定 ID"></a>ObjectBox 指定 ID</h3><p>对于每一个新对象，ObjectBox 把比当前 box 中最大的 ID 值大的未使用的值指定给新对象的 ID.比如 box 中有一个 ID 为 1 和 ID 为 100 的对象，那么新创建对象的 ID 将为 101.</p>
<p>默认只有 ObjectBox 可以指定 ID(👇 介绍).如果试图自己存入一个 ID 比当前 ID 值最大的还大的对象，ObjectBox 将抛出错误。</p>
<h3 id="手动指定-IDs"><a href="#手动指定-IDs" class="headerlink" title="手动指定 IDs"></a>手动指定 IDs</h3><p>如果需要手动指定 ID,那么请添加如下注解:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Id(assignable = true)</span></span><br><span class="line"><span class="type">long</span> id;</span><br></pre></td></tr></table></figure>

<p>这将会允许存入任意值 ID 的对象。当然设置 ID 为 0 时，ObjectBox 将制定新 ID</p>
<blockquote>
<p>自定义 ID 会打破自动状态指示监视(new vs. persisted). 所以应该立即存入该自定义 ID 对象，可能还得手动绑定 box，特别在关联状况下.</p>
</blockquote>
<h3 id="ID-的-String-别名-还在路上…"><a href="#ID-的-String-别名-还在路上…" class="headerlink" title="ID 的 String 别名 (还在路上…)"></a>ID 的 String 别名 (还在路上…)</h3><p>查看特性实现进度<a href="https://github.com/objectbox/objectbox-java/issues/167">String ID alias</a></p>
]]></content>
      <tags>
        <tag>ObjectBox</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>ObjectBox高级-3-自定义类型</title>
    <url>/2019/02/26/46/</url>
    <content><![CDATA[<p>objectbox</p>
<span id="more"></span>
<p>ObjectBox 支持以下类型（Java）:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span>, Boolean</span><br><span class="line"><span class="type">int</span>, Integer</span><br><span class="line"><span class="type">short</span>, Short</span><br><span class="line"><span class="type">long</span>, Long</span><br><span class="line"><span class="type">float</span>, Float</span><br><span class="line"><span class="type">double</span>, Double</span><br><span class="line"><span class="type">byte</span>, Byte</span><br><span class="line"><span class="type">char</span>, Character</span><br><span class="line"><span class="type">byte</span>[]</span><br><span class="line">String</span><br><span class="line">Date</span><br></pre></td></tr></table></figure>

<h3 id="转换器注解和属性转换"><a href="#转换器注解和属性转换" class="headerlink" title="转换器注解和属性转换"></a>转换器注解和属性转换</h3><p>使用 @Convert 注解将其他类型属性转为内置属性。此处需要提供 PropertyConverter 实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// enum 转为 Integer</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Convert(converter = RoleConverter.class, dbType = Integer.class)</span></span><br><span class="line">    <span class="keyword">private</span> Role role;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Role</span> &#123;</span><br><span class="line">        DEFAULT(<span class="number">0</span>), AUTHOR(<span class="number">1</span>), ADMIN(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">        Role(<span class="type">int</span> id) &#123;</span><br><span class="line">            <span class="built_in">this</span>.id = id;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">RoleConverter</span> <span class="keyword">implements</span> <span class="title class_">PropertyConverter</span>&lt;Role, Integer&gt;; &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Role <span class="title function_">convertToEntityProperty</span><span class="params">(Integer databaseValue)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (databaseValue == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (Role role : Role.values()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (role.id == databaseValue) &#123;</span><br><span class="line">                    <span class="keyword">return</span> role;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> Role.DEFAULT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Integer <span class="title function_">convertToDatabaseValue</span><span class="params">(Role entityProperty)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> entityProperty == <span class="literal">null</span> ? <span class="literal">null</span> : entityProperty.id;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="more"><a href="#more" class="headerlink" title="more"></a>more</h3><ul>
<li>如果是在 entity 类中定义自定义转换器，那么该转换器应该为 static.</li>
<li>别忘记正确处理 null,通常如果 input 是 null，也应返回 null.</li>
<li>推荐使用基本数据类型，更易转换.</li>
<li>绝对不能在转换器中调用数据库(Box,BoxStore),转换器方法在事务中调用，例如读取或写入对象到 box 中将会失败。</li>
<li>为提高性能，ObjectBox 使用了对所有的转换器使用了唯一一个实例。请保证除默认无参构造方法外没有自定义其他构造方法。同时请保证线程安全，应为在 multiple entities 中可能涉及到并发.</li>
</ul>
<h3 id="List-Array-类型"><a href="#List-Array-类型" class="headerlink" title="List&#x2F;Array 类型"></a>List&#x2F;Array 类型</h3><p>可以使用转换器转换 List 类型。例如把 List<String> 转为一条 String 的 JSON 数组.<br>当前不支持 Array 转换器.查看特性实现进度<a href="https://github.com/objectbox/objectbox-java/issues/42">Array</a></p>
<h3 id="Enums"><a href="#Enums" class="headerlink" title="Enums"></a>Enums</h3><p>最佳实践:</p>
<ul>
<li>不要持久化 enum 的 ordinal 或 name: 二者都不稳定，且在下次你修改 enum 定义时会改变</li>
<li>使用稳定的 ids: 在 enum 中定义自定义属性(integer,string) 都可以保证稳定。使用该特性作为你的持久化映射.</li>
<li>准备好应对未知: 定义一个 UNKNOWN 的 enmu 值。可以应对 null 或 unknown 值的情况。例如可以确保已经被移除的 enum 值不会导致 App 崩溃.</li>
</ul>
<h3 id="查询时的自定义类型"><a href="#查询时的自定义类型" class="headerlink" title="查询时的自定义类型"></a>查询时的自定义类型</h3><p><code>QueryBuilder</code> 是不关心自定类型的。请使用内置类型查询。</p>
]]></content>
      <tags>
        <tag>ObjectBox</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>ObjectBox高级-4-entity继承</title>
    <url>/2019/02/26/42/</url>
    <content><![CDATA[<p>objectbox</p>
<span id="more"></span>
<p>ObjectBox 允许子类继承 entity 父类持久化的属性。同样也支持继承非 entity 类。1.4+ 也支持多继承.<br>对于父类来说可以使用 @BaseEntity.</p>
<ul>
<li>无注解: 类本身及其属性不需要持久化</li>
<li>@BaseEntity: 属性在子类中持久化，类本身不持久化</li>
<li>@Entity: 属性在子类中持久化，类本身也持久化</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// base class:</span></span><br><span class="line"><span class="meta">@BaseEntity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span> <span class="type">long</span> id;</span><br><span class="line">    String baseString;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Base</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Base</span><span class="params">(<span class="type">long</span> id, String baseString)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.baseString = baseString;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sub class:</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"></span><br><span class="line">    String subString;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Sub</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Sub</span><span class="params">(<span class="type">long</span> id, String baseString, String subString)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(id, baseString);</span><br><span class="line">        <span class="built_in">this</span>.subString = subString;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// entities inherit properties from entities</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubSub</span> <span class="keyword">extends</span> <span class="title class_">Sub</span> &#123;</span><br><span class="line"></span><br><span class="line">    String subSubString;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SubSub</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SubSub</span><span class="params">(<span class="type">long</span> id, String baseString, String subString, String subSubString)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(id, baseString, subString);</span><br><span class="line">        <span class="built_in">this</span>.subSubString = subSubString;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用前注意"><a href="#使用前注意" class="headerlink" title="使用前注意"></a>使用前注意</h4><ul>
<li>在继承链中可能存在由 @BaseEntity 注解的类，它们的属性将被忽略，不会成为 entity model 的一部分</li>
<li>不推荐继承一个仅含有 ID 属性的 base entity 类.</li>
<li>某些情况下可以使用 interface 更简单明了</li>
</ul>
<h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><ul>
<li>@BaseEntity 注解的父类不能成为 library 的一部分。</li>
<li>没有多态查询(例如查询父类却希望得到子类)</li>
<li>当前无论是 @Entity 还是 @BaseEntity 注解的父类，都不能使用 ToOne ToMany 关联</li>
</ul>
]]></content>
      <tags>
        <tag>ObjectBox</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>ObjectBox高级-5-更新数据模型</title>
    <url>/2019/02/26/22/</url>
    <content><![CDATA[<p>objectbox</p>
<span id="more"></span>
<p>ObjectBox 大多数情况下自动管理数据模型.当添加&#x2F;删除 entities 或属性时，ObjectBox 自动作出响应。<br>对于其他改变如 保留或改变类型，ObjectBox 需要额外信息。</p>
<h3 id="UIDs"><a href="#UIDs" class="headerlink" title="UIDs"></a>UIDs</h3><p>ObjectBox 通过 unique IDs(UIDs) 来追踪 entities 和属性的变化。所有的 UIDs 都存储在 module-name&#x2F;objectbox-models&#x2F;default.json 中,可以使用版本控制软件(git)进行管理。</p>
<p>简单来说: 为了使 UID 相关的改变生效，在这些 entity 或 属性上放置 @Uid 然后编译，在获取进一步提示。</p>
<h3 id="重命名-entities-和-属性"><a href="#重命名-entities-和-属性" class="headerlink" title="重命名 entities 和 属性"></a>重命名 entities 和 属性</h3><p>需要 UID 注解的原因是: 如果仅仅改变 entities 和属性的名字，ObjectBox 只会意识到 old entity 不见了，而创建了新的 entity.<br>所以告诉 ObjectBox 重命名 entity 和数据，而不是丢弃它们.它们是相同的一个 entity。实际上是在内部给 entity 绑定一个 UID.属性也一样.</p>
<h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>第一步: 为想要重命名的 entity&#x2F;属性添加空的 @Uid 注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Uid</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyName</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>第二步: 编译项目，然后会输出错误信息：给出当前 entity&#x2F;属性的 UID</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">error: [ObjectBox] UID operations <span class="keyword">for</span> entity <span class="string">&quot;MyName&quot;</span>:</span><br><span class="line">  [Rename] apply the current UID using <span class="meta">@Uid(6645479796472661392L)</span> -</span><br><span class="line">  [Change/reset] apply a <span class="keyword">new</span> <span class="title class_">UID</span> using <span class="meta">@Uid(4385203238808477712L)</span></span><br></pre></td></tr></table></figure>

<p>第三部: 把上面的 UID 复制到 @Uid() 里</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Uid(6645479796472661392L)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyName</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>第四步: 重命名吧</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Uid(6645479796472661392L)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyNewName</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>或者可以在 default.json 中找到 UID,然后直接使用到 @Uid() 上，重命名即可</p>
</blockquote>
<h3 id="修改属性类型"><a href="#修改属性类型" class="headerlink" title="修改属性类型"></a>修改属性类型</h3><p>想要修改属性类型，那么 ObjectBox 内部得创建一个新类型。因为 ObjectBox 不会迁移数据。</p>
<ul>
<li>重命名属性类型：这样该属性就会被认为是新属性(如果该属性已经有 @Uid 注解了，则行不通)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// old:</span></span><br><span class="line">String year;</span><br><span class="line"><span class="comment">// new:</span></span><br><span class="line"><span class="type">int</span> yearInt;</span><br></pre></td></tr></table></figure>

<ul>
<li>告诉 ObjectBox 对新属性使用新 UID.</li>
</ul>
<h4 id="实践一下"><a href="#实践一下" class="headerlink" title="实践一下"></a>实践一下</h4><p>第一步：对想修改类型的属性添加 @Uid 注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Uid</span></span><br><span class="line">String year;</span><br></pre></td></tr></table></figure>

<p>第二步: 编译获取错误信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">error: [ObjectBox] UID operations <span class="keyword">for</span> property <span class="string">&quot;MyEntity.year&quot;</span>:</span><br><span class="line">  [Rename] apply the current UID using <span class="meta">@Uid(6707341922395832766L)</span> -</span><br><span class="line">  [Change/reset] apply a <span class="keyword">new</span> <span class="title class_">UID</span> using <span class="meta">@Uid(9204131405652381067L)</span></span><br></pre></td></tr></table></figure>

<p>第三步：为该属性应用新 @Uid,并修改类型.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Uid(9204131405652381067L)</span></span><br><span class="line"><span class="type">int</span> year;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>ObjectBox</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>ObjectBox高级-6-元模型,IDs,UIDs</title>
    <url>/2019/02/26/22/</url>
    <content><![CDATA[<p>objectbox</p>
<span id="more"></span>
<p>不像 SQLite 这样的数据库，ObjectBox 不需要你创建 database schema.这不意味着 ObjectBox 是无 schema 的。为高效起见，ObjectBox 对存储的数据维护了一个元模型(meta model)。此元模型实际上等价于 ObjectBox 的 schema.它包含了所有属性的类型、indexes 等.不同之处在于 ObjectBox 试图自动管理该元模型.某些情况下，这需要你帮忙.</p>
<blockquote>
<p>Object 的 IDs 是 @Id 定义的，而 所有 entity 类型的实例都绑定一个 meta model ID.</p>
</blockquote>
<h3 id="JSON-for-consistent-IDs"><a href="#JSON-for-consistent-IDs" class="headerlink" title="JSON for consistent IDs"></a>JSON for consistent IDs</h3><p>ObjectBox 把一部分元模型保存在 JSON 文件中.<strong>此文件应该通过版本控制软件管理</strong>,主要原因是：它可以保证 元模型里的 IDs 和 UIDs 跨设备一致.</p>
]]></content>
      <tags>
        <tag>ObjectBox</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Podman(Mac)挂载本地文件功能</title>
    <url>/2022/03/20/47/</url>
    <content><![CDATA[<p>在 mac 平台使用 podman 代替 docker 的过程中遇到了容器挂载文件的问题，这里将实践过程总结一下.</p>
<span id="more"></span>

<p>先说下，为什么替换 docker. docker-desktop 其实还是很好用的，只不过在使用中会发现以下几个问题 1、启动慢 2、总是更新失败。而且根据网上消息早期 docker-desktop 内部使用的是 virtualbox 技术，所以就选择了 podman 替换。</p>
<p>使用中 podman 和 docker 没什么多的使用差别，除了多了 <code>podman machine</code> 的操作，这是因为 podman 使用了 quemu 加载 fedora 作为容器的虚拟物理机使用。所以此处会出现挂载的问题也就是因为 quemu 没有先挂载本地文件，那么自然容器也就无法访问并挂载了，这个问题据说在 podman 4.0 中将得到解决，我们拭目以待。</p>
<p>回到正题，看看如何为 podman 挂载上本地文件。</p>
<p>首先当然可以通过 <code>scp</code> 将文件拷贝到虚拟机中。但实际中很浪费空间。</p>
<p>接下来就是如何将 macOS 文件系统挂载上去。此处则需要使用 <code>sshfs</code> 通过 ssh 反向代理登录进虚拟机(qemu). (需要注意的是，每次进行 <code>podman machine</code> 操作时都需要重新走一遍.)</p>
<p>第一步通过 <code>podman machine --log-level=debug ssh -- exit 2&gt;&amp;1 | grep Executing | awk &#123;&#39;print $8&#39;&#125;</code> 获取私有的 ssh 端口.</p>
<p>接下来使用此端口连接到 qemu 主机</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh -i ~/.ssh/podman-machine-default -R 10000:$(hostname):22 -p &lt;PORT&gt; core@localhost</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在 qemu 主机中生成和 macOS 主机连接的 ssh key</span></span><br><span class="line">ssh-keygen -t rsa -N &quot;&quot; -f ~/.ssh/id_rsa</span><br><span class="line">ssh-copy-id -p 10000 &lt;MAC USERNAME&gt;@127.0.0.1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">接下来挂载 macOS 的挂载点</span></span><br><span class="line">sudo mkdir -p /mnt/Users</span><br><span class="line">sudo chown core:core /mnt/Users</span><br></pre></td></tr></table></figure>

<p>现在就可以通过 <code>sshfs</code> 挂载了<br><code>sshfs -p 10000 $USER@127.0.0.1:/Users /mnt/Users</code>，</p>
<p>使用 screen 来将此操作置于后台运行 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">screen -t podman</span><br><span class="line">ssh -i ~/.ssh/podman-machine-default -R 10000:$(hostname):22 -p &lt;PORT&gt; core@localhost</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">挂载本地文件到 qemu 主机</span></span><br><span class="line">sshfs -p 10000 $USER@127.0.0.1:/Users /mnt/Users</span><br></pre></td></tr></table></figure>

<h3 id="其他方案"><a href="#其他方案" class="headerlink" title="其他方案"></a>其他方案</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">podman machine</span><br><span class="line"></span><br><span class="line">Current solution requires modifying the path, since the root directory is read-only on CoreOS:</span><br><span class="line"></span><br><span class="line">podman machine init -v /foo:/mnt/foo</span><br><span class="line"></span><br><span class="line">podman --remote run -v /mnt/foo:/foo</span><br><span class="line"></span><br><span class="line">This breaks compatibility with local version, that would do podman run -v /foo:/foo (no /mnt)</span><br><span class="line"></span><br><span class="line">other systems</span><br><span class="line"></span><br><span class="line">No issues with mounting, since the root directory can be modified to create the mountpoint dir:</span><br><span class="line"></span><br><span class="line">podman machine init -v /foo:/foo --volume-driver=sshfs</span><br><span class="line"></span><br><span class="line">podman --remote run -v /foo:/foo</span><br><span class="line"></span><br><span class="line">This means one can use the same command remote as local, when using something like Fedora.</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://dalethestirling.github.io/Macos-volumes-with-Podman/">https://dalethestirling.github.io/Macos-volumes-with-Podman/</a><br><a href="https://github.com/containers/podman/issues/8016#issuecomment-995242552">https://github.com/containers/podman/issues/8016#issuecomment-995242552</a></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>Room &amp; kotlin coroutine</title>
    <url>/2019/03/03/01/</url>
    <content><![CDATA[<p>room kotlin coroutine</p>
<span id="more"></span>
<h4 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h4><p>Room 2.1 开始支持 Kotlin 协程。DAO 方法可以使用 suspend 标记以确保这些方法不会在主线程中被执行。<br>Room 使用 <code>Executor</code>(来自框架组件) 作为 <code>Dispatcher</code> 运行 SQL 语句，当然在编译 <code>RoomDatabase</code> 时，你也可以提供自己的 <code>Executor</code>.</p>
<blockquote>
<p>当前协程支持正在开发中，更多特性正在计划中</p>
</blockquote>
<h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><p>请升级 Room 到 v2.1, 同时 Kotlin v1.3.0+ , Coroutines v1.0.0+</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">&quot;androidx.room:room-coroutines:$&#123;versions.room&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<p>现在就可以使用啦</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">UsersDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query(<span class="string">&quot;SELECT * FROM users&quot;</span>)</span></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUsers</span><span class="params">()</span></span>: List&lt;User&gt;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query(<span class="string">&quot;UPDATE users SET age = age + 1 WHERE userId = :userId)</span></span></span><br><span class="line"><span class="string"><span class="meta">    suspend fun incrementUserAge(userId: String)</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">    @Insert</span></span></span><br><span class="line"><span class="string"><span class="meta">    suspend fun insertUser(user: User)</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">    @Update</span></span></span><br><span class="line"><span class="string"><span class="meta">    suspend fun updateUser(user: User)</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">    @Delete</span></span></span><br><span class="line"><span class="string"><span class="meta">    suspend fun deleteUser(user: User)</span></span></span><br><span class="line"><span class="string"><span class="meta">&#125;</span></span></span><br></pre></td></tr></table></figure>

<p>在调用其他 suspending DAO 函数时，@Transaction 也可以被 suspending</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">UsersDao</span> &#123;</span><br><span class="line">    <span class="meta">@Transaction</span></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">setLoggedInUser</span><span class="params">(loggedInUser: <span class="type">user</span>)</span></span> &#123;</span><br><span class="line">        deleteUser(loggedInUser)</span><br><span class="line">        insertUser(loggedInUser)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query(<span class="string">&quot;DELETE FROM users&quot;</span>)</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">deleteUser</span><span class="params">(user: <span class="type">User</span>)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">insertUser</span><span class="params">(user: <span class="type">User</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据是否在 transaction 内调用，Room 对 suspending 函数处理逻辑不同.</p>
<ul>
<li>在 Transaction 中<blockquote>
<p>在数据库语句被触发的 CoroutineContext 下，Room 不做任何处理。函数调用者应该确保此方法不会在 UI 线程中执行.因为 suspend 函数只能被其他 suspend 函数 或在 coroutine 内调用，所以你不能把 Dispatchers.Main 赋值给 Dispatcher，应该是 Dispatchers.IO 或自定义</p>
</blockquote>
</li>
<li>不在 Transaction 中<blockquote>
<p>Room 会确保数据库语句在 <code>Architecutre Components I/O Dispatcher</code> 中触发。该 Dispatcher 在同一个 I&#x2F;O Executor 的一个后台线程中运行 LiveData</p>
</blockquote>
</li>
</ul>
<h3 id="底层"><a href="#底层" class="headerlink" title="底层"></a>底层</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Insert</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">insertUserSync</span><span class="params">(user: <span class="type">User</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Insert</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">insertUser</span><span class="params">(user: <span class="type">User</span>)</span></span></span><br></pre></td></tr></table></figure>

<p>对于同步 insert,生成的代码开始启动一个 transaction,然后执行 insert,标记 transaction successfull ，终结。<br>同步方法在被调用处的线程执行.</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> void insertUserSync(<span class="keyword">final</span> User user) &#123;</span><br><span class="line">  __db.beginTransaction();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    __insertionAdapterOfUser.insert(user);</span><br><span class="line">    __db.setTransactionSuccessful();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    __db.endTransaction();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>suspending 会确保不会在 UI 线程中执行。生成的代码会传递一个 Continuation.在 <code>Callable#call()</code> 中执行和同步相同的代码</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object insertUserSuspend(<span class="keyword">final</span> User user,</span><br><span class="line">    <span class="keyword">final</span> Continuation&lt;? <span class="keyword">super</span> <span class="built_in">Unit</span>&gt; p1) &#123;</span><br><span class="line">  <span class="keyword">return</span> CoroutinesRoom.execute(__db, new Callable&lt;<span class="built_in">Unit</span>&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">Unit</span> call() throws Exception &#123;</span><br><span class="line">      __db.beginTransaction();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        __insertionAdapterOfUser.insert(user);</span><br><span class="line">        __db.setTransactionSuccessful();</span><br><span class="line">        <span class="keyword">return</span> kotlin.<span class="built_in">Unit</span>.INSTANCE;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        __db.endTransaction();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, p1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>CoroutinesRoom.execute</code> 会根据数据库是否 open,当前调用是否在 transaction 内来切换处理 context.</p>
<ul>
<li>is open &amp; in transaction<blockquote>
<p>仅调用 insert 逻辑</p>
</blockquote>
</li>
<li>not in transaction<blockquote>
<p>使用 <code>Architecture Components IO Executor</code> 在后台线程执行 insert 逻辑</p>
</blockquote>
</li>
</ul>
]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>Room</tag>
        <tag>Kotlin</tag>
        <tag>Kotlin 协程</tag>
      </tags>
  </entry>
  <entry>
    <title>Termux 原理探究</title>
    <url>/2020/03/31/22/</url>
    <content><![CDATA[<p>详细介绍请移步: <a href="https://termux.com/">官网</a>,<a href="http://www.termux.cn/">中文镜像</a>,<a href="https://mirror.tuna.tsinghua.edu.cn/help/termux/">清华源</a></p>
<span id="more"></span>
<h3 id="源码探究"><a href="#源码探究" class="headerlink" title="源码探究"></a>源码探究</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">create_subprocess</span><span class="params">(JNIEnv* env,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">char</span> <span class="type">const</span>* cmd,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">char</span> <span class="type">const</span>* cwd,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">char</span>* <span class="type">const</span> argv[],</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">char</span>** envp,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int</span>* pProcessId,</span></span></span><br><span class="line"><span class="params"><span class="function">        jint rows,</span></span></span><br><span class="line"><span class="params"><span class="function">        jint columns)</span></span></span><br></pre></td></tr></table></figure>
<p>此方法即为 termux 的核心,通过该方法将用户输入的命令和当前工作的文件夹传入打开的终端去执行.</p>
<p>1、打开伪终端</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ptm = <span class="built_in">open</span>(<span class="string">&quot;/dev/ptmx&quot;</span>, O_RDWR | O_CLOEXEC);</span><br><span class="line"><span class="keyword">if</span> (ptm &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">throw_runtime_exception</span>(env, <span class="string">&quot;Cannot open /dev/ptmx&quot;</span>);</span><br><span class="line"><span class="comment">// UNIX98 的伪终端模式.</span></span><br><span class="line"><span class="comment">// pts(pseudo-terminal slave)/ptmx(pseudo-terminal master) 结合使用即可实现 pty(pseudo-tty).</span></span><br><span class="line"><span class="comment">// pts/ptmx 是成堆的逻辑终端设备(对 master 的操作会映射到 slave 上).</span></span><br></pre></td></tr></table></figure>

<p>2、初始化设置</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LACKS_PTSNAME_R</span></span><br><span class="line">    <span class="type">char</span>* devname;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="type">char</span> devname[<span class="number">64</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">// grantpt 在伪终端 slave 设备可被使用之前设置权限,使应用程序可以访问它.</span></span><br><span class="line">    <span class="comment">// 把设备节点的 userid 设置为调用者的实际 userid, groupid 为一非指定值,通常可以是访问该终端设备的组.</span></span><br><span class="line">    <span class="comment">// 将权限设为: 对单个所有者是读写,对组所有者是写(0620).</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// unlockpt 用于准予对伪终端 slave 设备的访问,从而允许应用打开该设备.</span></span><br><span class="line">    <span class="comment">// 可以阻止其他进程打开该设备,使得建立该设备的应用程序有机会在使用master、slave 设备之前正确的初始化这些设备.</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">grantpt</span>(ptm) || <span class="built_in">unlockpt</span>(ptm) ||</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LACKS_PTSNAME_R </span></span><br><span class="line">            <span class="comment">// 在给定伪终端 master 的设备文件符时,找到对应 slave 设备的路径名.</span></span><br><span class="line">            <span class="comment">// 如果成功,会在一个静态存储区存放设备名称并返回其地址,否则 NULL.</span></span><br><span class="line">            <span class="comment">// include &lt;stdlib.h&gt;</span></span><br><span class="line">            <span class="comment">// 返回指针不能被调用进程释放.</span></span><br><span class="line">            (devname = <span class="built_in">ptsname</span>(ptm)) == <span class="literal">NULL</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span>       </span></span><br><span class="line">            <span class="comment">// 可重入版本.</span></span><br><span class="line">            <span class="built_in">ptsname_r</span>(ptm, devname, <span class="built_in">sizeof</span>(devname))</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">       ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">throw_runtime_exception</span>(env, <span class="string">&quot;Cannot grantpt()/unlockpt()/ptsname_r() on /dev/ptmx&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Enable UTF-8 mode and disable flow control to prevent Ctrl+S from locking up the display.</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">termios</span> tios;</span><br><span class="line"><span class="comment">// 返回 ptm 对应伪终端的属性.</span></span><br><span class="line"><span class="built_in">tcgetattr</span>(ptm, &amp;tios);</span><br><span class="line"><span class="comment">// tcgetattr(STDIN_FILENO,&amp;ts); STDIN_FILENO 值为1,表示标准输入的文件喵输入.</span></span><br><span class="line">tios.c_iflag |= IUTF8;</span><br><span class="line">tios.c_iflag &amp;= ~(IXON | IXOFF); <span class="comment">// 关闭输入时对 XON/XOFF流进行控制</span></span><br><span class="line"><span class="built_in">tcsetattr</span>(ptm, TCSANOW, &amp;tios); </span><br><span class="line"><span class="comment">// TCSANOW: 立即生效</span></span><br><span class="line"><span class="comment">// TCSADRAIN: 在所有写入 fd 的输出被传输后生效.建议在修改输出参数时使用.</span></span><br><span class="line"><span class="comment">// TCSAFLUSH: 在所有写入 fd 应用对象的输出都被传输后生效,所有已接受但未读入的输入都在改变生效前被丢弃</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置初始化窗口大小</span></span><br><span class="line"><span class="comment">// include &lt;termios.h&gt;</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">winsize</span> sz = &#123; .ws_row = (<span class="type">unsigned</span> <span class="type">short</span>) rows, .ws_col = (<span class="type">unsigned</span> <span class="type">short</span>) columns &#125;;</span><br><span class="line"><span class="built_in">ioctl</span>(ptm, TIOCSWINSZ, &amp;sz); <span class="comment">// 获取 winsize 值</span></span><br><span class="line"><span class="comment">// ioctl TIOCSWINSZ 命令也可将此结构的新值存放到内核中。如果此新值和存放在内核中的当前值不同,则向前台进程组发送 SIGWINCH 信号.</span></span><br><span class="line"><span class="comment">// ioctl(STDIN_FILENO,TIOCGWINSZ,&amp;wz);</span></span><br></pre></td></tr></table></figure>

<p>3、创建新进程</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">pid_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">throw_runtime_exception</span>(env, <span class="string">&quot;Fork failed&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 当前进程</span></span><br><span class="line">    *pProcessId = (<span class="type">int</span>) pid;</span><br><span class="line">    <span class="keyword">return</span> ptm;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Clear signals which the Android java process may have blocked:</span></span><br><span class="line">    <span class="type">sigset_t</span> signals_to_unblock;</span><br><span class="line">    <span class="built_in">sigfillset</span>(&amp;signals_to_unblock); <span class="comment">// 初始化 signals_to_unblock,然后将所有的信号加入此信号集.</span></span><br><span class="line">    <span class="built_in">sigprocmask</span>(SIG_UNBLOCK, &amp;signals_to_unblock, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// SIG_BLOCK: 将参数二中的信号添加到信号屏蔽字中</span></span><br><span class="line">    <span class="comment">// SIG_SETMASK: 将信号屏蔽字设置为参数二中信号</span></span><br><span class="line">    <span class="comment">// SIG_UNBLOCK: 从信号屏蔽字中删除参数二中的信号.</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(ptm);</span><br><span class="line">    <span class="built_in">setsid</span>();</span><br><span class="line">    <span class="comment">// 子进程从父进程继承了: SessionID, process GroupID 和打开的终端</span></span><br><span class="line">    <span class="comment">// setsid 帮助子进程脱离父进程继承的属性.</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pts = <span class="built_in">open</span>(devname, O_RDWR); <span class="comment">// 打开伪终端 slave 设备.</span></span><br><span class="line">    <span class="keyword">if</span> (pts &lt; <span class="number">0</span>) <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dup2</span>(pts, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dup2</span>(pts, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">dup2</span>(pts, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 一般一个进程会有3个文件描述符存在(0,1,2)0 -&gt; 进程的标准输入,1 -&gt; 进程的标准输出,2 -&gt; 进程的标准错误输出.</span></span><br><span class="line">    <span class="comment">// int dup(int oldfd); </span></span><br><span class="line">    <span class="comment">// 内核在进程创建一个新的文件描述符,此描述符是当前可用文件描述符的最小数值,指向 oldfd 所拥有的文件表项.</span></span><br><span class="line">    <span class="comment">// int dup2(int oldfd,int newfd); </span></span><br><span class="line">    <span class="comment">// 使用newfd 指定新描述符的数值,如果 newfd 已经打开,先将其关闭.如果 newfd 等于 oldfd,则返回 newfd,不关闭它.</span></span><br><span class="line"></span><br><span class="line">    DIR* self_dir = <span class="built_in">opendir</span>(<span class="string">&quot;/proc/self/fd&quot;</span>); <span class="comment">// 当前进程打开的文件</span></span><br><span class="line">    <span class="keyword">if</span> (self_dir != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="type">int</span> self_dir_fd = <span class="built_in">dirfd</span>(self_dir); <span class="comment">// 把 DIR* 转为文件描述符</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">dirent</span>* entry;</span><br><span class="line">        <span class="keyword">while</span> ((entry = <span class="built_in">readdir</span>(self_dir)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="type">int</span> fd = <span class="built_in">atoi</span>(entry-&gt;d_name);</span><br><span class="line">            <span class="keyword">if</span>(fd &gt; <span class="number">2</span> &amp;&amp; fd != self_dir_fd) <span class="built_in">close</span>(fd); <span class="comment">// 关闭打开的文件</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">closedir</span>(self_dir);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">clearenv</span>(); <span class="comment">// 删除环境表中所有的环境变量</span></span><br><span class="line">    <span class="comment">// getenv() 按环境变量的名称取得环境变量的值</span></span><br><span class="line">    <span class="keyword">if</span> (envp) <span class="keyword">for</span> (; *envp; ++envp) <span class="built_in">putenv</span>(*envp); <span class="comment">// 将传进来的环境变量设为当前环境变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">chdir</span>(cwd) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span>* error_message;</span><br><span class="line">        <span class="comment">// No need to free asprintf()-allocated memory since doing execvp() or exit() below.</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">asprintf</span>(&amp;error_message, <span class="string">&quot;chdir(\&quot;%s\&quot;)&quot;</span>, cwd) == <span class="number">-1</span>) error_message = <span class="string">&quot;chdir()&quot;</span>;</span><br><span class="line">        <span class="built_in">perror</span>(error_message);</span><br><span class="line">        <span class="built_in">fflush</span>(stderr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从 PATH 环境变量所值的目录中查找符合参数 cmd 的文件名,找到后便执行该文件,然后将第二个参数 argv 传给此文件.</span></span><br><span class="line">    <span class="comment">// 成功无返回，失败返回 -1,失败原因存于 errno 中.</span></span><br><span class="line">    <span class="built_in">execvp</span>(cmd, argv);</span><br><span class="line">    <span class="comment">// Show terminal output about failing exec() call:</span></span><br><span class="line">    <span class="type">char</span>* error_message;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">asprintf</span>(&amp;error_message, <span class="string">&quot;exec(\&quot;%s\&quot;)&quot;</span>, cmd) == <span class="number">-1</span>) error_message = <span class="string">&quot;exec()&quot;</span>;</span><br><span class="line">    <span class="built_in">perror</span>(error_message);</span><br><span class="line">    _exit(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为 termux 的主界面是一个 psuedo terminal,所以第一步先建立伪终端设备,然后创建当前进程的子进程去执行命令.因此,termux 能访问的就只能 termux app 私有文件目录及 SD 卡公开目录(需要特殊命令支持)</p>
]]></content>
  </entry>
  <entry>
    <title>Podman</title>
    <url>/2019/08/13/10/</url>
    <content><![CDATA[<p>Podman 是什么? Podman 是一个非守护线程的容器引擎,支持在 Linux 系统上开发、管理和运行 OCI 容器.容器同时支持 root 身份和非 root 身份.只需要使用 <code>alias docker=podman</code> 就可以立即从 docker 切换到 podman.</p>
<span id="more"></span>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul>
<li>Arch Linux &amp; Manjaro Linux<br><code>sudo pacman -S podman</code></li>
<li>Fedora,CentOS<br><code>sudo yum -y install podman</code></li>
<li>Fedora-CoreOS,Fedora SilverBlue<br>内置无需安装</li>
<li>Gentoo<br><code>sudo emerge app-emulation/libpod</code></li>
<li>MacOS<br><code>brew cask install podman</code></li>
<li>openSUSE<br><code>sudo zypper install podman</code></li>
<li>openSUSE Kubic<br>内置无需安装</li>
<li>RHEL7<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo subcription-manager repos --enable=rhel-7-server-extras-rpms</span><br><span class="line">sudo yum -y install podman</span><br></pre></td></tr></table></figure></li>
<li>RHEL8 Beta<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo yum module enable -y contianer-tools:1.0</span><br><span class="line">sudo yum module install-y container-tools:1.0</span><br></pre></td></tr></table></figure></li>
<li>Ubuntu<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get update -qq</span><br><span class="line">sudo apt-get install -qq -y software-properties-common uidmap</span><br><span class="line">sudo add-apt-repository -y ppa:projectatomic/ppa</span><br><span class="line">sudo apt-get update -qq</span><br><span class="line">sudo apt-get -qq -y install podman</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>Podman 由 libpod 库提供的一个工具.可以用来创建维护容器.下面的指南将带你如何设置 Podman 并实现一些基本命令.</p>
<h3 id="运行示例容器"><a href="#运行示例容器" class="headerlink" title="运行示例容器"></a>运行示例容器</h3><figure class="highlight plaintext"><figcaption><span>run -dt -p 8080:8080/tcp -e HTTPD_VAR_RUN</span></figcaption><table><tr><td class="code"><pre><span class="line">-e HTTPD_MAIN_CONF_PATH=/etc/httpd/conf \</span><br><span class="line">-e HTTPD_CONTAINER_SCRIPTS_PATH=/usr/share/container-scripts/httpd/ \</span><br><span class="line">registry.fedoraproject.org/f27/httpd /usr/bin/run-httpd</span><br></pre></td></tr></table></figure>
<p>上面的容器将开启一个基本的 http server.由于此容器是以 detached 模式运行,由 podman run 命令 -d flag 表示,所以 Podman 在启动运行后仅输出容器 ID.然后就可以访问该 http server了.</p>
<h3 id="列出正在运行的容器"><a href="#列出正在运行的容器" class="headerlink" title="列出正在运行的容器"></a>列出正在运行的容器</h3><p><code>podman ps</code><br><code>podman ps -a</code> 列出所有的容器</p>
]]></content>
      <tags>
        <tag>container</tag>
      </tags>
  </entry>
  <entry>
    <title>每个JS开发者都应该知道的 Unicode</title>
    <url>/2024/08/05/25/</url>
    <content><![CDATA[<blockquote><p>What every JavaScript developer should know about Unicode</p>
<footer><strong>原文</strong><cite><a href="https://dmitripavlutin.com/what-every-javascript-developer-should-know-about-unicode/">dmitripavlutin.com/what-every-javascript-developer-should-know-about-unicode</a></cite></footer></blockquote>
<p>本文起源于一个忏悔：我对 Unicode 已经恐惧很久了。当实际工作中需要 Unicode 知识时，我一般仅针对问题搜索答案，而不会对其原理进行深入探究。</p>
<span id="more"></span>

<p>我一直在回避这件事，直到我遇到了一个需要深入理解 Unicode 原理的问题。此刻没有现成的解决方案可用了。</p>
<p>在付出大量努力（阅读一大堆文章）后，我才发现，其实 Unicode 也没那么难懂。好吧。。。有些文章确实需要至少3遍之后才能理解。</p>
<p>如果你在理解 Unicode 方面也有同样的困惑，那么此刻正是时候！真的不难！首先准备好可口的🍵或者咖啡。接下来，就一起进入抽象、字符、astrals和代理的世界吧。</p>
<p>本文将阐述 Unicode 的基本原理及其创建的必要性。然后介绍 JavaScript 如何使用 Unicode, 以及开发中可能遇到的问题。同时也会学习如何使用最新的 ECMAScript 2015 特性解决一部分难题。</p>
<p>准备好了吗？</p>
<p>[toc]</p>
<h2 id="1、Unicode-缘起"><a href="#1、Unicode-缘起" class="headerlink" title="1、Unicode 缘起"></a>1、Unicode 缘起</h2><p>我们先从一个简单的问题开始。你是如何阅读理解本文的？原因很简单，因为你知道每个字母的意思和由一组字母组成的单词的意思。</p>
<p>那么你为什么能理解这些字母呢？原因也很简单，因为你（读者）和我（作者）在英语字符（意思）和图形符号（显示在屏幕上的符号）之间的联系达成了共识。</p>
<p>计算机也是同样的道理。不同之处在于计算机是不理解字母的意思的。对于计算机而言，字母就是一列二进制位。</p>
<p>想象一下, 用户1通过网络向用户2发送了一条 <code>hello</code> 的消息。</p>
<p>用户1的计算机是不知道这些字母的含义。所以它把 <code>hello</code> 转换为数字序列<code>0x68 0x65 0x6C 0x6F</code>,此处每个字母都对应一个数字: <code>h</code> 对应 <code>0x68</code>，<code>e</code> 对应 <code>0x65</code>等。这些数字最终会被传送给用户2的电脑。</p>
<p>用户2的电脑收到这堆数字序列，然后它使用相同的数字字母对照将数字转换为字母信息。最终显示出正确的消息: <code>hello</code>。</p>
<p>两台电脑间关于数字与字符之间达成的对照协议就是 Unicode 标准化的内容。</p>
<p>从 Unicode 的角度来看，<code>h</code> 是名为 <code>H</code> 的小写拉丁抽象字符。此字符的对应数字为 <code>0x68</code>，也就是经常用 <code>U+0068</code> 来表示的码点。</p>
<p>Unicode 存在的意义就是提供一系列的抽象字符（字符集）且为每个字符分配一个独一无二的码点（编码字符集）。</p>
<h2 id="2、Unicode-基本术语"><a href="#2、Unicode-基本术语" class="headerlink" title="2、Unicode 基本术语"></a>2、Unicode 基本术语</h2><p><code>www.unicode.org</code> 网站提到:</p>
<blockquote>
<p><code>Unicode</code> 为每个字符提供了一个独一无二的数字，无论是在哪个平台上，无论是何种程序，无论使用何种语言，这个数字都是独一无二的。</p>
</blockquote>
<p>Unicode 是一个通用字符集，覆盖了市面上大部分可用的文字写作系统，为每一个字符都赋予了一个独一无二的数字（码点）。<br><a href="https://dmitripavlutin.com/3e07eef08e75e952b9b3fee7fd3ac454/unicode-logo.svg"></a></p>
<p>Unicode 包含了包括今天常见的语言、标点符号、音标、数学符号、技术符号、箭头、表情等等在内的字符。</p>
<p>Unicode 1.0 发布于 1991 年十月，拥有 7161 个字符。发布于 2021 年九月的 14.0 版支持 144697 个字符。</p>
<p>Unicode 的普适性及开放性解决了之前因为大量不同字符集和编码集之间带来的问题。</p>
<p>之前创建一个支持所有字符集和编码集的应用是很复杂的。</p>
<blockquote>
<p>如果你觉得 Unicode 很难，那么不使用 Unicode 编程则是难上加难</p>
</blockquote>
<p>我现在都记得选择任意字符集和编码集读取文件问题就像买彩票一样，全凭运气。</p>
<h3 id="2-1-字符集和码点"><a href="#2-1-字符集和码点" class="headerlink" title="2.1 字符集和码点"></a>2.1 字符集和码点</h3><blockquote>
<p><strong>抽象字符</strong>(或者字符)是用于组织、控制或表示文本数据的信息单元</p>
</blockquote>
<p>Unicode 把字符作为一个抽象术语来处理的。每一个抽象字符都有对应的名称，如 <code>LATIN SMALL LETTER A</code>, 此字符的呈现形式(字形)是 <code>a</code>.</p>
<blockquote>
<p><strong>码点</strong>是分配给单个字符的数字.</p>
</blockquote>
<p>码点是介于 <code>U+0000</code> - <code>U+10FFFF</code> 之间的数字.</p>
<p><code>U+&lt;hex&gt;</code> 是码点的格式，<code>U+</code> 作为前缀，意为<strong>U</strong>nicode；<code>&lt;hex&gt;</code>是十六进制表示的数字。例如 <code>U+0041</code> 和 <code>U+2603</code> 都是码点。</p>
<p>总之记住一点，码点就是一个简单的数字。也是一个数组里面元素的索引。</p>
<p>神奇之处在于 Unicode 把码点和字符关联了起来。比如 <code>U+0041</code> 对应名为 <code>LATIN CAPITAL LETTER A</code> 的字符(即 <code>A</code>), 而 <code>U+2603</code> 对应名为 <code>SNOWMAN</code> 的字符(即 <code>☃</code>)。</p>
<p><strong>不是所有的码点都有对应的字符.</strong> <code>1,114,112</code>是合规的码点(在 <code>U+0000</code> - <code>U+10FFFF</code>之间), 但只有 <code>144,697</code>(即 2021 年九月)有对应的字符.</p>
<h3 id="2-2-Unicode-位面-planes"><a href="#2-2-Unicode-位面-planes" class="headerlink" title="2.2 Unicode 位面(planes)"></a>2.2 Unicode 位面(planes)</h3><blockquote>
<p><strong>Plane</strong>是从 <code>U+n0000</code> - <code>U+nFFFF</code>，范围 65536（或 1000016） 的连续 Unicode 码点，其中 <code>n</code> 取值范围为 0 - 16.</p>
</blockquote>
<p>整个 Unicode 码点被分为 17 个位面.</p>
<ul>
<li><code>Plane 0</code> 包括 <code>U+0000</code> - <code>U+FFFF</code> 之间的码点</li>
<li><code>Plane 1</code> 包括 <code>U+1000</code> - <code>U+1FFF</code> 之间的码点</li>
<li>……</li>
<li><code>Plane 16</code> 包括 <code>U+100000</code> - <code>U+10FFFF</code> 之间的码点</li>
</ul>
<p><a href="https://dmitripavlutin.com/static/a0793621ff979b9a80b9a6b0a600e663/bca77/unicode-planes.png"></a></p>
<h4 id="基础多语言位面"><a href="#基础多语言位面" class="headerlink" title="基础多语言位面"></a>基础多语言位面</h4><p>Plane 0 是最特殊的一个，被称为<strong>基础多语言位面</strong>或者简称<strong>BMP</strong>。它包含了当前大多数的现代语言（如基本拉丁语、斯拉夫语、希腊语等等）和大量的符号。</p>
<p>如上所述，BMP 的码点范围在 <code>U+0000</code> - <code>U+FFFF</code> 之间，最多可以有4位十六进制数字。</p>
<p>开发者经常需要和 BMP 中的字符打交道。</p>
<p>比如以下 BMP 中的字符:</p>
<ul>
<li>e 是码点为 U+0065 的 <code>LATIN SMALL LETTER E</code> 字符</li>
<li>| 是码点为 U+007C 的 <code>VERTICAL BAR</code> 字符</li>
<li>■ 是码点为 U+25A0 的 <code>BLACK SQUARE</code> 字符</li>
<li>☂ 是码点为 U+2602 的 <code>UMBRELLA</code> 字符</li>
</ul>
<h4 id="星型位面"><a href="#星型位面" class="headerlink" title="星型位面"></a>星型位面</h4><p>BMP 之外的其他 16 个位面被称为<strong>星型位面</strong>或<strong>增补位面</strong></p>
<p>星型位面里的码点也被称为<strong>星型码点</strong>，这些码点的范围在 <code>U+10000</code> - <code>U+10FFFF</code> 之间</p>
<p>一个星型码点可以有 5 位或 6 位16进制数字，如: <code>U+ddddd</code> 或 <code>U+dddddd</code></p>
<p>以下是星型位面中的字符:</p>
<ul>
<li>𝄞 是码点为 U+1D11E 的 <code>MUSICAL SYMBOL G CLEF</code> 字符</li>
<li>𝐁 是码点为 U+1D401 的 <code>MATHEMATICAL BOLD CAPITAL B</code> 字符</li>
<li>🀵 是码点为 U+1F035 的 <code>DOMINO TITLE HORIZONTAL-00-04</code> 字符</li>
<li>😀 是码点为 U+1F600 的 <code>GRINNING FACE</code> 字符</li>
</ul>
<h4 id="码元"><a href="#码元" class="headerlink" title="码元"></a>码元</h4><p>到现在为止，Unicode 字符，码点，位面都是抽象概念。</p>
<p>接下来看看在物理层面，硬件上是如何实现 Unicode 的。</p>
<p>计算机在内存中是不使用码点或抽象字符的。它需要一种物理方式来展示 Unicode 码点：码元。</p>
<blockquote>
<p><strong>码元</strong>是一个位序列，用于在给定编码表单中对每个字符进行编码</p>
</blockquote>
<p>字符编码就是如何将抽象的码点转为物理位的方式即码元。换言之，字符编码把码点转换为独一无为的代码单元序列。</p>
<p>比较流行的编码是 <code>UTF-8</code>,<code>UTF-16</code>和<code>UTF-32</code></p>
<p>大多数 JS 引擎使用 <code>UTF-16</code> 编码，那么我们就来研究下 <code>UTF-16</code>.</p>
<p>UTF-16（全名：16 位 Unicode 转换格式）是一种变长编码：</p>
<ul>
<li>来自 BMP 的码点使用一个16位的码元编码</li>
<li>来自星型位面的码点使用两个16位的码元分别编码</li>
</ul>
<p>这就是全部的理论干货。以下是示例：</p>
<p>假设你需要把 <code> LATIN SMALL LETTER A</code> 字符 <code>a</code> 保存到硬盘里。Unicode 会告诉你它对应的码点是 <code>U+0061</code></p>
<p>接下来，我们需要询问 UTF-16， <code>U+0061</code> 怎么转换。编码规范明确指出来自 BMP 的码点只取它的 16 进制数字 <code>U+0061</code>, 然后保存到一个 16 位码元中: <code>0x0061</code>.</p>
<p>如上可见，BMP 中的码点刚好适合一个16位码元。</p>
<h4 id="代理对"><a href="#代理对" class="headerlink" title="代理对"></a>代理对</h4><p>现在我们来研究一个比较复杂的案例. 假设你需要编码 <code>GRINNING FACE</code> 字符 😀。从星型位面得到它的码点 <code>U+1F600</code>.</p>
<p>因为星型码点需要 21 位（因为最大的 0x10FFFF 转为2进制是 21 位）才能保存信息,那么 UTF-16 表示你需要两个 16 位的码元。码点 <code>U+1F600</code> 被分成了代理对：<code>0xD83D</code> (高代理码元)和 <code>0xDE00</code>（低代理码元）。</p>
<blockquote>
<p><strong>代理对</strong>用两个16位码元组成的码元序列来表示一个抽象字符。代理对的第一个值被称为<strong>高代理码元</strong>，第二个值被称为<strong>低代理码元</strong></p>
</blockquote>
<p>一个星型码点需要2个码元-即代理对。比如把 <code>U+1F600</code>（<code>😀</code>）编码为 UTF-16，它的代理对即为 <code>0xD83D 0xDE00</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;\uD83D\uDE00&#x27;</span>); <span class="comment">// =&gt; &#x27;😀&#x27;</span></span><br></pre></td></tr></table></figure>

<p>高代理码元取值范围为 <code>0xD800</code> - <code>0xDBFF</code>. 低代理码元取值范围为 <code>0xDC00</code> - <code>0xDFFF</code></p>
<p>星型码点和代理对之间的转换算法如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getSurrogatePair</span>(<span class="params">astralCodePoint</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> highSurrogate = </span><br><span class="line">     <span class="title class_">Math</span>.<span class="title function_">floor</span>((astralCodePoint - <span class="number">0x10000</span>) / <span class="number">0x400</span>) + <span class="number">0xD800</span>;</span><br><span class="line">  <span class="keyword">let</span> lowSurrogate = (astralCodePoint - <span class="number">0x10000</span>) % <span class="number">0x400</span> + <span class="number">0xDC00</span>;</span><br><span class="line">  <span class="keyword">return</span> [highSurrogate, lowSurrogate];</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">getSurrogatePair</span>(<span class="number">0x1F600</span>); <span class="comment">// =&gt; [0xD83D, 0xDE00]</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getAstralCodePoint</span>(<span class="params">highSurrogate, lowSurrogate</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (highSurrogate - <span class="number">0xD800</span>) * <span class="number">0x400</span> </span><br><span class="line">      + lowSurrogate - <span class="number">0xDC00</span> + <span class="number">0x10000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">getAstralCodePoint</span>(<span class="number">0xD83D</span>, <span class="number">0xDE00</span>); <span class="comment">// =&gt; 0x1F600</span></span><br></pre></td></tr></table></figure>

<p>代理对使用起来不太方便。当在 JS 中使用字符串时，就需要特殊处理。</p>
<p>尽管如此，UTF-16的内存是很高效。常用的字符中，99% 都来自 BMP，也就是需要一个码元，所以比较节省内存空间。</p>
<h4 id="2-5-组合标记"><a href="#2-5-组合标记" class="headerlink" title="2.5 组合标记"></a>2.5 组合标记</h4><blockquote>
<p>字素或符号是在特定书写系统上下文中最小独特的书写单位。</p>
</blockquote>
<p>字素是用户如何理解字符的方式。屏幕上实际展示的字符被称为字形。</p>
<p>大多数情况下，一个单独的 Unicode 字符即展示为一个字素。如 <code>U+0066</code> 即展示为英文 <code>f</code>.</p>
<p>当然也包含一个字素包括一系列字符的情况。</p>
<p>如 <code>å</code> 就是丹麦语书写系统中的一个单独字素。它是由 <code>LATIN SMALL LETTER A</code> <code>U+0061</code> (渲染为 <code>a</code>) 和 <code>COMBINING RING ABOVE</code> <code>U+030A</code>(渲染为 <code>◌̊</code>) 的特殊字符组合而成的。‘</p>
<p><code>U+030A</code> 修改了前面字符的展示，所以被称为组合标记。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;\u0061\u030A&#x27;</span>); <span class="comment">// =&gt; &#x27;å&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;\u0061&#x27;</span>);       <span class="comment">// =&gt; &#x27;a&#x27;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>组合标记</strong>是一个应用到前置字符上，生成新字素的一个字符。</p>
</blockquote>
<p>组合标记包括重音符号、变音符号、希伯来语点、阿拉伯语元音符号和印度语 matras 等字符。</p>
<p>组合标记通常不单独使用。应该避免单独使用他们。</p>
<p>和代理对一样，组合标记在 JS 中也是比较难用的。</p>
<p>组合标记字符序列（基本字符+组合标记）一般被用户识别为单独的符号（如 <code>\u0061\u031A</code> 就是 <code>å</code>）.但是开发者就得考虑把2个码点 <code>U+0061</code>和 <code>U+030A</code> 才能组合成 <code>å</code></p>
<p><a href="https://dmitripavlutin.com/static/16d7bd44cac07b727121315ae7db1ab6/03f31/unicode-terms.webp"></a></p>
<h3 id="JavaScript-中的-Unicode"><a href="#JavaScript-中的-Unicode" class="headerlink" title="JavaScript 中的 Unicode"></a>JavaScript 中的 Unicode</h3><p>ES2015 语言规范提到：源码是使用 Unicode(5.1 及之后的版本) 表示的。源码文本就是一系列范围在 <code>U+0000</code> - <code>U+10FFFF</code> 之间的码点。而源码文本存储或彼此交换的方式没有在 ECMAScript 规范中说明，通常是使用 UTF-8 来编码的（web 领域最通用的编码格式）</p>
<p>而我推荐把源码文本以 <code>Basic Latin Unicode block</code> (或 ASCII) 格式进行保存。ASCII 范围之外的字符应该被转义。这样就能避免一些编码方面出现的问题。</p>
<p>在语言层面，ECMAScript 中明确定义了 JavaScript 中的字符串。</p>
<blockquote>
<p>String 类型是所有有序序列的集合，这些序列包含零个或多个 16 位无符号整数值（”元素”），最大长度为 253-1 个元素。String 类型通常用于表示正在运行的 ECMAScript 程序中的文本数据，在这种情况下，String 中的每个元素都被视为 UTF-16 代码单元值。</p>
</blockquote>
<p>string 的每个元素都被引擎解析为一个码元。字符串渲染时没有强制要求使用哪个码元来展示。比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;cafe\u0301&#x27;</span>); <span class="comment">// =&gt; &#x27;café&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;café&#x27;</span>);       <span class="comment">// =&gt; &#x27;café&#x27;</span></span><br></pre></td></tr></table></figure>

<p><code>cafe\u0301</code> 和 <code>café</code> 字面上看来码元是不同的，但是都被渲染为 <code>café</code> 符号.</p>
<blockquote>
<p><strong>字符串长度</strong>就是其内元素（如16位值）的个数。ECMAScript 把字符串的每个元素都解析为单个的 UTF-16 码元</p>
</blockquote>
<p>从上面的代理对和组合标记可知，某些符号需要2个或更多的码元来展示。所以当使用索引访问字符或者计算字符个数时就需要特别小心了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> smile = <span class="string">&#x27;\uD83D\uDE00&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(smile);        <span class="comment">// =&gt; &#x27;😀&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(smile.<span class="property">length</span>); <span class="comment">// =&gt; 2</span></span><br><span class="line"><span class="keyword">const</span> letter = <span class="string">&#x27;e\u0301&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(letter);        <span class="comment">// =&gt; &#x27;é&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(letter.<span class="property">length</span>); <span class="comment">// =&gt; 2</span></span><br></pre></td></tr></table></figure>

<p><code>smile</code> 字符串包含2个码元：<code>\uD83D</code>（高代理）和 <code>\uDE00</code>（低代理）。因为字符串是码元序列，所以 <code>smile.length</code> 就是2.即使 <code>smile</code>渲染出来只有一个符号 <code>😀</code></p>
<p><code>letter</code> 字符串也是同样的道理。组合标记 <code>U+0301</code> 会应用到前面的字符，然后只渲染一个符号 <code>é</code>. 因为 <code>letter</code> 包含2个码元，所以 <code>letter.length</code> 就是2.</p>
<p>我的建议：<strong>总是把 JavaScript 中的字符串看作一系列码元</strong>，这样屏幕上渲染出来的字符串就不能明确说出包含了哪些码元。</p>
<p>星型符号和组合标记需要2个或更多的码元来编码，但是一般是把他们作为一个单独的字素来处理的。如果一个字符串有代理对或者组合标记，如果不遵循这些规则，那么在计算字符串长度或通过索引访问字符时就会出现这样或那样的困惑。</p>
<p>大多数的 JavaScript 字符串方法都是非 Unicode 敏感的方法。如果你的字符串包含了 Unicode 字符，当使用 <code>myString.slice()</code> 或 <code>myString.substring()</code> 等方法时就需要谨慎了。</p>
<h4 id="3-1-转义序列"><a href="#3-1-转义序列" class="headerlink" title="3.1 转义序列"></a>3.1 转义序列</h4><p>字符串中的转义序列是用来表示基于码点数字的码元的。JavaScript 中有 3 中转义类型，其中一个就是 ECMAScript 中提出的。</p>
<p><b>16进制转义序列</b></p>
<p><strong>16进制转义序列</strong>简称为: <code>\x&lt;hex&gt;</code>, 前缀 <code>\x</code> 后面跟着2个固定长度的16进制数字。如 <code>\x30</code>(符号 <code>0</code>) 或者 <code>\x5B</code> (符号 <code>[</code>)</p>
<p>字符串中的16进制转义序列或者正则表达式看起来是这样的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;\x4A\x61vaScript&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str);                    <span class="comment">// =&gt; &#x27;JavaScript&#x27;</span></span><br><span class="line"><span class="keyword">const</span> reg = <span class="regexp">/\x4A\x61va.*/</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reg.<span class="title function_">test</span>(<span class="string">&#x27;JavaScript&#x27;</span>)); <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure>
<p>16进制转义序列可以转义有限范围内的码点：<code>U+00</code> - <code>U+FF</code> 因为它只允许有2个数字。但是16进制转义是很好用的，因为它表示起来比较短，节省空间。</p>
<p><b>Unicode 转义序列</b></p>
<p>如果你想转义整个 BMP 中的码点，那么就使用<strong>Unicode 转义序列</strong> 吧。转义格式为 <code>\u&lt;hex&gt;</code>, 前缀<code>\u</code> 后面跟着4个固定长度的16进制数字。如 <code>\u0051</code>（符号 <code>Q</code>） 或 <code>\u222B</code> (符号 <code>∫</code>)</p>
<p>下面是一些 unicode 转义序列示例:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;I\u0020learn \u0055nicode&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str);                 <span class="comment">// =&gt; &#x27;I learn Unicode&#x27;</span></span><br><span class="line"><span class="keyword">const</span> reg = <span class="regexp">/\u0055ni.*/</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reg.<span class="title function_">test</span>(<span class="string">&#x27;Unicode&#x27;</span>)); <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure>

<p>Unicode 转义序列可以转义有限范围内的码点：<code>U+0000</code> - <code>U+FFFF</code> (包括所有的 BMP 码点，因为4位数字的局限)。这已经足够应付大多数情况了。</p>
<p>为了阐述 JavaScript 如何表示星型符号，你需要把 unicode 转义序列合并起显示（高代理和低代理）创建一个代理对</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;My face \uD83D\uDE00&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str); <span class="comment">// =&gt; &#x27;My face 😀&#x27;</span></span><br></pre></td></tr></table></figure>

<p><code>\uD83D\uDE00</code> 就是用2个转义序列创建的代理对。</p>
<p><strong>码点转义序列</strong></p>
<p>ECMAScript 2015 提供了整个 Unicode 空间的码点转义序列: <code>U+00000</code> - <code>U+10FFFF</code>， 如 BMP 和星型位面。</p>
<p><code>\u&lt;hex&gt;</code> 被称为<strong>码点转义序列</strong>, <code>&lt;hex&gt;</code> 是长度在 1-6 之间的可变16进制数字。</p>
<p>例如 <code>\u&#123;7A&#125;</code> (符号 <code>z</code>) 或者 <code>\u&#123;1F639&#125;</code> （符号 <code>😹</code>）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;Funny cat \u&#123;1F639&#125;&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str);                      <span class="comment">// =&gt; &#x27;Funny cat 😹&#x27;</span></span><br><span class="line"><span class="keyword">const</span> reg = <span class="regexp">/\u&#123;1F639&#125;/u</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reg.<span class="title function_">test</span>(<span class="string">&#x27;Funny cat 😹&#x27;</span>)); <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure>

<p>正则表达式 <code>\u&#123;1F639&#125;/u</code> 有一个特殊的标识 <code>u</code>，它可以开启 Unicode 特性(如下<a href="https://dmitripavlutin.com/what-every-javascript-developer-should-know-about-unicode/#35regularexpressionmatch">正则表达式所述</a>)</p>
<p>我同意码点转义可以避免代理对展示星型符号的弊端。例如使用码点转义 名为 <code>SMILING FACE WITH HALO</code> 的码点 <code>U+1F607</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> niceEmoticon = <span class="string">&#x27;\u&#123;1F607&#125;&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(niceEmoticon);   <span class="comment">// =&gt; &#x27;😇&#x27;</span></span><br><span class="line"><span class="keyword">const</span> spNiceEmoticon = <span class="string">&#x27;\uD83D\uDE07&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(spNiceEmoticon); <span class="comment">// =&gt; &#x27;😇&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(niceEmoticon === spNiceEmoticon); <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure>

<p>变量 <code>niceEmoticon</code> 代表的字面值的码点转义 <code>\u&#123;1F607&#125;</code> 表示的就是一个星型码点 <code>U+1F607</code></p>
<p>实际上，码点转义在底层会创建一个代理对（2个码元）。<code>spNiceEmoticon</code> （使用 unicode 转义 <code>\uD83D\uDE07</code> 表示的代理对）等同于 &#96;niceEmotion</p>
<p><a href="https://dmitripavlutin.com/static/6b44fa7c2642601d0bf68ddf688e808d/fb018/unicode-escape-sequence.webp"></a></p>
<p>使用字符串创建 <code>RegExp</code> 正则表达式时，必须使用 <code>\\</code> 来代替 <code>\</code>  表示转义字符。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> reg1 = <span class="regexp">/\x4A \u0020 \u&#123;1F639&#125;/</span>;</span><br><span class="line"><span class="keyword">const</span> reg2 = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&#x27;\\x4A \\u0020 \\u&#123;1F639&#125;&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reg1.<span class="property">source</span> === reg2.<span class="property">source</span>); <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure>

<h4 id="3-2-字符串比较"><a href="#3-2-字符串比较" class="headerlink" title="3.2 字符串比较"></a>3.2 字符串比较</h4><p>JavaScript 中的字符串都是码元序列。在比较字符串时，应该预料到，彼此字符串之间的码元数先相等。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> firstStr = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> secondStr = <span class="string">&#x27;\u0068ell\u006F&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(firstStr === secondStr); <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure>

<p><code>firstStr</code> 和 <code>secondStr</code> 的码元是相等的，所以他们俩相等。</p>
<p>但是当你比较两个渲染结果看起来相等，但是码元不一致的字符串时，结果就可能不一样了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str1 = <span class="string">&#x27;ça va bien&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> str2 = <span class="string">&#x27;c\u0327a va bien&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str1);          <span class="comment">// =&gt; &#x27;ça va bien&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str2);          <span class="comment">// =&gt; &#x27;ça va bien&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str1 === str2); <span class="comment">// =&gt; false</span></span><br></pre></td></tr></table></figure>

<p><code>str1</code> 和 <code>str2</code> 的渲染结果看起来是一样的，但是拥有不同的码元。这是因为字素 <code>ç</code> 有两种构成方式：</p>
<ul>
<li>使用 <code>U+00E7</code> <code>LATIN SMALL LETTER C WITH CEDILLA</code> 构成</li>
<li>使用 <code>U+0063</code> <code>LATIN SMALL LETTER C</code> 加上组合标记 <code>U+0327</code> <code>COMBINING CEDILLA</code> 构成.</li>
</ul>
<p>如何处理这种情况下的字符串比较？答案是字符串标准化。</p>
<p><strong>标准化</strong></p>
<blockquote>
<p><strong>规范化</strong>是字符串转换为规范表示形式，以确保规范等效（和&#x2F;或兼容性等效）字符串具有唯一的表示形式。</p>
</blockquote>
<p>换言之，如果一个字符串有复杂的构造结构：如组合字符串序列或其他混合结构，那么<i>标准化</i>成规范格式就可以。标准化字符串可以无缝的比较或者实现文本搜索等操作。</p>
<p><a href="http://unicode.org/reports/tr15/">Unicode Standard Annex #15</a> 有关于标准化处理的详细描述。</p>
<p>在 ECMAScript 2015 Javascipt 中字符串的标准化处理通过 <code>myString.normalize([normForm])</code> 来实现。<code>normForm</code> 是可选的参数(默认 <code>NFC</code>), 接受以下几个选项</p>
<ul>
<li><code>NFC</code>: Normalization Form Canonical Composition</li>
<li><code>NFD</code>: Normalization Form Canonical Decomposition</li>
<li><code>NFKC</code>: Normalization Form Compatibility Composition</li>
<li><code>NFKD</code>: Normalization Form Compatibility Decomposition</li>
</ul>
<p>下面让我们通过标准化字符串来实现字符串的比较</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str1 = <span class="string">&#x27;ça va bien&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> str2 = <span class="string">&#x27;c\u0327a va bien&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str1.<span class="title function_">normalize</span>() === str2.<span class="title function_">normalize</span>()); <span class="comment">// =&gt; true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str1 === str2);                         <span class="comment">// =&gt; false</span></span><br></pre></td></tr></table></figure>

<p>当 <code>str2.normalize()</code> 被调用时，返回的是 <code>str2</code> 的规范化版本(<code>c\u0327</code> 被替换为 <code>ç</code>), 所以 <code>str1.normalize() === str2.normalize()</code>就符合预期了。</p>
<p><code>str1</code> 不受 <code>normalize</code> 的影响，因为它本身就是规范化的表现形式。</p>
<h4 id="3-3-字符串长度"><a href="#3-3-字符串长度" class="headerlink" title="3.3 字符串长度"></a>3.3 字符串长度</h4><p>通常使用 <code>myString.length</code> 来获取字符串的长度。此属性表明字符串所包含的码元的个数。</p>
<p>如果字符串是来自 BMP 中的码点，那么实际获取的字符串长度和预期是符合的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> color = <span class="string">&#x27;Green&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(color.<span class="property">length</span>); <span class="comment">// =&gt; 5</span></span><br></pre></td></tr></table></figure>
<p><code>color</code> 中的每个码元都对应一个单独的字素。所以预期字符串长度是5.</p>
<p><strong>长度和代理对</strong></p>
<p>如果字符串包含了代理对，那么当展示星型码点时问题就变得棘手起来了。因为每个代理对包含2个码元（高位代理和低位代理），所以字符串的长度就比预期长。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;cat\u&#123;1F639&#125;&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str);        <span class="comment">// =&gt; &#x27;cat😹&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="property">length</span>); <span class="comment">// =&gt; 5</span></span><br></pre></td></tr></table></figure>
<p>当 <code>str</code> 字符串渲染时，它其实是包含了4个符号的 <code>cat😹</code>。然而 <code>smile.length</code> 等于5，因为 <code>U+1F639</code> 由2个码元编码的星型码元（一个代理对）。</p>
<p>遗憾的事，目前没有本地可用的高效修复方案。</p>
<p>不过至少 ECMAScript 2015 引入了能够识别星型符号的算法。星型符号即使被2个码元编码，也是算作一个字符。</p>
<p>Unicode 敏感的方法是字符串迭代器 <code>String.prototype[@@iterator]()</code>.可以通过组合扩散操作符<code>[...str]</code> 或 <code>Array.from(str)</code> 函数（都会消费字符串迭代器）来创建字符串。然后计算数组返回的符号数量。</p>
<p>实际按照上面的方案操作时则会有轻微的性能损失。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;cat\u&#123;1F639&#125;&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str);             <span class="comment">// =&gt; &#x27;cat😹&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([...str]);        <span class="comment">// =&gt; [&#x27;c&#x27;, &#x27;a&#x27;, &#x27;t&#x27;, &#x27;😹&#x27;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([...str].<span class="property">length</span>); <span class="comment">// =&gt; 4</span></span><br></pre></td></tr></table></figure>
<p><code>[...str]</code> 创建了包含4个符号的数组。代理对编码 <code>CAT FACE WITH TEARS OF JOY 😹</code> <code>U+1F639</code> 时会保证其完整，因为字符串迭代器是 Unicode 敏感的。</p>
<p><strong>长度和组合标记</strong></p>
<p>那组合字符串序列时会怎样呢？因为每个组合标记都是一个码元，此时也会遇到相同的问题。</p>
<p>标准化字符串就可以解决这个问题。如果幸运的话，组合字符序列就会以单字符对待。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> drink = <span class="string">&#x27;cafe\u0301&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(drink);                    <span class="comment">// =&gt; &#x27;café&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(drink.<span class="property">length</span>);             <span class="comment">// =&gt; 5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(drink.<span class="title function_">normalize</span>())         <span class="comment">// =&gt; &#x27;café&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(drink.<span class="title function_">normalize</span>().<span class="property">length</span>); <span class="comment">// =&gt; 4</span></span><br></pre></td></tr></table></figure>

<p><code>drink</code> 字符串包含了5个码元（所以 <code>drink.length</code> 就是5），即使它渲染出来是4个符号。</p>
<p>当标准化 <code>drink</code> 时，组合字符序列<code>e\u0301</code>只有一个规范化格式 <code>é</code>.所以 <code>drink.normalize().length</code> 就是包含4个符号。</p>
<p>不幸的是，标准化不是万能钥匙。长组合字符序列不总是只有一个规划化符号</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> drink = <span class="string">&#x27;cafe\u0327\u0301&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(drink);                    <span class="comment">// =&gt; &#x27;cafȩ́&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(drink.<span class="property">length</span>);             <span class="comment">// =&gt; 6</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(drink.<span class="title function_">normalize</span>());        <span class="comment">// =&gt; &#x27;cafȩ́&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(drink.<span class="title function_">normalize</span>().<span class="property">length</span>); <span class="comment">// =&gt; 5</span></span><br></pre></td></tr></table></figure>

<p><code>drink</code> 有6个码元，所以<code>drink.length</code> 等于6.然而 <code>drink</code> 有4个符号。</p>
<p><code>drink.normalize()</code> 会把组合序列 <code>e\u0327\u0301</code> 转换为包含2个字符 <code>ȩ\u0301</code> 的规范化格式（只一处一个组合标记）。</p>
<p>然而 <code>drink.normalize().length</code> 等于5，依然和显示的符号数不相符。</p>
<h4 id="3-4-字符位置"><a href="#3-4-字符位置" class="headerlink" title="3.4 字符位置"></a>3.4 字符位置</h4><p>因为字符串是一个码元序列，使用索引访问字符串同样会出现问题。</p>
<p>当字符串仅包含 BMP 字符时，通过索引访问字符串就是正确的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str[<span class="number">0</span>]); <span class="comment">// =&gt; &#x27;h&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str[<span class="number">4</span>]); <span class="comment">// =&gt; &#x27;o&#x27;</span></span><br></pre></td></tr></table></figure>

<p>每个符号都被编码为一个单独的码元，所以索引访问就是正确的。</p>
<p><strong>字符位置和代理对</strong></p>
<p>当字符串包含星型符号时情况就不一样了。</p>
<p>一个星型符号用2个码元编码（一个代理对）。所以通过索引访问字符串的字符时可能获取到的就是一个单独的高代理或者低代理，这就是无效的符号。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">onst omega = <span class="string">&#x27;\u&#123;1D6C0&#125; is omega&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(omega);        <span class="comment">// =&gt; &#x27;𝛀 is omega&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(omega[<span class="number">0</span>]);     <span class="comment">// =&gt; &#x27;&#x27; (unprintable symbol)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(omega[<span class="number">1</span>]);     <span class="comment">// =&gt; &#x27;&#x27; (unprintable symbol)</span></span><br></pre></td></tr></table></figure>

<p>因为 <code>MATHEMATICAL BOLD CAPITAL OMEGA </code> <code>U+1D6C0</code> 是一个星型字符，它是用2个码元的一个代理对编码的。</p>
<p><code>omega[0]</code> 访问高位代理码元，<code>omega[1]</code> 访问低位代理码元，这就会打破代理对。</p>
<p>有两种方式可以正确的访问字符串的星型符号。</p>
<ul>
<li>使用 Unicode 敏感的字符串迭代器，生成符号数组 <code>[...str][index]</code></li>
<li>使用 <code>number = myString.codePointAt(index)</code> 获取码点数字，然后使用 <code>String.fromCodePoint(number)</code> 将数字转换为符号(推荐)</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> omega = <span class="string">&#x27;\u&#123;1D6C0&#125; is omega&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(omega);                        <span class="comment">// =&gt; &#x27;𝛀 is omega&#x27;</span></span><br><span class="line"><span class="comment">// 方法1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([...omega][<span class="number">0</span>]);                <span class="comment">// =&gt; &#x27;𝛀&#x27;</span></span><br><span class="line"><span class="comment">// 方法2</span></span><br><span class="line"><span class="keyword">const</span> number = omega.<span class="title function_">codePointAt</span>(<span class="number">0</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(number.<span class="title function_">toString</span>(<span class="number">16</span>));          <span class="comment">// =&gt; &#x27;1d6c0&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>.<span class="title function_">fromCodePoint</span>(number)); <span class="comment">// =&gt; &#x27;𝛀&#x27;</span></span><br></pre></td></tr></table></figure>

<p><code>[...omega]</code> 返回 <code>omega</code> 字符串包含的符号数组。代理对计算是正确的，所以访问的第一个字符 <code>[...smile][0]</code> 就是<code>𝛀</code></p>
<p><code>omega.codePointAt(0)</code> 方法调用是 Unicode 敏感的，所以它返回的 <code>omega</code> 字符串的第一个字符的星型码点数字 <code>0x1D6C0</code>。而 <code>String.fromCodePoint(number)</code> 则根据码点返回对应的符号 <code>𝛀</code></p>
<p><strong>字符串位置和组合标记</strong></p>
<p>使用索引访问包含组合标记的字符串也会出现上述问题。</p>
<p>通过索引访问字符串返回的是码元。但是组合标记序列应该被作为整体读取，不能被拆分成单独的码元。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> drink = <span class="string">&#x27;cafe\u0301&#x27;</span>;  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(drink);        <span class="comment">// =&gt; &#x27;café&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(drink.<span class="property">length</span>); <span class="comment">// =&gt; 5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(drink[<span class="number">3</span>]);     <span class="comment">// =&gt; &#x27;e&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(drink[<span class="number">4</span>]);     <span class="comment">// =&gt; ◌́</span></span><br></pre></td></tr></table></figure>

<p><code>drink[3]</code> 只能访问基础字符 <code>e</code>, 不包括 <code>COMBINING ACUTE ACCENT</code> <code>U+0301</code> 组合标记(<code>◌́</code>). 而 <code>drink[4]</code> 返回的则是单独的组合标记 <code>◌́</code></p>
<p>这种情况下试试字符串标准化。组合字符序列 <code>U+0065</code> <code>LATIN SMALL LETTER E</code> + <code>U+0301</code> <code>COMBINING ACUTE ACCENT</code> 的规范化格式就是 <code>U+00E9</code> <code>LATIN SMALL LETTER E WITH ACUTE é</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> drink = <span class="string">&#x27;cafe\u0301&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(drink.<span class="title function_">normalize</span>());        <span class="comment">// =&gt; &#x27;café&#x27;  </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(drink.<span class="title function_">normalize</span>().<span class="property">length</span>); <span class="comment">// =&gt; 4  </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(drink.<span class="title function_">normalize</span>()[<span class="number">3</span>]);     <span class="comment">// =&gt; &#x27;é&#x27;</span></span><br></pre></td></tr></table></figure>
<p>不幸的是，不是所有的组合字符序列都只有一个单独符号的规范化格式。所以标准化方案不是通用的。</p>
<p>幸运的是，在大多数欧洲&#x2F;北美语言中，这种方法是可行的。</p>
<h4 id="3-5-正则表达式匹配"><a href="#3-5-正则表达式匹配" class="headerlink" title="3.5 正则表达式匹配"></a>3.5 正则表达式匹配</h4><p>正则表达式和字符串一样，也是按码元区分的。和上述场景类似，当使用正则表达式处理代理对和组合字符序列时也有同样的问题。</p>
<p>BMP 字符匹配是正常的，因为它只需要一个码元就能表示一个字符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> greetings = <span class="string">&#x27;Hi!&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> regex = <span class="regexp">/^.&#123;3&#125;$/</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(regex.<span class="title function_">test</span>(greetings)); <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure>
<p><code>greetings</code> 有3个符号，被编码成3个码元。正则表达式 <code>/.&#123;3&#125;/</code> 预期匹配3个码元，刚好能匹配上 <code>grettings</code></p>
<p>当匹配星型符号（被2个码元组合的代理对编码）时，问题就出来了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> smile = <span class="string">&#x27;😀&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> regex = <span class="regexp">/^.$/</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(regex.<span class="title function_">test</span>(smile)); <span class="comment">// =&gt; false</span></span><br></pre></td></tr></table></figure>
<p><code>smile</code> 包含了 <code>U+1F600 GRINNING FACE</code> 星型符号。<code>U+1F600</code> 用代理对 <code>0xD83D</code> + <code>0xDE00</code> 编码。而正则表达式 <code>/^.$/</code> 预期一个码元，所以匹配失败。</p>
<p>当使用星型符号定义正则表达式时，JS 甚至会抛出错误。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> regex = <span class="regexp">/[😀-😎]/</span>;</span><br><span class="line"><span class="comment">// =&gt; SyntaxError: Invalid regular expression: /[😀-😎]/: </span></span><br><span class="line"><span class="comment">// Range out of order in character class</span></span><br></pre></td></tr></table></figure>
<p>星型码点被编码为代理对。所以 js 使用码元 <code>/[\uD83D\uDE00-\uD83D\uDE0E]</code> 来表示正则表达式。每个码元都被认为是 pattern 中的一个单独元素，所以正则表达式会忽略代理对概念。</p>
<p>正则表达式 <code>\uDE00-\uD83D</code> 是无效的，因为 <code>uDE00</code> 大于 <code>\uD83D</code>, 所以会生成错误。</p>
<p><strong>正则表达式 u 标识</strong></p>
<p>幸运的是，ECMAScript 2015 引入了一个有用的 <code>u</code> 标识，表明正则表达式是 Unicode 敏感的。这个标识可以保证能正确的处理星型符号。</p>
<p>可以在正则表达式 <code>/u&#123;1F600&#125;/u</code> 中使用 unicode 转义序列。此转义方式比高低代理对 <code>/\uD83D\uDE00/</code> 占用空间要小。</p>
<p>接下来看看应用 <code>u</code> 标识时，<code>.</code> 操作符（包括大量的 <code>?+* 和 &#123;3&#125; &#123;3,&#125; &#123;2,3&#125;</code>）来匹配星型符号</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> smile = <span class="string">&#x27;😀&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> regex = <span class="regexp">/^.$/u</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(regex.<span class="title function_">test</span>(smile)); <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure>
<p><code>/^.$/u</code> 因为添加了 <code>u</code> Unicode 敏感标识，所以可以匹配😊星型符号。</p>
<p>在正则表达式构造时，添加 <code>u</code> 标识就可以正确处理了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> smile = <span class="string">&#x27;😀&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> regex = <span class="regexp">/[😀-😎]/u</span>;</span><br><span class="line"><span class="keyword">const</span> regexEscape = <span class="regexp">/[\u&#123;1F600&#125;-\u&#123;1F60E&#125;]/u</span>;</span><br><span class="line"><span class="keyword">const</span> regexSpEscape = <span class="regexp">/[\uD83D\uDE00-\uD83D\uDE0E]/u</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(regex.<span class="title function_">test</span>(smile));         <span class="comment">// =&gt; true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(regexEscape.<span class="title function_">test</span>(smile));   <span class="comment">// =&gt; true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(regexSpEscape.<span class="title function_">test</span>(smile)); <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure>

<p><strong>正则表达式和组合标记</strong></p>
<p>不过无论有没有 <code>u</code> 标识，正则表达式都把组合标记看作一个单独的码元</p>
<p>如果需要匹配组合字符序列，那么必须得单独匹配基础字和和字符标记</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> drink = <span class="string">&#x27;cafe\u0301&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> regex1 = <span class="regexp">/^.&#123;4&#125;$/</span>;</span><br><span class="line"><span class="keyword">const</span> regex2 = <span class="regexp">/^.&#123;5&#125;$/</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(drink);              <span class="comment">// =&gt; &#x27;café&#x27;  </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(regex1.<span class="title function_">test</span>(drink)); <span class="comment">// =&gt; false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(regex2.<span class="title function_">test</span>(drink)); <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure>
<p>字符串最终渲染出来4个符号<code>café</code>，而正则表达式只有 <code>/^.&#123;5&#125;$/</code> 才能正确匹配出 <code>cafe\u0301</code> 字符序列</p>
<h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h3><p>JS 中关于 Unicode 最重要的知识点应该是把字符串看作码元序列。</p>
<p>只有当开发者把字符串以字符或符号来看待时才会出现问题，忽略掉了码元序列这个概念。</p>
<p>当字符串包含代理对或组合字符序列时，以下场景就会出现困惑</p>
<ul>
<li>获取字符串长度</li>
<li>字符串索引访问</li>
<li>正则表达式匹配</li>
</ul>
<p>注意：大多数 js 字符串方法是非 Unicode 敏感的：比如 <code>myString.indexOf()</code>, <code>myString.slice()</code> 等</p>
<p>ECMAScript 2015 引入了一个和字符串、正则表达式中的码点转义序列<code>\u&#123;1F600&#125;</code>类似的非常好的特性，即正则表达式 <code>u</code> 标识，可以对字符串开启 Unicode 敏感模式。匹配星型符号时就比较容易了。</p>
<p>字符串迭代器<code>String.prototype[@@iterator]()</code> 就是 Unicode 敏感的。可以使用扩展操作符 <code>[...str]</code> 或 <code>Array.from(str)</code> 来创建符号数组，计算字符串长度，不需要打断代理对通过访问索引字符。注意，这些操作对性能有影响。</p>
<p>如果需要更好的 Unicode 字符处理方案，可以试试 <a href="https://github.com/bestiejs/punycode.js/">punycode</a> 或者<a href="https://github.com/mathiasbynens/regenerate">生成</a> 特殊正则表达式。</p>
<p>希望这篇文章能帮助你彻底掌握 Unicode.</p>
]]></content>
      <tags>
        <tag>翻译,JS,Unicode</tag>
      </tags>
  </entry>
  <entry>
    <title>android 交叉编译</title>
    <url>/2022/03/03/01/</url>
    <content><![CDATA[<p>当前 native 项目大多是 cmake 或 autotool 配置编译，以下就分别以 libgit2 和 openssl 来说明如何进行 NDK 交叉编译</p>
<span id="more"></span>

<h3 id="openssl"><a href="#openssl" class="headerlink" title="openssl"></a>openssl</h3><p>openssl 使用 autotool 配置，如 NOTES-ANDROID.md 所述先进行环境配置</p>
<p>1、<code>.zshrc</code></p>
<p>因为 NDK 从 r20 后不再携带 gcc,所以需要使用 clang 编译 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export ANDROID_NDK_HOME=/Users/shuttle/Library/Android/sdk/ndk</span><br><span class="line">export ANDROID_NDK_ROOT=$ANDROID_NDK_HOME/24.0.7956693</span><br><span class="line">export PATH=$ANDROID_NDK_ROOT/toolchains/llvm/prebuilt/darwin-x86_64/bin:$PATH</span><br><span class="line">export CC=x86_64-linux-android32-clang</span><br></pre></td></tr></table></figure>
<p>2、执行 Configure</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./Configure android-x86_64  -D__ANDROID_API__=32</span><br></pre></td></tr></table></figure>
<p>3、编译</p>
<p><code>make -j6</code></p>
<p>同理，openssl 支持 <code>android-arm,android-arm64,android-mips,android-mip64,android-x86,android-x86_64</code>(其中 r20+后不再支持 mips 架构)</p>
<h3 id="libgit2"><a href="#libgit2" class="headerlink" title="libgit2"></a>libgit2</h3><p>1、添加 CMakeLists.android.tx 文件</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 交叉编译 Android</span></span><br><span class="line"><span class="keyword">SET</span>(CMAKE_SYSTEM_NAME Android)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置安卓的 api level, 如未设置，按一下顺序取值</span></span><br><span class="line"><span class="comment"># - CMAKE_ANDROID_API 即 android api level</span></span><br><span class="line"><span class="comment"># - CMAKE_SYSROOT</span></span><br><span class="line"><span class="comment"># - lastes api level 都没设置则取 ndk 最新的 api level</span></span><br><span class="line"><span class="comment"># SET(CMAKE_SYSTEM_VERSION 32)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置编译架构：arm64-v8a,armeabi-v7a,armeabi-v6,armeabi,mips,mips64,x86,x86_64 默认 armeabi</span></span><br><span class="line"><span class="keyword">SET</span>(CMAKE_ANDROID_ARCH_ABI arm64-v8a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ndk 绝对路径</span></span><br><span class="line"><span class="keyword">SET</span>(CMAKE_ANDROID_NDK /Users/shuttle/Library/Android/sdk/ndk/<span class="number">24.0</span>.<span class="number">7956693</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># true -&gt; 使用 api level 已经废弃的 header, 而不使用统一头文件。默认 false</span></span><br><span class="line"><span class="comment"># SET(CMAKE_ANDROID_NDK_DEPRECATED_HEADERS false)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 ndk 编译链版本。默认最新的</span></span><br><span class="line"><span class="comment"># SET(CMAKE_ANDROID_NDK_TOOLCHAIN_VERSION 32)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># none: No C++ Support</span></span><br><span class="line"><span class="comment"># system: Minimal C+++ without STL</span></span><br><span class="line"><span class="comment"># gabi++_static: GAbi++ Static</span></span><br><span class="line"><span class="comment"># gabi++_shared: GAbi++ Shared</span></span><br><span class="line"><span class="comment"># gnustl_static: GNU libstd++ Static</span></span><br><span class="line"><span class="comment"># gnustl_shared: GNU libstd++ Shared</span></span><br><span class="line"><span class="comment"># c++_shared: LLVM libc++ Shared</span></span><br><span class="line"><span class="comment"># c++_static: LLVM libc++ Static</span></span><br><span class="line"><span class="comment"># stlport_static: STLport Static</span></span><br><span class="line"><span class="comment"># stlport_shared: STLport Shared</span></span><br><span class="line"><span class="comment"># 默认 gnustl_static</span></span><br><span class="line"><span class="comment"># SET(CMAKE_ANDROID_STL_TYPE none)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SET(CMAKE_&lt;LANG&gt;_ANDROID_TOOLCHAIN_PREFIX ) # 自动生成，绝对路径前缀</span></span><br><span class="line"><span class="comment"># SET(CMAKE_&lt;LANG&gt;_ANDROID_TOOLCHAIN_SUFFIX ) # 自动生成，绝对路径后缀</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SET(CMAKE_C_COMPILER $&#123;NDK_HOME&#125;/toolchains/llvm/prebuilt/darwin-x86_64/bin/aarch64-linux-android32-clang)</span></span><br><span class="line"><span class="comment"># SET(CMAKE_CXX_COMPILER $&#123;NDK_HOME&#125;/toolchains/llvm/prebuilt/darwin-x86_64/bin/aarch64-linux-android32-clang++)</span></span><br><span class="line"><span class="comment"># SET(CMAKE_FIND_ROOT_PATH $&#123;NDK_HOME&#125;/toolchains/llvm/prebuilt/darwin-x86_64/sysroot)</span></span><br><span class="line"><span class="comment"># SET(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)</span></span><br><span class="line"><span class="comment"># SET(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)</span></span><br><span class="line"><span class="comment"># SET(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span>(NDK_HOME /Users/shuttle/Library/Android/sdk/ndk/<span class="number">24.0</span>.<span class="number">7956693</span>)</span><br><span class="line"><span class="keyword">SET</span>(OPENSSL_DYHOME /Users/shuttle/<span class="keyword">Project</span>/Native/libgit2/deps/openssl)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span>(OPENSSL_ROOT_DIR <span class="variable">$&#123;OPENSSL_DYHOME&#125;</span>)</span><br><span class="line"><span class="keyword">SET</span>(OPENSSL_INCLUDE_DIR <span class="variable">$&#123;OPENSSL_DYHOME&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="comment"># Could NOT find OpenSSL, try to set the path to OpenSSL root folder in the system variable OPENSSL_ROOT_DIR (missing: OPENSSL_CRYPTO_LIBRARY) </span></span><br><span class="line"><span class="keyword">SET</span>(OPENSSL_CRYPTO_LIBRARY <span class="variable">$&#123;OPENSSL_DYHOME&#125;</span>/android_arm64/libcrypto.so)</span><br><span class="line"><span class="keyword">SET</span>(OPENSSL_SSL_LIBRARY <span class="variable">$&#123;OPENSSL_DYHOME&#125;</span>/android_arm64/libssl.so)</span><br><span class="line"><span class="keyword">SET</span>(OPENSSL_LIBRARIES <span class="variable">$&#123;OPENSSL_DYHOME&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_definitions</span>(<span class="string">&quot;--sysroot=$&#123;CMAKE_FIND_ROOT_PATH&#125; -Wall -g&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span>(USE_SHA1 OpenSSL)</span><br><span class="line"><span class="keyword">SET</span>(USE_HTTPS OpenSSL)</span><br><span class="line"><span class="keyword">SET</span>(BUILD_TESTS <span class="keyword">OFF</span>)</span><br><span class="line"><span class="keyword">SET</span>(CMAKE_GENERATOR Ninja)</span><br></pre></td></tr></table></figure>

<p>2、cmake 配置</p>
<p><code>cmake -S. -Bbuild_arm64 -GNinja -DCMAKE_TOOLCHAIN_FILE=CMakeLists.android.txt</code></p>
<p>3、编译 </p>
<p><code>cmake --build build_arm64</code></p>
]]></content>
  </entry>
  <entry>
    <title>dart-build tool</title>
    <url>/2019/12/20/32/</url>
    <content><![CDATA[<p>build-tool</p>
<span id="more"></span>

<h3 id="使用-build-runner-作为开发服务"><a href="#使用-build-runner-作为开发服务" class="headerlink" title="使用 build_runner 作为开发服务"></a>使用 <code>build_runner</code> 作为开发服务</h3><p>1、在 <code>pubspec.yaml</code>中添加<code>build_runner</code>和<code>build_web_compilers</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">environment:</span></span><br><span class="line">  <span class="attr">sdk:</span> <span class="string">&#x27;&gt;=2.0.0 &lt;3.0.0&#x27;</span></span><br><span class="line"><span class="attr">dev_dependencies:</span></span><br><span class="line">  <span class="attr">build_runner:</span> <span class="string">^1.0.0</span></span><br><span class="line">  <span class="attr">build_web_compilers:</span> <span class="string">^0.4.0</span></span><br></pre></td></tr></table></figure>
<p>2、下载依赖</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pub get</span><br></pre></td></tr></table></figure>
<p>3、启动服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pub run build_runner serve</span><br></pre></td></tr></table></figure>
<p>服务启动后,每次保存操作都会触发重新构建.</p>
<h3 id="创建输出文件夹"><a href="#创建输出文件夹" class="headerlink" title="创建输出文件夹"></a>创建输出文件夹</h3><p>使用<code>--output &lt;directory name&gt;</code>选项构建,将内部引用 URL 匹配的文件路径和<code>directory name</code>合并作为输出目录,将文件写入.<br>此选项可以在<code>build,watch,serve</code>命令中使用.如果没有使用 <code>serve</code>命令时,此目录同时被另一个不同的 server 使用.<br>如果只想输出包的一部分,比如<code>web</code>目录,可以使用<code>--output web:&lt;directory name&gt;</code>.</p>
<h3 id="使用其他-build-runner-命令"><a href="#使用其他-build-runner-命令" class="headerlink" title="使用其他 build_runner 命令"></a>使用其他 <code>build_runner</code> 命令</h3><ul>
<li><code>build</code>: 执行单独构建然后退出.如果你的构建会把产物输出到源码文件中会很有用.使用<code>--output &lt;dirname&gt;</code> 可以将所有的源和生成的产物输出到合并目录中.</li>
<li><code>watch</code>: 类似 <code>build</code>,但是在文件改变时返回.使用<code>--output &lt;dirname&gt;</code>将数据的改变保存到合并的目录中.可以保持输出持续更新和其他基于文件的开发服务器配合使用.</li>
<li><code>test</code>: 创建输出目录然后运行<code>pub run test</code>.此命令需要 <code>dev dependency</code>中有<code>build_test</code>依赖.</li>
</ul>
<h3 id="切换到-dart2js"><a href="#切换到-dart2js" class="headerlink" title="切换到 dart2js"></a>切换到 dart2js</h3><p>默认情况下 <code>build_web_compilers</code>使用<code>dartdevc</code>.如果需要切换到 dart2js,在 <code>pub run build_runner build/serve</code>后传递<code>--release</code>选项.在<code>build.yaml</code>文件中配置.</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">targets:</span></span><br><span class="line">  <span class="string">$default:</span></span><br><span class="line">    <span class="attr">builders:</span></span><br><span class="line">      <span class="string">build_web_compilers|entrypoint:</span></span><br><span class="line">        <span class="attr">optioins:</span></span><br><span class="line">          <span class="attr">dart2js_args:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">--minify</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">--fast_startup</span></span><br></pre></td></tr></table></figure>

<h2 id="build-yaml-格式"><a href="#build-yaml-格式" class="headerlink" title="build.yaml 格式"></a><code>build.yaml</code> 格式</h2><p><code>build.yaml</code> 文件按照 <code>BuildConfig</code>对象配置.</p>
<h3 id="BuildConfig"><a href="#BuildConfig" class="headerlink" title="BuildConfig"></a>BuildConfig</h3><table>
<thead>
<tr>
<th>key</th>
<th>value</th>
<th>default</th>
</tr>
</thead>
<tbody><tr>
<td><code>targets</code></td>
<td><code>Map&lt;String,BuildTarget&gt;</code></td>
<td>a single target with the same name as the package</td>
</tr>
</tbody></table>
]]></content>
  </entry>
  <entry>
    <title>dart-flutter engine</title>
    <url>/2019/12/20/11/</url>
    <content><![CDATA[<h1 id="Flutter-engine"><a href="#Flutter-engine" class="headerlink" title="Flutter engine"></a>Flutter engine</h1><p>Flutter Engine 不创建或管理线程,相应的由 embedder 创建管理、message loops.</p>
<p>embedder 提供了 task runner 来执行任务.</p>
<p>Dart VM 会有自己的线程池.而 Flutter engine 和 embedder 都无法访问到线程池的线程.</p>
<span id="more"></span>

<h3 id="Task-Runner-Configuration"><a href="#Task-Runner-Configuration" class="headerlink" title="Task Runner Configuration"></a>Task Runner Configuration</h3><p>Flutter engine 会向 embedder 申请4个 task runner 引用. engine 不在乎引用是不是同一个 task runner,或者多个 task runner 运行在同一个线程中.<br>为了优化性能, embedder 应该为每个 task runner 分配一个单独的线程.虽然 engine 不关心 task runner 运行的线程情况,但是在 engine 的整个生命周期中线程配置应该保持一致.也就是如果 embedder 为task runner 分配了一个单独的线程,那么直到 engine 销毁,这个 task runner 都只能在这个线程运行.<br>常用的 task runners:</p>
<ul>
<li>Platform Task Runner</li>
<li>UI Task Runner</li>
<li>GPU Task Runner</li>
<li>IO Task Runner</li>
</ul>
<h3 id="Platform-Task-Runner"><a href="#Platform-Task-Runner" class="headerlink" title="Platform Task Runner"></a>Platform Task Runner</h3><p>此 task runner 运行的线程被 embedder 认为是主线程.</p>
<p>此线程执行的 task runner 都是由 embedder 分配的.engine 指派的 task runner 是无意义的.多个 Flutter engine 可以在基于不同线程上运行的 platform task runner 启动.Flutter Content Handler 在 Fuchsia 中就是此原理.每个 Flutter 应用所在的进程会创建一个新的 Flutter engine,同时每个 engine 都会创建一个新的 platform thread.</p>
<p>和 Flutter engine 的任何交互操作必须在 platform thread 中执行.而在其他线程中和 engine 交互, debug 构建中触发断言,release 构建中是非线程安全的.Flutter engine 中的很多组件都是非线程安全的.一旦 engine 配置运行后,只要 embedder API 的访问是在 platform thread 中执行的,embedder 就不必指派 task runner 去配置 engine.</p>
<p>此 task runner 除了在 engine 启动后负责 embedder 和 engine 交互外,同时会执行 platform messages.这是因为只有在 platform 的主线程访问 platform APIs 才是安全的.插件不必将他们的调用重新分配到主线程上.如果插件管理自己的 worker 线程,那么插件在响应结果被提交到 engine 由 Dart 处理前应该将其入队到 platform 线程中.和 engine 的交互必须在 platform 线程执行.</p>
<p>即使 platform 线程被阻塞了很长时间,Flutter rendering pipeline也不会被阻塞.platform 对此线程上的耗时操作进行了诸多限制.所以建议任何耗时操作在将执行结果返回并被入队到 platform 线程之前应该在独立的线程中执行(不是上面讨论的4种线程).如果不这么做可能导致 platform 指定的 watchdog 终结应用.诸如 android、ios 也使用 platform 线程传递用户输入时间.阻塞 platform 线程将导致操作被丢弃.</p>
<h3 id="UI-Task-Runner"><a href="#UI-Task-Runner" class="headerlink" title="UI Task Runner"></a>UI Task Runner</h3><p>engine 在 root isolate 通过 UI Task Runner 执行所有的 Dart 代码.root isolate 和 Flutter 绑定才能执行.此 isolate 运行应用程序的 main dart code.engine 绑定此 isolate 提交执行 frames. Flutter 的每一帧:</p>
<ul>
<li>root isolate 告诉 engine 要渲染哪一帧</li>
<li>engine 会询问 platform 在下一次 vsync 时是否需要 be notified.</li>
<li>platform 等待下一 vsync.</li>
<li>在 vsync, engine 会唤醒 dart code执行如下操作:<ul>
<li>更新动画插值器</li>
<li>在 build phase 重建应用的 widget.</li>
<li>布局新构建的 widget,将其绘制到层里的 tree 中立即提交给 engine.此处实际没有栅格化.</li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>docker,docker-compose学习笔记</title>
    <url>/2019/03/01/57/</url>
    <content><![CDATA[<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>Compose 是一个为了定义和运行多容器 Docker 应用的工具。<br><a href="https://github.com/docker/labs">官方动手示例</a></p>
<span id="more"></span>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul>
<li>一个主机多个隔离环境</li>
<li>当容器创建时保留所有的 volume</li>
<li>只有容器被更改时才触发创建</li>
<li>定义变量和在不同环境中使用</li>
</ul>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>自动测试环境</li>
<li>单独主机部署</li>
</ul>
<h3 id="docker-compose-安装"><a href="#docker-compose-安装" class="headerlink" title="docker-compose 安装"></a>docker-compose 安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.23.2/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</span><br><span class="line">sudo chmod +x /usr/local/bin/docker-compose</span><br><span class="line">sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose</span><br><span class="line">sudo docker-compose --version</span><br></pre></td></tr></table></figure>

<p>pip 安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install docker-compose</span><br></pre></td></tr></table></figure>

<p>卸载</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo rm /usr/local/bin/docker-compose</span><br><span class="line">pip uninstall docker-compose</span><br></pre></td></tr></table></figure>

<h3 id="docker-compose-命令"><a href="#docker-compose-命令" class="headerlink" title="docker-compose 命令"></a>docker-compose 命令</h3><ul>
<li><code>-f</code> 指定 一个或多个 compose 文件的名称和路径<blockquote>
<p>1、使用多个 Compose 文件时，Compose 会把这几个文件合并为一个配置。按顺序合并，后边的覆盖前边的配置。<br>2、<code>docker-compose -f docker-compose.yml -f docker-compose.admin.yml run backup_db</code><br>3、使用 <code>-(dash)</code> 作为 <code>-f</code> 的值，将会从输入中读取配置文件名。使用 <code>stdin</code> 时，配置里涉及到的路径都是相对于当前工作上下文路径。<br>4、如果不是用 <code>-f</code>,Compose 遍历当前上下文路径和它的父路径查询 <code>docker-compose.yml</code> 和 <code>docker-compose.override.yml</code> 文件。请至少提供一个 <code>docker-compose.yml</code> 文件。如果所有的文件都在同一个文件夹下，Compose 将合并它们。<br>5、<code>docker-compose.override.yml</code> 的配置高于 <code>docker-compose.yml</code>,且为后者提供额外的配置属性。</p>
</blockquote>
</li>
<li>为单独的 Compose 文件指定路径<blockquote>
<p>1、使用 <code>-f</code>, 或从命令行输入，或在 shell &#x2F; 某个环境配置文件中设置 COMPOSE_FILE 环境变量,指定不在当前文件夹的 Compose 文件路径.<br>2、<code>docker-compose -f ~/sandbox/rails/docker-compose.yml pull db</code> 从 <code>~/sandbox/rails/docker-compose.yml</code> 文件中获取 db 服务中定义的 postgres db 镜像。</p>
</blockquote>
</li>
<li><code>-p</code> 指定项目名<blockquote>
<p>1、如果不指定 <code>-p</code>,Compose 默认使用当前文件夹的名称。</p>
</blockquote>
</li>
<li>配置环境变量</li>
</ul>
<h3 id="docker-compose-CLI-环境变量"><a href="#docker-compose-CLI-环境变量" class="headerlink" title="docker-compose CLI 环境变量"></a>docker-compose CLI 环境变量</h3><p>默认内置了几个环境变量可以配置 docker-compose.<br>以 <code>DOCKER_</code> 开头的变量和配置 docker 命令行客户端的变量类似。如果使用 <code>docker-machine</code>的话，<code>eval &quot;$(docker-machine env my-docker-vm)&quot;</code>将为变量设置正确的值。</p>
<ul>
<li><code>COMPOSE_PROJECT_NAME</code><blockquote>
<p>1、设置项目名.该值在启动时会作为容器服务的前缀.比如项目名 myapp,包含两个服务 db 和 web,那么 Compose 启动的容器名为 myapp_db_1 和 myapp_web_1.<br>2、默认时项目文件夹的根目录名。</p>
</blockquote>
</li>
<li><code>COMPOSE_FILE</code><blockquote>
<p>1、指定 Compose 文件路径。如果未指定，Compose 将在当前文件夹查询 docker-compose.yml 文件，如果不存在将继续遍历父目录直到找到。<br>2、支持使用文件路径分隔符(Linux &amp; MacOS [:] Windows [;]).比如 <code>COMPOSE_FILE=docker-compose.yml:docker-compose.prod.yml</code>,路径分隔符可以通过 <code>COMPOSE_PATH_SEPARATOR</code> 自定义</p>
</blockquote>
</li>
<li><code>COMPOSE_API_VERSION</code><blockquote>
<p>1、Docker API 仅支持来自指定版本客户端的请求。使用 docker-compose 时出现 <code>client and server don&#39;t have same version</code> 错误，那么可以通过设置该变量解决。<br>2、设置该变量主要针对临时的运行客户端和服务端版本不一致的情况。</p>
</blockquote>
</li>
<li><code>DOCKER_HOST</code><blockquote>
<p>1、为 docker daemon 设置 URL.和 docker 客户端一样，默认为 <code>unix:///var/run/docker.sock</code></p>
</blockquote>
</li>
<li><code>DOCKER_TLS_VERIFY</code><blockquote>
<p>1、设置空字符以外的任何值时，开启 TLS.</p>
</blockquote>
</li>
<li><code>DOCKER_CERT_PATH</code><blockquote>
<p>1、配置 <code>ca.pem,cert.pem,key.pem</code> 的路径。默认 <code>~/.docker</code></p>
</blockquote>
</li>
<li><code>COMPOSE_HTTP_TIMEOUT</code><blockquote>
<p>1、超时时间(秒).默认 60s</p>
</blockquote>
</li>
<li><code>COMPOSE_TLS_VERSION</code><blockquote>
<p>1、TLS 版本.默认 TLSv1. 可供选项 TLSv1, TLSv1_1, TLSv1_2</p>
</blockquote>
</li>
<li><code>COMPOSE_CONVERT_WINDOWS_PATH</code><blockquote>
<p>1、是否开启把 Windos-style 的路径转为 Unix-style 的卷定义。在 Windos 上使用 Docker Machine 和 Docker Toolbox 时总是要设置该变量。默认 0。 true&#x2F;1 代表开启，false&#x2F;0 代表关闭.</p>
</blockquote>
</li>
<li><code>COMPOSE_PATH_SEPARATOR</code><blockquote>
<p>1、如果设置，COMPOSE_FILE 值将使用此处的定义作为分隔符。</p>
</blockquote>
</li>
<li><code>COMPOSE_FORCE_WINDOWS_HOST</code><blockquote>
<p>1、如果设置，即使 Compose 运行在 Unix-based 系统上，卷定义也将使用简略语法解析为假设运行在 Windows 上的路径。true&#x2F;a,false&#x2F;0</p>
</blockquote>
</li>
<li><code>COMPOSE_IGNORE_ORPHANS</code><blockquote>
<p>1、如果设置，Compose 不会试着对项目的单独容器检测。true&#x2F;1,false&#x2F;0</p>
</blockquote>
</li>
<li><code>COMPOSE_PARALLEL_LIMIT</code><blockquote>
<p>1、并行执行的限制。默认 64，绝不能低于 2.</p>
</blockquote>
</li>
<li><code>COMPOSE_INTERACTIVE_NO_CLI</code><blockquote>
<p>1、如果设置，Compose 不会尝试使用 Docker CLI 和 run exec 操作交互。true&#x2F;1,false&#x2F;0</p>
</blockquote>
</li>
</ul>
<h3 id="Compose-file"><a href="#Compose-file" class="headerlink" title="Compose file"></a>Compose file</h3><h4 id="version-3"><a href="#version-3" class="headerlink" title="version 3"></a>version 3</h4><h5 id="build"><a href="#build" class="headerlink" title="build"></a>build</h5><p>配置选项在编译期生效。<br>build 可以指定一个路径</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">webapp:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">./dir</span></span><br></pre></td></tr></table></figure>

<p>或者是一个在指定 context 下的路径对象，同时可包含 Dockerfile 和 args</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">webapp:</span></span><br><span class="line">    <span class="attr">build:</span></span><br><span class="line">      <span class="attr">context:</span> <span class="string">./dir</span></span><br><span class="line">      <span class="attr">dockerfile:</span> <span class="string">Dockerfile-alternate</span></span><br><span class="line">      <span class="attr">args:</span></span><br><span class="line">        <span class="attr">buildno:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>如果同时也指定了 image,Compose 使用 webapp 和 image 中指定的可选的 tag 命名最终生成的镜像名</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">build:</span> <span class="string">./dir</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">webapp:tag</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>swarm mode 不支持。docker stack 命令只接受预编译的镜像.</p>
</blockquote>
<h6 id="CONTEXT"><a href="#CONTEXT" class="headerlink" title="CONTEXT"></a>CONTEXT</h6><p>可以是包含 Dockerfile 文件的路径，或 git 仓库的 url.<br>如果是相对路径，那么被解析为相对于当前 Compose 文件的路径。此文件夹同时也是发送到 Docker daemon 的编译上下文。</p>
<h6 id="DOCKERFILE"><a href="#DOCKERFILE" class="headerlink" title="DOCKERFILE"></a>DOCKERFILE</h6><p>可选<br>此处必须指定编译路径</p>
<h6 id="ARGS"><a href="#ARGS" class="headerlink" title="ARGS"></a>ARGS</h6><p>只有在编译过程中可访问的环境变量。<br>首先，在 Dokcerfile 中指定参数:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">ARG</span> <span class="string">buildno</span></span><br><span class="line"><span class="string">ARG</span> <span class="string">gitcommithash</span></span><br><span class="line"></span><br><span class="line"><span class="string">RUN</span> <span class="string">echo</span> <span class="string">&quot;Build number: $buildno&quot;</span></span><br><span class="line"><span class="string">RUN</span> <span class="string">echo</span> <span class="string">&quot;Bashed on commit: $gitcommithash&quot;</span></span><br></pre></td></tr></table></figure>

<p>然后在 build 下给该参数复制（可以是键值对列表）：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">build:</span></span><br><span class="line">  <span class="attr">context:</span> <span class="string">.</span></span><br><span class="line">  <span class="attr">args:</span></span><br><span class="line">    <span class="attr">buildno:</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">gitcommithash:</span> <span class="string">cdc3b19</span></span><br><span class="line"></span><br><span class="line"><span class="attr">build:</span></span><br><span class="line">  <span class="attr">context:</span> <span class="string">.</span></span><br><span class="line">  <span class="attr">args:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">buildno=1</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">gitcommithash=cdc3b19</span></span><br></pre></td></tr></table></figure>

<p>你也可以不指定值，它的值就是编译时 Compose 当前运行环境的值.</p>
<blockquote>
<p>YAML 布尔值(true,false,yes,no,on,off)应该使用引号应用，这样解析器才能把它们解析为 string</p>
</blockquote>
<h6 id="CACHE-FROM"><a href="#CACHE-FROM" class="headerlink" title="CACHE_FROM"></a>CACHE_FROM</h6><blockquote>
<p>v3.2+</p>
</blockquote>
<p>指定 engine 可以缓存的镜像列表</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">build:</span></span><br><span class="line">  <span class="attr">context:</span> <span class="string">.</span></span><br><span class="line">  <span class="attr">cache_from:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">alpine:latest</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">corp/webapp:3.14</span></span><br></pre></td></tr></table></figure>

<h6 id="LABELS"><a href="#LABELS" class="headerlink" title="LABELS"></a>LABELS</h6><blockquote>
<p>v3.3+</p>
</blockquote>
<p>向生成的镜像添加元数据。可以是数组或目录<br>推荐使用反向 DNS 标记以避免和其他软件冲突</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">build:</span></span><br><span class="line">  <span class="attr">context:</span> <span class="string">.</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">com.example.description:</span> <span class="string">&quot;Accounting webapp&quot;</span></span><br><span class="line">    <span class="attr">com.example.department:</span> <span class="string">&quot;Finance&quot;</span></span><br><span class="line">    <span class="attr">com.example.label-with-empty-value:</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">build:</span></span><br><span class="line">  <span class="attr">context:</span> <span class="string">.</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;com.example.description=Accounting webapp&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;com.example.department=Finance&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;com.example.label-with-empty-value&quot;</span></span><br></pre></td></tr></table></figure>

<h6 id="SHM-SIZE"><a href="#SHM-SIZE" class="headerlink" title="SHM_SIZE"></a>SHM_SIZE</h6><blockquote>
<p>v3.5+</p>
</blockquote>
<p>设置编译生成容器 <code>dev/shm&#39;</code> 分区大小。int 值单位为 byte. string 可以携带单位</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">build:</span></span><br><span class="line">  <span class="attr">context:</span> <span class="string">.</span></span><br><span class="line">  <span class="attr">shm_size:</span> <span class="string">&#x27;2gb&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">build:</span></span><br><span class="line">  <span class="attr">context:</span> <span class="string">.</span></span><br><span class="line">  <span class="attr">shm_size:</span> <span class="number">10000000</span></span><br></pre></td></tr></table></figure>

<h6 id="TARGET"><a href="#TARGET" class="headerlink" title="TARGET"></a>TARGET</h6><blockquote>
<p>v3.4+</p>
</blockquote>
<p>编译 Dockerfile 中定义的指定版本</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">build:</span></span><br><span class="line">  <span class="attr">context:</span> <span class="string">.</span></span><br><span class="line">  <span class="attr">target:</span> <span class="string">prod</span></span><br></pre></td></tr></table></figure>

<h5 id="cap-add-cap-drop"><a href="#cap-add-cap-drop" class="headerlink" title="cap_add,cap_drop"></a>cap_add,cap_drop</h5><p>添加或删除容器的容量。<code>man 7 capabilities</code> 查看可用列表</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">cap_add:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ALL</span></span><br><span class="line"><span class="attr">cap_drop:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">NET_ADMIN</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">SYS_ADMIN</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>swarm mode 无效</p>
</blockquote>
<h5 id="cgroup-parent"><a href="#cgroup-parent" class="headerlink" title="cgroup_parent"></a>cgroup_parent</h5><p>为容器指定可选的 cgroup parent</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">cgroup_parent:</span> <span class="string">m-executor-abcd</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>swarm mode 无效</p>
</blockquote>
<h5 id="command"><a href="#command" class="headerlink" title="command"></a>command</h5><p>覆盖默认的命令</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">command:</span> <span class="string">bundle</span> <span class="string">exec</span> <span class="string">thin</span> <span class="string">-p</span> <span class="number">3000</span></span><br></pre></td></tr></table></figure>

<p>也可以是列表</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">command:</span> [<span class="string">&quot;bundle&quot;</span>, <span class="string">&quot;exec&quot;</span>, <span class="string">&quot;thin&quot;</span>, <span class="string">&quot;-p&quot;</span>, <span class="string">&quot;3000&quot;</span>]</span><br></pre></td></tr></table></figure>

<h5 id="configs"><a href="#configs" class="headerlink" title="configs"></a>configs</h5><h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><ul>
<li>共享文件夹，卷，绑定挂载<blockquote>
<p>如果你的项目不在 <code>Users</code>目录(<code>cd ~</code>),那么你需要共享驱动器或 Dockerfile 所在位置和当前正在使用的卷。如果出现运行时错误表示文件未找到，那么就是一个挂载卷的请求被拒绝，或服务启动失败，试着共享文件或驱动。挂载卷要求共享项目不在 <code>C:\Users (Windows)</code>,或 <code>/Users (Mac)</code> 的驱动，并且如果是运行在 <code>Dokcer Desktop for Windows</code> 的 Linux 容器上的所有应用都需要共享。</p>
</blockquote>
</li>
<li>如果改变了一个服务的 Dockerfile 或者编译文件夹里的内容，运行 <code>docker-compose build</code>重新编译</li>
</ul>
<h3 id="官方示例"><a href="#官方示例" class="headerlink" title="官方示例"></a>官方示例</h3><h4 id="Compose-WordPress"><a href="#Compose-WordPress" class="headerlink" title="Compose &amp; WordPress"></a>Compose &amp; WordPress</h4><ul>
<li>为项目创建空文件夹。该文件夹作为应用的上下文，且只保存构建镜像所需的资源。</li>
<li>创建 docker-compose.yml</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:5.7</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db_data:/var/lib/mysql</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">somewordpress</span></span><br><span class="line">      <span class="attr">MYSQL_DATABASE:</span> <span class="string">wordpress</span></span><br><span class="line">      <span class="attr">MYSQL_USER:</span> <span class="string">wordpress</span></span><br><span class="line">      <span class="attr">MYSQL_PASSWORD:</span> <span class="string">wordpress</span></span><br><span class="line">  <span class="attr">wordpress:</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">wordpress:latest</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8000:80&quot;</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">WORDPRESS_DB_HOST:</span> <span class="string">db:3306</span></span><br><span class="line">      <span class="attr">WORDPRESS_DB_USER:</span> <span class="string">wordpress</span></span><br><span class="line">      <span class="attr">WORDPRESS_DB_PASSWORD:</span> <span class="string">wordpress</span></span><br><span class="line">      <span class="attr">WORDPRESS_DB_NAME:</span> <span class="string">wordpress</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="attr">db_data:</span> &#123;&#125;</span><br><span class="line"><span class="comment"># db_data 卷会保存任何 WordPress 对数据库的改变。</span></span><br><span class="line"><span class="comment"># WordPress 通常开放 80 和 443 端口.</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>docker-compose up -d</code>.<blockquote>
<p>如果使用 Docker Machine, 那么运行 <code>docker-machine ip MACHINE_VM</code> 获取运行地址。如果是 destop 版，<a href="http://localhost/">http://localhost</a> 即可.</p>
</blockquote>
</li>
<li><code>docker-compose down</code> 移除容器，默认的网络，保留 WordPress 和数据库。<code>docker-compose down --volumes</code> 全部移除。</li>
</ul>
]]></content>
      <tags>
        <tag>docker</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>flutter 学习笔记</title>
    <url>/2019/06/04/00/</url>
    <content><![CDATA[<p>flutter 的核心设计是将整个应用的各个部分各个层级都看作 Widget 来渲染,所以按照 Widget 的分类来学习会比较全面。</p>
<span id="more"></span>
<h2 id="基础组件"><a href="#基础组件" class="headerlink" title="基础组件"></a>基础组件</h2><h3 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h3><ul>
<li>Row</li>
<li>Column</li>
<li>Image</li>
<li>Text</li>
<li>Icon</li>
<li>RaisedButton</li>
<li>Scaffold</li>
<li>AppBar</li>
<li>FlutterLogo</li>
<li>Placeholder</li>
</ul>
<h2 id="Material-组件"><a href="#Material-组件" class="headerlink" title="Material 组件"></a>Material 组件</h2><h3 id="结构和导航"><a href="#结构和导航" class="headerlink" title="结构和导航"></a>结构和导航</h3><ul>
<li>Scaffold</li>
<li>AppBar</li>
<li>BottomNavigationBar</li>
<li>TabBar</li>
<li>TabBarView</li>
<li>MaterialApp</li>
<li>WidgetsApp</li>
<li>Drawer</li>
</ul>
<h3 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h3><ul>
<li>RaisedButton</li>
<li>FloatingActionButton</li>
<li>FlatButton</li>
<li>IconButton</li>
<li>PopupMenuButton</li>
<li>ButtonBar</li>
</ul>
<h3 id="输入框和选择框"><a href="#输入框和选择框" class="headerlink" title="输入框和选择框"></a>输入框和选择框</h3><ul>
<li>TextField</li>
<li>Checkbox</li>
<li>Radio</li>
<li>Switch</li>
<li>Slider</li>
<li>Date &amp; Time Pickers</li>
</ul>
<h3 id="对话框-Alert-Panel"><a href="#对话框-Alert-Panel" class="headerlink" title="对话框,Alert Panel"></a>对话框,Alert Panel</h3><ul>
<li>SimpleDialog</li>
<li>AlertDialog</li>
<li>BottomSheet</li>
<li>ExpansionPanel</li>
<li>SnackBar</li>
</ul>
<h3 id="信息展示"><a href="#信息展示" class="headerlink" title="信息展示"></a>信息展示</h3><ul>
<li>Image</li>
<li>Icon</li>
<li>Chip</li>
<li>Tooltip</li>
<li>DataTable</li>
<li>Card</li>
<li>LinearProgressIndicator</li>
</ul>
<h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><ul>
<li>ListTile</li>
<li>Stepper</li>
<li>Divider</li>
</ul>
<h2 id="Cupertino"><a href="#Cupertino" class="headerlink" title="Cupertino"></a>Cupertino</h2><ul>
<li>CupertinoActivityIndicator</li>
<li>CupertinoAlertDialog</li>
<li>CupertinoButton</li>
<li>CupertinoDialog</li>
<li>CupertinoDialogAction</li>
<li>CupertinoSlider</li>
<li>CupertinoSwitch</li>
<li>CupertinoPageTransition</li>
<li>CupertinoFullScreenDialogTransition</li>
<li>CupertinoNavigationBar</li>
<li>CupertinoTabBar</li>
<li>CupertinoPageScaffold</li>
<li>CupertinoTabScaffold</li>
<li>CupertinoTabView</li>
</ul>
<h2 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h2><h3 id="单个元素"><a href="#单个元素" class="headerlink" title="单个元素"></a>单个元素</h3><ul>
<li>Container</li>
<li>Padding</li>
<li>Center</li>
<li>Align</li>
<li>FittedBox</li>
<li>AspectRatio</li>
<li>ConstrainedBox</li>
<li>Baseline</li>
<li>FractionallySizedBox</li>
<li>IntrinsicHeight</li>
<li>IntrinsicWidth</li>
<li>LimitedBox</li>
<li>Offstage</li>
<li>OverflowBox</li>
<li>SizedBox</li>
<li>SizedOverflowBox</li>
<li>Transform</li>
<li>CustomSingleChildLayout</li>
</ul>
<h3 id="多个元素"><a href="#多个元素" class="headerlink" title="多个元素"></a>多个元素</h3><ul>
<li>Row</li>
<li>Column</li>
<li>Stack</li>
<li>IndexedStack</li>
<li>Flow</li>
<li>Table</li>
<li>Wrap</li>
<li>ListBody</li>
<li>ListView</li>
<li>CustomMultiChildLayout</li>
</ul>
<h3 id="LayoutBuilder"><a href="#LayoutBuilder" class="headerlink" title="LayoutBuilder"></a>LayoutBuilder</h3><h2 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h2><ul>
<li>Text</li>
<li>RichText</li>
<li>DefaultTextStyle</li>
</ul>
<h2 id="Assets"><a href="#Assets" class="headerlink" title="Assets"></a>Assets</h2><ul>
<li>Image</li>
<li>Icon</li>
<li>RawImage</li>
<li>AssetBundle</li>
</ul>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><ul>
<li>Form</li>
<li>FormField</li>
<li>RawKeyboardListener</li>
</ul>
<h2 id="Animation"><a href="#Animation" class="headerlink" title="Animation"></a>Animation</h2><ul>
<li>AnimatedContainer</li>
<li>AnimatedCrossFade</li>
<li>Hero</li>
<li>AnimatedBuilder</li>
<li>DecoratedBoxTransition</li>
<li>FadeTransition</li>
<li>PositionedTransition</li>
<li>RotationTransition</li>
<li>ScaleTransition</li>
<li>SizeTransition</li>
<li>SlideTransition</li>
<li>AnimatedDefaultTextStyle</li>
<li>AnimatedListState</li>
<li>AnimatedModalBarrier</li>
<li>AnimatedOpacity</li>
<li>AnimatedPhysicalModal</li>
<li>AnimatedPositioned</li>
<li>AnimatedSize</li>
<li>AnimatedWidget</li>
<li>AnimatedWidgetBaseState</li>
</ul>
<h2 id="交互"><a href="#交互" class="headerlink" title="交互"></a>交互</h2><ul>
<li>LongPressDraggable</li>
<li>GestureDetector</li>
<li>DragTarget</li>
<li>Dismissible</li>
<li>IgnorePointer</li>
<li>AbsorbPointer</li>
<li>Navigator</li>
<li>Scrollable</li>
</ul>
<h2 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h2><ul>
<li>Padding</li>
<li>Theme</li>
<li>MediaQuery</li>
</ul>
<h2 id="Draw"><a href="#Draw" class="headerlink" title="Draw"></a>Draw</h2><ul>
<li>Opacity</li>
<li>Transform</li>
<li>DecoratedBox</li>
<li>FractionalTransition</li>
<li>RotatedBox</li>
<li>ClipOval</li>
<li>ClipPath</li>
<li>ClipRect</li>
<li>CustomPaint</li>
<li>BackdropFilter</li>
</ul>
<h2 id="Async"><a href="#Async" class="headerlink" title="Async"></a>Async</h2><ul>
<li>FutureBuilder</li>
<li>StreamBuilder</li>
</ul>
<h2 id="滚动"><a href="#滚动" class="headerlink" title="滚动"></a>滚动</h2><ul>
<li>ListView</li>
<li>NestedScrollView</li>
<li>GridView</li>
<li>SingleChildScrollView</li>
<li>Scrollable</li>
<li>Scrollbar</li>
<li>CustomScrollView</li>
<li>NotificationListener</li>
<li>ScrollConfiguration</li>
<li>RefreshIndicator</li>
</ul>
<h2 id="辅助"><a href="#辅助" class="headerlink" title="辅助"></a>辅助</h2><ul>
<li>Semantics</li>
<li>MergeSemantics</li>
<li>ExcludeSemantics</li>
</ul>
]]></content>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>git 笔记</title>
    <url>/2019/03/17/15/</url>
    <content><![CDATA[<span id="more"></span>
<ul>
<li>config</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改配置</span></span><br><span class="line">git config --<span class="built_in">local</span> <span class="comment"># 对某个仓库有效</span></span><br><span class="line">git config --global <span class="comment"># 对当前用户所有仓库有效</span></span><br><span class="line">git config --system <span class="comment"># 对系统所有登录用户有效</span></span><br><span class="line"><span class="comment"># 查看配置</span></span><br><span class="line">git config --list --<span class="built_in">local</span></span><br><span class="line">git config --list --global</span><br><span class="line">git config --list --system</span><br><span class="line"><span class="comment"># 打开编辑器修改config</span></span><br><span class="line">git config -e <span class="comment"># 仅对当前仓库有效</span></span><br><span class="line"><span class="comment"># 变更文件名</span></span><br><span class="line">git <span class="built_in">mv</span> readme readme.md <span class="comment"># 避免  mv x y -&gt; git add -&gt; git rm</span></span><br><span class="line">git <span class="built_in">log</span> [分支]</span><br><span class="line">        --oneline <span class="comment"># 一行显示</span></span><br><span class="line">        -n4 <span class="comment"># 指定最新的几次提交</span></span><br><span class="line">        --all <span class="comment"># 所有分支的提交</span></span><br><span class="line">        --graph <span class="comment"># 图形化显示</span></span><br><span class="line"><span class="comment"># 打开内置帮助网页.</span></span><br><span class="line">git <span class="built_in">help</span> --web [<span class="built_in">log</span>]</span><br><span class="line"><span class="comment"># gui</span></span><br><span class="line">gitk --all</span><br><span class="line">git branch -av</span><br><span class="line"><span class="comment"># 在 ./git/refs/heads/xxx 中查看信息</span></span><br><span class="line">git cat-file -t master <span class="comment"># 返回 git object model 类型: blog, tree, commit, tag</span></span><br><span class="line">            -p <span class="comment"># 显示所有内容</span></span><br><span class="line"><span class="comment"># 删除分支</span></span><br><span class="line">git branch -D [fixup]</span><br><span class="line"><span class="comment"># 变基</span></span><br><span class="line">git rebase -i</span><br><span class="line"><span class="comment"># 暂存区和最近一次提交的区别</span></span><br><span class="line">git diff --cached</span><br><span class="line"><span class="comment"># 将暂存区的内容丢弃</span></span><br><span class="line">git reset HEAD -- &lt;file&gt;</span><br><span class="line"><span class="comment"># 将暂存区的内容恢复到本地</span></span><br><span class="line">git checkout -- &lt;file&gt;</span><br><span class="line"><span class="comment"># 设置别名</span></span><br><span class="line">git config --global alias.co checkout</span><br><span class="line">git config --global alias.br branch</span><br><span class="line">git config --global alias.ci commit</span><br><span class="line">git config --global alias.st status</span><br><span class="line">git config --global alias.last <span class="string">&#x27;log -1 HEAD&#x27;</span></span><br><span class="line">git config --global alias.unstage <span class="string">&#x27;reset HEAD --&#x27;</span>; git unstage fileA === git reset HEAD -- fileA</span><br><span class="line">git config --global alias.visual <span class="string">&#x27;!gitk&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看各个分支所指的对象  --decorate</span></span><br><span class="line">git <span class="built_in">log</span> --oneline --decorate</span><br><span class="line">git <span class="built_in">log</span> --oneline --decorate --graph --all</span><br><span class="line"><span class="comment"># 跟踪远程分支</span></span><br><span class="line">git checkout --track origin/serverfix</span><br><span class="line">git checkout -b sf origin/serverfix; sf 分支追踪 origin/serverfix 分支.</span><br><span class="line"><span class="comment"># 添加修改正在追踪的上游分支; -u / --set-upstream-to</span></span><br><span class="line">git branch -u origin/serverfix</span><br><span class="line"><span class="comment"># 当设置好跟踪分支后，可通过 @&#123;upstream&#125; 或 @&#123;u&#125; 快捷方式来引用.所有如果 master 跟踪 origin/master。那么 git merge @&#123;u&#125; 可以取代 git merage origin/master.</span></span><br><span class="line"><span class="comment"># 查看所有跟踪分支</span></span><br><span class="line">git branch -vv</span><br><span class="line"><span class="comment"># 删除服务端的分支</span></span><br><span class="line">git push origin --delete serverfix</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">git init --bare --shared ; <span class="comment"># shared 会自动修改该仓库目录的组权限为可写.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 为服务端配置 SSH 访问</span></span><br><span class="line"><span class="built_in">sudo</span> adduser git</span><br><span class="line">su git</span><br><span class="line"><span class="built_in">cd</span></span><br><span class="line"><span class="built_in">mkdir</span> .ssh &amp;&amp; <span class="built_in">chmod</span> 700 .ssh</span><br><span class="line"><span class="built_in">touch</span> .ssh/authorized_keys &amp;&amp; <span class="built_in">chmod</span> 600 .ssh/authorized_keys</span><br><span class="line"><span class="built_in">cat</span> /tmp/id_rsa.john.pub &gt;&gt; ~/.ssh/authorized_keys</span><br><span class="line"><span class="built_in">cat</span> /tmp/id_rsa.josie.pub &gt;&gt; ~/.ssh/authorized_keys</span><br><span class="line"><span class="comment"># 限制 git 用户只能访问项目，无法登录远程主机.</span></span><br><span class="line"><span class="built_in">cat</span> /etc/shells</span><br><span class="line"><span class="built_in">which</span> git-shell</span><br><span class="line"><span class="built_in">sudo</span> vim /etc/shells； <span class="comment"># 将 git-shell 添加</span></span><br><span class="line"><span class="built_in">sudo</span> chsh git /usr/bin/git-shell; <span class="comment"># 限制 git 用户只能利用 SSH 连接对 Git 仓库进行推送和拉去操作，而不能登录机器并取得普通 shell.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以守护进程的方式设置 git 协议,不需要配置 SSH 公钥.</span></span><br><span class="line">git daemon --reuseaddr --base-path=/opt/git/ /opt/git/;</span><br><span class="line"><span class="comment"># --reuseaddr 允许服务器在无需等待旧连接超时的情况下重启</span></span><br><span class="line"><span class="comment"># --base-path 允许用户在未完全指定路径的条件下克隆项目,结尾的路径将告诉 git 守护进程从何处寻找仓库来导出.如果有防火墙运行，请开放 9418 端口.</span></span><br><span class="line"><span class="comment"># 空白错误(换行\tab\。。。)</span></span><br><span class="line">git diff --check</span><br><span class="line"><span class="comment"># 部分暂存</span></span><br><span class="line">git add --patch</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">git merge --squash featureB</span><br><span class="line"><span class="comment"># --squash 接受被合并分支上的所有工作，并将其压缩至一个变更及，使仓库成为真正合并发生的状态，而不是生成一个合并提交.</span></span><br><span class="line"><span class="comment"># 打包 archive</span></span><br><span class="line">git archive master --prefix=<span class="string">&#x27;project/&#x27;</span> | gzip &gt; `git describe master`.tar.gz</span><br><span class="line">git archive master --prefix=<span class="string">&#x27;project/&#x27;</span> --format=zip &gt; `git describe master`.zips</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">git diff --ours</span><br><span class="line">        <span class="comment"># --theirs</span></span><br><span class="line">        <span class="comment"># --base -b</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Dart-Zone</title>
    <url>/2019/10/23/01/</url>
    <content><![CDATA[<p>Dart 是单线程模型,相对于 JavaScript,其也有 <code>microTaskQueue</code> 和 <code>eventTaskQueue</code>.</p>
<span id="more"></span>
<p><code>Zone</code> 代表某个环境的稳定跨异步环境调用.</p>
<p>代码通常都执行在一个 <code>zone</code>中,如<code>Zone.current</code>.而<code>main</code>函数通常运行在默认的<code>Zone.root</code>上下文中.<br>通过 <code>runZoned</code> 创建一个新<code>zone</code> 或 <code>Zone.run</code> 将代码运行到一个由 <code>Zone.fork</code>创建的上下文中.</p>
<p>开发者可以通过覆盖一个存在<code>zone</code>的一些方法来创建一个新<code>zone</code>.如自定义<code>zone</code>可以替换或修改<code>print</code>、timers、<br>micortasks、uncaught erros 的默认行为.</p>
<p><code>Zone</code>类不可以被继承.可以使用 fork 存在的 <code>zone</code>,通常是<code>Zone.current</code>和<code>ZoneSpecification</code>来自定义<code>zone</code>.这和继承<code>Zone</code>类来创建新的<code>zone</code>类似.</p>
<p>异步回调总是运行在其被规定的<code>zone</code>上下文中.使用一下步骤实现:</p>
<ul>
<li>首先使用<code>registerCallback</code>、<code>registerUnaryCallback</code>、<code>registerBinaryCallback</code>中的一个注册.<code>zone</code>就就可以记录此<code>callback</code>或修改它(返回一个不同的<code>callback</code>).执行注册的代码(如 <code>Future.then</code>)也会记住当前的<code>zone</code>,之后<code>callback</code>就可以在此<code>zone</code>中运行.</li>
<li>之后在上面保留的<code>zone</code>中运行注册的<code>callback</code>.<br>这些通常都有平台处理,用户无需操心.如果要根据底层提供的功能或<code>native extensions</code>开发自定义的异步规则,则必须实现上面两步.</li>
</ul>
<p><code>bindCallback</code>、<code>bindUnaryCallback</code>、<code>bindBinaryCallback</code> 则简化了上面的步骤,直接调用即可.</p>
<p><code>bindCallbackGuarded</code>、<code>bindUnaryCallbackGuarded</code>、<code>bindBinaryCallbackGuarded</code>可以通过<code>Zone.runGuarded</code>来调用.</p>
<blockquote>
<p>Dart 构造方法不可见的实现方式: Zone._();</p>
</blockquote>
<p>所有的隔离入口函数被调用时(<code>main</code>或<code>spawned</code> 函数)都运行在根<code>zone</code>(即 <code>Zone.current</code>等于<code>Zone.root</code>).如果没有创建自定义的<code>zone</code>,后面的代码都会运行在此根<code>zone</code>中.</p>
<p>如果异步回调如<code>Future</code>或<code>Stream</code>没有捕获异常,则会调用<code>zone.handleUncaughtError</code>来捕获异常.</p>
<p><code>error zone</code>(<code>Zone.current.errorZone</code>)是处理未捕获异常的地方.异步异常不会传递到不同的error handler.</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:async&#x27;</span>;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> future;</span><br><span class="line">  runZoned(() &#123;</span><br><span class="line">    future = Future.error(<span class="string">&quot;asynchronous error&quot;</span>);</span><br><span class="line">  &#125;,onError:(e)&#123;<span class="built_in">print</span>(e);&#125;);</span><br><span class="line">  future.catchError(e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&quot;is never reached&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Dart</tag>
      </tags>
  </entry>
  <entry>
    <title>libgit2 NDK cross-compile</title>
    <url>/2022/02/08/26/</url>
    <content><![CDATA[<p>libgit2 最近升级到了 v1.3,然后自己也想利用这个库在安卓上开发个小工具，所以需要 NDK 交叉编译一下。</p>
<span id="more"></span>
<p>1、代码</p>
<p>首先下载 libgit2 源码，然后切换到 <code>git checkout v1.3.0</code>(这里的目的是锁住代码版本，否则在 master 分支，每次重新编译的代码可能会有所差异)</p>
<p>2、准备 ndk 工具链</p>
<p>打开 AndroidStudio 下载 NDK. 这里使用的版本是最新的 <code>24.0.7956693</code></p>
<p>3、依赖库准备</p>
<p>libgit2 有几个依赖库，在 <code>deps</code> 目录下。实际中 libgit2 有使用到 openssl 库，因为是交叉编译，所以也需要我们自己用 ndk 编译 openssl, 而不是直接使用本机上的 openssl</p>
<ul>
<li>下载 openssl 源码到 deps 目录下</li>
<li>根据 openssl 目录下的 NOTES-ANDROID.md 提示编译即可</li>
</ul>
<p>4、cmake android cross-compile 准备</p>
<p>在 libgit2 项目根目录下新建 <code>CMakeLists.android.txt</code> 文件.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET(CMAKE_SYSTEM_NAME Android) # 交叉编译时为 Android</span><br><span class="line">SET(CMAKE_ANDROID_ARCH_ABI  arm64-v8a) # arm64-v8a、Armeabi-v7a、armeabi-v6、armeabi、mips、mips64、x86、x86_64, 自动设置默认 armeabi.</span><br><span class="line">SET(CMAKE_ANDROID_NDK /Users/shuttle/Library/Android/sdk/ndk/24.0.7956693) # ndk 绝对路径</span><br><span class="line"></span><br><span class="line">SET(NDK_HOME /Users/shuttle/Library/Android/sdk/ndk/24.0.7956693)</span><br><span class="line">SET(OPENSSL_DYHOME /Users/shuttle/Project/Native/libgit2/deps/openssl)</span><br><span class="line"></span><br><span class="line">SET(OPENSSL_ROOT_DIR $&#123;OPENSSL_DYHOME&#125;)</span><br><span class="line">SET(OPENSSL_INCLUDE_DIR $&#123;OPENSSL_DYHOME&#125;/include)</span><br><span class="line">SET(OPENSSL_CRYPTO_LIBRARY $&#123;OPENSSL_DYHOME&#125;/libcrypto.so) # # Could NOT find OpenSSL, try to set the path to OpenSSL root folder in the system variable OPENSSL_ROOT_DIR (missing: OPENSSL_CRYPTO_LIBRARY) </span><br><span class="line">SET(OPENSSL_SSL_LIBRARY $&#123;OPENSSL_DYHOME&#125;/libssl.so)</span><br><span class="line">SET(OPENSSL_LIBRARIES $&#123;OPENSSL_DYHOME&#125;)</span><br><span class="line"></span><br><span class="line">add_definitions(&quot;--sysroot=$&#123;CMAKE_FIND_ROOT_PATH&#125; -Wall -g&quot;)</span><br><span class="line"></span><br><span class="line">SET(USE_SHA1 OpenSSL)</span><br><span class="line">SET(USE_HTTPS OpenSSL)</span><br><span class="line">SET(BUILD_TESTS OFF)</span><br></pre></td></tr></table></figure>

<p>5、cmake configure</p>
<p><code>cmake -S. -Bbuild_arm64 -GNinja -DCMAKE_TOOLCHAIN_FILE=CMakeLists.android.txt</code></p>
<p>6、cmake compile</p>
<p><code>cmake --build build_arm64</code></p>
<p>大功告成!</p>
<blockquote>
<p><a href="https://cmake.org/cmake/help/v3.12/manual/cmake-toolchains.7.html#cross-compiling-for-android-with-the-ndk">cmake android cross-compile</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>cmake</tag>
      </tags>
  </entry>
  <entry>
    <title>gradle</title>
    <url>/2019/03/28/38/</url>
    <content><![CDATA[<p>gradle</p>
<span id="more"></span>
<h3 id="Gradle-升级日志"><a href="#Gradle-升级日志" class="headerlink" title="Gradle 升级日志"></a>Gradle 升级日志</h3><p>5.0 包含了 Kotlin DSL 生产级支持,依赖版本对齐(类似 Maven BOM),任务超时,Java 11 支持</p>
<ul>
<li><p>Kotlin DSL 1.0</p>
</li>
<li><p>依赖版本对齐:</p>
<ul>
<li>同一逻辑组(platform)下的不同模块在依赖树中可以有相同的版本.也可以导入 Maven BOMs 定义 platform.</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  <span class="comment">// 导入 BOM.此文件中版本将覆盖依赖树中的其他版本</span></span><br><span class="line">  implementation(enforcedPlatform(<span class="string">&quot;org.springframework.boot:spring-boot-dependencies:1.5.8.RELEASE&quot;</span>))</span><br><span class="line">  <span class="comment">// 使用上面定义的版本</span></span><br><span class="line">  implementation(<span class="string">&quot;com.google.code.gson:gson&quot;</span>)</span><br><span class="line">  implementation(<span class="string">&quot;dom4j:dom4j&quot;</span>)</span><br><span class="line">  <span class="comment">// 覆盖上面的版本</span></span><br><span class="line">  implementation(<span class="string">&quot;org.codehaus.groovy:groovy:1.8.6&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Gradle build 初始化特性</p>
</li>
<li><p>可搜索文档</p>
</li>
<li><p>任务超时</p>
</li>
<li><p>解析依赖时 HTTP 重试</p>
</li>
<li><p>性能特性</p>
<ul>
<li>Gradle 可以作为一个低优先级的进程启动: –priority low 或者 org.gradle.priority&#x3D;low.可以保证 IDE&#x2F;Browser 不卡,即使是一个很消耗资源的 gradle 任务.</li>
<li>多任务输出属性不再禁用缓存.当使用 <code>@OutputFiles</code> 或 <code>OutputDirectories</code> 标记一个<code>Iterable</code>类型,Gradle 通常会对该任务禁用缓存且输出如下信息:</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Declares multiple output files <span class="keyword">for</span> the single output property <span class="string">&#x27;outputFiles&#x27;</span> via @OutputFiles,@OutputDirectories or TaskOutputs.files()</span><br></pre></td></tr></table></figure>

<p>现在不会再阻止缓存了.对该任务禁用缓存的唯一理由可能是如果输出包含文件树.</p>
</li>
<li><p>Java 11 运行时支持</p>
</li>
<li><p>插件授权特性</p>
</li>
<li><p><code>Provider 追踪产品任务</code>：Provider API 实例提供了追踪某值和任务或生成该值的任务。</p>
</li>
<li><p>Gradle Native 特性</p>
</li>
<li><p>推广特性</p>
</li>
</ul>
<h3 id="Gradle-编译语言指南"><a href="#Gradle-编译语言指南" class="headerlink" title="Gradle 编译语言指南"></a><a href="https://docs.gradle.org/current/dsl/index.html">Gradle 编译语言指南</a></h3><h4 id="gradle-可以使用不同的语言或-DSL-来执行编译任务"><a href="#gradle-可以使用不同的语言或-DSL-来执行编译任务" class="headerlink" title="gradle 可以使用不同的语言或 DSL 来执行编译任务"></a>gradle 可以使用不同的语言或 DSL 来执行编译任务</h4><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>理解以下概念可以帮助书写 gradle 脚本.<br>首先，gradle 脚本是一种可配置脚本.当脚本执行时，会生成一个特定类型的配置对象.例如 build script 执行时，会生成一个类型为 Project 的配置对象.这个对象作为脚本的代理对象被使用.下面显示了 gradle 脚本对应的代理对象.</p>
<table>
<thead>
<tr>
<th>脚本类型</th>
<th>代理对象</th>
</tr>
</thead>
<tbody><tr>
<td>build script</td>
<td>Project</td>
</tr>
<tr>
<td>init script</td>
<td>Gradle</td>
</tr>
<tr>
<td>settings script</td>
<td>settings</td>
</tr>
</tbody></table>
<p>在脚本内可以使用这些代理对象的属性和方法.</p>
<h4 id="build-script-结构"><a href="#build-script-结构" class="headerlink" title="build script 结构"></a>build script 结构</h4><p>一段编译脚本由 0 个或多个语句和脚本块组成。语句可以包含方法调用，属性赋值，定义局部变量。一个脚本块是一个接受 closure 作为参数的方法调用.这个 closure 可以看作是一个当其执行时配置了一些代理对象的可配置 closure. 最顶层的脚本块如下</p>
<table>
<thead>
<tr>
<th>脚本块</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>allprojects{}</td>
<td>配置此项目及其所有子项目</td>
</tr>
<tr>
<td>artifacts{}</td>
<td>配置此项目的发布产物</td>
</tr>
<tr>
<td>buildscript{}</td>
<td>配置此项目的 build script classpath</td>
</tr>
<tr>
<td>configurations{}</td>
<td>配置此项目的依赖配置项</td>
</tr>
<tr>
<td>dependencies{}</td>
<td>配置此项目的依赖</td>
</tr>
<tr>
<td>repositories{}</td>
<td>配置此项目的仓库</td>
</tr>
<tr>
<td>sourceSets{}</td>
<td>配置此项目的 source set</td>
</tr>
<tr>
<td>subprojects{}</td>
<td>配置此项目的子项目</td>
</tr>
<tr>
<td>publishing{}</td>
<td>配置由 publishing plugin 添加的 publishingExtension</td>
</tr>
</tbody></table>
<p>一段编译脚本同时也是一个 groovy 脚本,所以可以包含能出现在 groovy 脚本中的元素,如 方法定义，类定义</p>
<h4 id="核心类型"><a href="#核心类型" class="headerlink" title="核心类型"></a>核心类型</h4><p>以下是在 gradle 脚本中常用的核心类型</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Project</td>
<td>此接口是你在你的编译脚本中最常使用的 API。通过 Project,你可以使用 gradle 的所有特性</td>
</tr>
<tr>
<td>Task</td>
<td>一个 task 代表一个编译过程中的一个单一原子任务，如编译 class,生成 javadoc</td>
</tr>
<tr>
<td>Gradle</td>
<td>表示 gradle 的调用</td>
</tr>
<tr>
<td>Settings</td>
<td>声明实例化和配置要参与构建的 Project 实例的层次结构所需的配置</td>
</tr>
<tr>
<td>Script</td>
<td>此接口由所有的 gradle 脚本实现并添加一些 gradle 特定的方法。当你编译脚本类时将会实现此接口，你可以在脚本中使用此接口声明的方法和属性</td>
</tr>
<tr>
<td>JavaToolChain</td>
<td>一组用于编译 Java 源文件的工具</td>
</tr>
<tr>
<td>SourceSet</td>
<td>表示 Java 源文件和资源文件的逻辑组</td>
</tr>
<tr>
<td>SourceSetOutput</td>
<td>所有输出目录的集合(编译的类，处理过的资源等),SourceSetOutput 继承自 FileCollection</td>
</tr>
<tr>
<td>SourceDirectorySet</td>
<td>表示一组由一系列源文件目录组成的源文件。以及相关的 include 和 exclude pattern</td>
</tr>
<tr>
<td>IncrementalTaskInputs</td>
<td>提供通过增量任务访问任意需要被处理文件的途径</td>
</tr>
<tr>
<td>Configuration</td>
<td>表示一组产物及其依赖。从 ConfigurationContainer 中可以获取更多关于对 configuration 声明依赖或者管理 configuration 的信息</td>
</tr>
<tr>
<td>ResolutingStrategy</td>
<td>定义依赖解析的策略.例如强制固定依赖版本号，替代，冲突解决方案或快照</td>
</tr>
<tr>
<td>ArtifactResolutingQuery</td>
<td>发起可以解析特定组件的指定软件产物的查询的生成器</td>
</tr>
<tr>
<td>ComponentSelection</td>
<td>表示一个模块的组件选择器和某个组件选中规则中评估的候选版本的元组</td>
</tr>
<tr>
<td>ComponentSelectionRules</td>
<td>表示组件选中规则的容器.规则可以作为一个 configuration 的解析规则一部分被使用，而且独立的组件可以明确接受或拒绝该规则。既不接受也不拒绝的组件将被指定到默认的版本匹配规则</td>
</tr>
<tr>
<td>ExtensionAware</td>
<td>在运行时可以和其他对象一起被扩展的对象</td>
</tr>
<tr>
<td>ExtraPropertiesExtension</td>
<td>Gradle 域对象的附加 ad-hoc 属性</td>
</tr>
<tr>
<td>PluginDependenciesSpec</td>
<td>在脚本中使用的声明插件的 DSL</td>
</tr>
<tr>
<td>PluginDependencySpec</td>
<td>插件依赖的可变规范</td>
</tr>
<tr>
<td>PluginManagementSpec</td>
<td>配置插件如何被解析</td>
</tr>
<tr>
<td>ResourceHandler</td>
<td>提供访问特定资源的工具方法的途径,例如创建各种资源的工厂方法</td>
</tr>
<tr>
<td>TextResourceFactory</td>
<td>创建由字符串、文件、存档实体等资源提供的 TextResources</td>
</tr>
</tbody></table>
<h4 id="type-safe-model-accessors"><a href="#type-safe-model-accessors" class="headerlink" title="type-safe model accessors"></a>type-safe model accessors</h4><p>执行时机：plugins{} 块后，script 脚本之前.</p>
<figure class="highlight kts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// build.gradle.kts</span></span><br><span class="line">plugins &#123;</span><br><span class="line">  `java-library`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">  api(<span class="string">&quot;junit:junit;4.12&quot;</span>)</span><br><span class="line">  implementation(<span class="string">&quot;junit:junit:4.12&quot;</span>)</span><br><span class="line">  testImplementation(<span class="string">&quot;junit:junit:4.12&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">configurations &#123;</span><br><span class="line">  implementation &#123;</span><br><span class="line">    resolutinStrategy.failOnVersionConflict()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sourceSets &#123;</span><br><span class="line">  main &#123;</span><br><span class="line">    java.srcDir(<span class="string">&quot;src/core/java&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">java &#123;</span><br><span class="line">  sourceCompatibility = JavaVersion.VERSION_11</span><br><span class="line">  targetCompatibility = JavaVersion.VERSION_11</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tasks &#123;</span><br><span class="line">  test &#123;</span><br><span class="line">    testLogging.showExceptions = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="了解-type-safe-accessors-不可用时要执行的操作"><a href="#了解-type-safe-accessors-不可用时要执行的操作" class="headerlink" title="了解 type-safe accessors 不可用时要执行的操作"></a>了解 type-safe accessors 不可用时要执行的操作</h4><p>下面的脚本明确使用了 apply() 方法应用插件.编译脚本无法使用 type-safe accessors,因为 apply() 方法是在这个编译脚本内调用的。你可以采用其他技巧，如下</p>
<figure class="highlight kts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// build.gradle.kts</span></span><br><span class="line">apply(plugin = <span class="string">&quot;java-library&quot;</span>)</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">  <span class="string">&quot;api&quot;</span>(<span class="string">&quot;junit:junit:4.12&quot;</span>)</span><br><span class="line">  <span class="string">&quot;implementation&quot;</span>(<span class="string">&quot;junit:junit:&quot;</span><span class="number">4.12</span><span class="string">&quot;)</span></span><br><span class="line"><span class="string">  &quot;</span>testImplementation<span class="string">&quot;(&quot;</span>junit:junit:<span class="number">4.12</span><span class="string">&quot;)</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">configurations &#123;</span></span><br><span class="line"><span class="string">  &quot;</span>implementation<span class="string">&quot; &#123;</span></span><br><span class="line"><span class="string">    resolutinStrategy.failOnVersionConflict()</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">configure&lt;SourceSetContainer&gt; &#123;</span></span><br><span class="line"><span class="string">  named(&quot;</span>main<span class="string">&quot;) &#123;</span></span><br><span class="line"><span class="string">    java.srcDir(&quot;</span>src/core/java<span class="string">&quot;)</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">configure&lt;JavaPluginConvention&gt; &#123;</span></span><br><span class="line"><span class="string">  sourceCompatibility = JavaVersion.VERSION_11</span></span><br><span class="line"><span class="string">  targetCompatibility = JavaVersion.VERSION_11</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">tasks &#123;</span></span><br><span class="line"><span class="string">  named&lt;Test&gt;(&quot;</span>test<span class="string">&quot;) &#123;</span></span><br><span class="line"><span class="string">    testLogging.showException = true</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>下列情况下，type-safe accessor 不可用</p>
<ul>
<li>使用 apply(plugin &#x3D; id) 应用插件</li>
<li>项目 build script</li>
<li>通过 apply(from &#x3D; “script-plugin.gradle.kts”) 应用的脚本插件</li>
<li>跨项目配置的插件</li>
</ul>
<h4 id="产物配置"><a href="#产物配置" class="headerlink" title="产物配置"></a>产物配置</h4><figure class="highlight kts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// build.gradle.jts</span></span><br><span class="line">apply(plugin = <span class="string">&quot;java-library&quot;</span>)<span class="string">&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">dependencies &#123;</span></span><br><span class="line"><span class="string">  &quot;api&quot;(&quot;junit:junit:4.12&quot;)</span></span><br><span class="line"><span class="string">  &quot;implementation&quot;(&quot;junit:junit:4.12&quot;)</span></span><br><span class="line"><span class="string">  &quot;testImplementation&quot;(&quot;junit:junit:4.12&quot;)</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">configurations &#123;</span></span><br><span class="line"><span class="string">  &quot;implementation&quot; &#123;</span></span><br><span class="line"><span class="string">    resolutinStrategy.failOnVersionConflict()</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<figure class="highlight kts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// settings.gradle.kts</span></span><br><span class="line">pluginManagement &#123;</span><br><span class="line">  repositories &#123;</span><br><span class="line">    google()</span><br><span class="line">    gradlePluginPortal()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  resolutionStrategy &#123;</span><br><span class="line">    eachPlugin &#123;</span><br><span class="line">      <span class="keyword">if</span> (requested.id.namespace == <span class="string">&#x27;com.android&#x27;</span>) &#123;</span><br><span class="line">        useModule(<span class="string">&#x27;com.android.tools.build:gradle:$&#123;requested.version&#125;&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// build.gradle.kts</span></span><br><span class="line"><span class="keyword">val</span> check <span class="keyword">by</span> tasks.existing</span><br><span class="line"><span class="keyword">val</span> myTask1 <span class="keyword">by</span> tasks.registering</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> compileJava <span class="keyword">by</span> tasks.existing(JavaCompile::<span class="keyword">class</span>)</span><br><span class="line"><span class="keyword">val</span> myCopy1 <span class="keyword">by</span> tasks.registering(Copy::<span class="keyword">class</span>)</span><br><span class="line"></span><br><span class="line">va; assemble <span class="keyword">by</span> tasks.existing &#123;</span><br><span class="line">  dependsOn(myTask1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> myTask2 <span class="keyword">by</span> tasks.registering &#123;</span><br><span class="line">  description = <span class="string">&quot;some meaningful words&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> test <span class="keyword">by</span> tasks.existing(Test::<span class="keyword">class</span>) &#123;</span><br><span class="line">  testLogging.showStackTrace = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> myCopy2 <span class="keyword">by</span> tasks.registering(Copy::<span class="keyword">class</span>) &#123;</span><br><span class="line">  from(<span class="string">&quot;source&quot;</span>)</span><br><span class="line">  into(<span class="string">&quot;destination&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="升级-Gradle-Wrapper"><a href="#升级-Gradle-Wrapper" class="headerlink" title="升级 Gradle Wrapper"></a>升级 <code>Gradle Wrapper</code></h3><p>如果已经有基于<code>gradlew wrapper</code>的项目,可以通过运行<code>wrapper</code>任务来指定需要的<code>gradle</code>版本.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./gradlew wrapper --gradle-version=5.3 --distribution-type=bin</span><br></pre></td></tr></table></figure>

<p>当然没必要使用<code>gradle wrapper</code>来安装<code>gradle</code>.调用<code>gradlew</code>或<code>gradlew.bat</code>将会下载并缓存指定版本的 Gradle.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./gradlew taska</span><br></pre></td></tr></table></figure>

<h3 id="CLI-自动补全"><a href="#CLI-自动补全" class="headerlink" title="CLI 自动补全"></a>CLI 自动补全</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install gradle-completion</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$fpath</span> | grep <span class="string">&quot;/usr/local/share/zsh/site-functions&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="设计-gradle-插件"><a href="#设计-gradle-插件" class="headerlink" title="设计 gradle 插件"></a>设计 gradle 插件</h3><p>对 gradle 新手来说，实现 gradle 插件可能是一个坑:组织管理插件逻辑，测试、调试插件代码等.可以在<a href="https://gradle.org/guides">此</a>获取到更多的信息.</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>通过指定 subproject 的路径，可以将本地任何路径下的代码导入工程中，供本地开发调试。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">include <span class="string">&#x27;:lib&#x27;</span></span><br><span class="line">project(<span class="string">&#x27;:lib&#x27;</span>).projectDir = <span class="keyword">new</span> File(<span class="string">&#x27;xxx/xxx/lib&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="com-android-application-插件"><a href="#com-android-application-插件" class="headerlink" title="com.android.application 插件"></a>com.android.application 插件</h3><ul>
<li><code>applicationVariants</code></li>
</ul>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  AppExtension 继承自 BaseExtension 唯一扩展的成员变量，它的参数类型是 DefaultDomainObjectSet,这是不同 buildType 及 Flavor 的集合,applicationVariants 最长的是它的 all 方法，如修改 apk 名字</span></span><br><span class="line"><span class="keyword">def</span> buildTime() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Date().format(<span class="string">&quot;yyyy-MM-dd&quot;</span>,TimeZone.getTimeZone(<span class="string">&quot;UTC&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">  applicationVariants.all &#123; variant -&gt;</span><br><span class="line">    variant.outputs.each &#123; output -&gt;</span><br><span class="line">      <span class="keyword">def</span> outputFile = output.outputFile</span><br><span class="line">      <span class="keyword">if</span> (outputFile != <span class="literal">null</span> &amp;&amp; outputFile.name.endsWith(<span class="string">&#x27;.apk&#x27;</span>)) &#123;</span><br><span class="line">        <span class="keyword">def</span> fileName = <span class="string">&quot;$&#123;variant.buildType.name&#125;-$&#123;variant.versionName&#125;-$&#123;buildTime()&#125;.apk&quot;</span></span><br><span class="line">        output.outputFile = <span class="keyword">new</span> File(output.outputFile.parent,fileName)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><code>defaultConfig</code></li>
</ul>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">defaultConfig &#123;</span><br><span class="line">    applicationId <span class="string">&#x27;**.**.**&#x27;</span></span><br><span class="line">    applicationIdSuffix <span class="string">&#x27;.two&#x27;</span> <span class="comment">//applicationId的后缀，可以用在想同时安装运行两个Flavor包的时候，比如同时安装debug包和Release包做一些对比。</span></span><br><span class="line">    minSdkVersion <span class="number">14</span></span><br><span class="line">    minSdkVersion <span class="number">14</span></span><br><span class="line">    targetSdkVersion <span class="number">28</span></span><br><span class="line">    versionCode <span class="number">1</span></span><br><span class="line">    versionName <span class="string">&#x27;1.0&#x27;</span></span><br><span class="line">    versionNameSuffix <span class="string">&#x27;.0&#x27;</span> <span class="comment">// versionName后缀</span></span><br><span class="line">    consumerProguardFiles <span class="string">&#x27;proguard-rules.pro&#x27;</span> <span class="comment">//用于Library中，可以将混淆文件输出到aar中，供Application混淆时使用。</span></span><br><span class="line">    dimension <span class="string">&#x27;api&#x27;</span></span><br><span class="line">    <span class="comment">//给渠道一个分组加维度的概念，比如你现在有三个渠道包，分成免费和收费两种类型，</span></span><br><span class="line">    <span class="comment">//可以添加一个dimension, 打渠道包的时候会自动打出6个包，而不需要添加6个渠道，</span></span><br><span class="line">    <span class="comment">// 详细的说明可见 https://developer.android.com/studio/build/build-variants.html#flavor-dimensions。</span></span><br><span class="line">    externalNativeBuild &#123; <span class="comment">//ndk的配置，AS2.2之后推荐切换到cmake的方式进行编译。</span></span><br><span class="line">        cnamke &#123;</span><br><span class="line">            cppFlags <span class="string">&#x27;-frtti --fexceptions&#x27;</span></span><br><span class="line">            arguments <span class="string">&#x27;-DANDROID_ARM_NEON=TRUE&#x27;</span></span><br><span class="line">            buildStagingDirectory <span class="string">&#x27;./outputs/cmake&#x27;</span></span><br><span class="line">            path <span class="string">&#x27;CMakeLists.txt&#x27;</span></span><br><span class="line">            version <span class="string">&#x27;3.7.1&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        ndkBuild &#123;</span><br><span class="line">          path <span class="string">&#x27;Android.mk&#x27;</span></span><br><span class="line">          buildStagingDirectory <span class="string">&#x27;./outputs/ndk-build&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    javaCompileOptions &#123;</span><br><span class="line">      annotationProcessorOptions &#123; <span class="comment">// 注解的配置</span></span><br><span class="line">        includeCompileClasspath <span class="literal">true</span> <span class="comment">// 使用注解功能</span></span><br><span class="line">        arguments = [ <span class="attr">eventBusIndex :</span> <span class="string">&#x27;org.greenrobot.eventbusperf.MyEventBusIndex&#x27;</span> ] <span class="comment">// AbstractProcessor 中可以读取到该参数</span></span><br><span class="line">        classNames</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    manifestPlaceholders = [<span class="attr">key:</span> <span class="string">&#x27;value&#x27;</span>] <span class="comment">// manifest 占位符，定义参数给 manifest 调用，如不同的渠道id</span></span><br><span class="line">    multiDexEnabled <span class="literal">true</span> <span class="comment">// 启用 multiDex</span></span><br><span class="line">    multiDexKeepFile file(<span class="string">&#x27;multiDexKeep.txt&#x27;</span>) <span class="comment">// 手动拆包，将具体的类放在主 dex</span></span><br><span class="line">    mutliDexKeepProguard file(<span class="string">&#x27;multiDexKeep.pro&#x27;</span>) <span class="comment">// 支持 proguard 语法，进行一些模糊匹配.</span></span><br><span class="line"></span><br><span class="line">    ndk &#123;</span><br><span class="line">      abiFilterss <span class="string">&#x27;x86&#x27;</span>,<span class="string">&#x27;x86_64&#x27;</span>,<span class="string">&#x27;armeabi&#x27;</span> <span class="comment">// 只保留特定的 abi 输出到 apk</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    proguardFiles getDefaultProguardFile(<span class="string">&#x27;proguard-android.txt&#x27;</span>), <span class="string">&#x27;proguard-rules.pro&#x27;</span> <span class="comment">// 混淆文件的列表，如默认的 android 混淆文件及本地的 proguard 文件，切记不要遗漏 android 混淆文件，否则导致一些默认安卓组件无法找到</span></span><br><span class="line"></span><br><span class="line">    signingConfig &#123;</span><br><span class="line">      storeFile file(<span class="string">&#x27;debug.keystore&#x27;</span>) <span class="comment">// 签名文件路径</span></span><br><span class="line">      storePassword <span class="string">&#x27;android&#x27;</span> <span class="comment">// 签名文件密码</span></span><br><span class="line">      keyAlias <span class="string">&#x27;androiddebugkey&#x27;</span> <span class="comment">// 别名</span></span><br><span class="line">      keyPassword <span class="string">&#x27;android&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buildConfigField(<span class="string">&#x27;boolean&#x27;</span>,<span class="string">&#x27;IS_RELEASE&#x27;</span>,<span class="string">&#x27;false&#x27;</span>) <span class="comment">// 在代码中可以通过 BuildConfig.IS_RELEASE 调用。默认 false</span></span><br><span class="line">    resValue(<span class="string">&#x27;string&#x27;</span>,<span class="string">&#x27;appname&#x27;</span>,<span class="string">&#x27;demo&#x27;</span>) <span class="comment">// 在 res/value 中添加 &lt;string name=&quot;appname&quot; translatable=&quot;false&quot;&gt;demo&lt;/string&gt;</span></span><br><span class="line">    resConfigs <span class="string">&#x27;cn&#x27;</span>,<span class="string">&#x27;hdpi&#x27;</span> <span class="comment">// 指定特定资源，可以结合 productFlavors 实现不同渠道的最小的 apk 包.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>productFlavors</code>: 渠道包的列表，可覆盖 defaultConfig 的参数配置,形成自己的风味</li>
<li><code>flavorDimensionList</code>: 添加纬度的定义</li>
<li><code>resourcePrefix</code>: 在模块化开发中给每个模块指定一个特定的资源前缀，避免多模块使用相同的文件名后合并冲突，在 build.gradle 指定此配置后，AS 会检查不合法的资源命名并报错</li>
<li><code>buildTypes</code>: 默认有 debug 和 release。</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">debug &#123;</span><br><span class="line">  applicationIdSuffix <span class="string">&#x27;.debug&#x27;</span></span><br><span class="line">  versionNameSuffix <span class="string">&#x27;.1&#x27;</span></span><br><span class="line">  debugable <span class="literal">true</span> <span class="comment">// 生成的 apk 是否可调试，debug -&gt; true,release -&gt; false</span></span><br><span class="line">  jniDebuggable <span class="literal">true</span> <span class="comment">// 是否可以调试 NDK 代码，使用 lldb 进行 c/c++ 代码调试</span></span><br><span class="line">  crunchPngs <span class="literal">true</span> <span class="comment">// 是否开启 png 优化，会对 png 图片做一次最优压缩，影响编译速度, debug -&gt; false,release -&gt; true</span></span><br><span class="line">  embedMicroApp <span class="literal">true</span> <span class="comment">// Android Wear 支持</span></span><br><span class="line">  minifyEnabled <span class="literal">true</span> <span class="comment">// 是否开启混淆</span></span><br><span class="line">  renderscriptDebuggable <span class="literal">false</span> <span class="comment">// 是否开启渲染脚本</span></span><br><span class="line">  renderscriptOptimLevel <span class="number">5</span> <span class="comment">// 渲染脚本等级 默认 5</span></span><br><span class="line">  zipAlignEnabled <span class="literal">true</span> <span class="comment">// 是否 zip 对齐优化，默认 true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ndkDirectory</code>: 也可在 local.properties 中配置 ndk.dir&#x3D;&#x2F;Users&#x2F;shuttle&#x2F;Library&#x2F;Android&#x2F;sdk</li>
<li><code>sdkDirectory</code>: ..</li>
<li><code>aaptOptions</code>: 资源打包工具</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">aaptOptions &#123;</span><br><span class="line">  additionalParameters <span class="string">&#x27;--rename-manifest-package&#x27;</span>,<span class="string">&#x27;cct.cn.gradle.lsn13&#x27;</span>,<span class="string">&#x27;-S&#x27;</span>,<span class="string">&#x27;src/main/res2&#x27;</span>,<span class="string">&#x27;--auto-add-overlay&#x27;</span> <span class="comment">// appt 执行时的额外参数</span></span><br><span class="line">  cruncherEnabled <span class="literal">true</span> <span class="comment">// 对 png 进行优化检查</span></span><br><span class="line">  ignoreAssets <span class="string">&#x27;*.jpg&#x27;</span> <span class="comment">// 对 res 目录下的资源文件进行排除，把 res 文件下的所有 .jpg 文件打包到 apk 中</span></span><br><span class="line">  noCompress <span class="string">&#x27;.jpg&#x27;</span> <span class="comment">// 对所有 jpg 文件不压缩</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>adbExecutable</code>: adb 路径</li>
<li><code>adbOptions</code></li>
</ul>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">adbOptions &#123;</span><br><span class="line">  installOptions <span class="string">&#x27;-r&#x27;</span>,<span class="string">&#x27;-d&#x27;</span> <span class="comment">// 调用 adb install 命令时默认传递的参数</span></span><br><span class="line">  timeOutInMs <span class="number">1000</span> <span class="comment">// 执行 adb 命令的超时时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>compileOptions</code></li>
</ul>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">compileOptions &#123;</span><br><span class="line">  encoding <span class="string">&#x27;UTF-8&#x27;</span> <span class="comment">// java 源文件的编码格式，默认 utf8</span></span><br><span class="line">  incrmental <span class="literal">true</span> <span class="comment">// java编译是否使用 gradle 增量编译</span></span><br><span class="line">  sourceCompatibility JavaVersion.VERSION_1_7 <span class="comment">// java 源文件编译的 jdk 版本</span></span><br><span class="line">  targetCompatibility JavaVersion.VERSION_1_7 <span class="comment">// 编译出的 class 版本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>dataBinding</code></li>
</ul>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dataBinding &#123;</span><br><span class="line">  enabled = <span class="literal">true</span></span><br><span class="line">  version = <span class="string">&quot;1.0&quot;</span></span><br><span class="line">  addDefaultAdapters = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>defaultPublishConfig</code>: 指定发布的渠道及 BuildType 类型。在 Library 中使用,默认 Release.</li>
<li><code>signingConfigs</code>: 签名配置列表，供不同渠道和 buildType 使用.</li>
<li><code>lintOptions</code></li>
</ul>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">lintOptions &#123;</span><br><span class="line">  quiet <span class="literal">true</span> <span class="comment">// true -&gt; 不报告分析的进度</span></span><br><span class="line">  abortOnError <span class="literal">false</span> <span class="comment">// true -&gt; 发现错误时终止 gradle</span></span><br><span class="line">  ignoreWarnings <span class="literal">true</span> <span class="comment">// true -&gt; 只报告错误</span></span><br><span class="line">  absolutePaths <span class="literal">true</span> <span class="comment">// true -&gt; 当有错误时显示文件的全路径或绝对路径</span></span><br><span class="line">  checkAllWarnings <span class="literal">true</span> <span class="comment">// true -&gt; 检查所有问题，包括默认不检查问题</span></span><br><span class="line">  warningsAsErrors <span class="literal">true</span> <span class="comment">// true -&gt; 将所有警告视为错误</span></span><br><span class="line">  disable <span class="string">&#x27;TypeographyFractions&#x27;</span>,<span class="string">&#x27;TypographyQUotes&#x27;</span> <span class="comment">// 不检查给定问题 id</span></span><br><span class="line">  enable <span class="string">&#x27;RtlHardCoded&#x27;</span>,<span class="string">&#x27;RtlCompat&#x27;</span>,<span class="string">&#x27;RtlEnabled&#x27;</span> <span class="comment">// 检查给定问题 id</span></span><br><span class="line">  check <span class="string">&#x27;NewApi&#x27;</span>,<span class="string">&#x27;InlinedApi&#x27;</span> <span class="comment">// 仅 检查给定问题 id</span></span><br><span class="line">  noLines <span class="literal">true</span> <span class="comment">// 如果为 true,则在错误报告的输出中不包含源代码行</span></span><br><span class="line">  showAll <span class="literal">true</span> <span class="comment">// true -&gt; 对一个错误的问题显示它所在的所有地方，而不会截短列表等等。</span></span><br><span class="line">  lintConfig file(<span class="string">&#x27;default-lint.xml&#x27;</span>) <span class="comment">// 重置 lint 配置(使用默认的严重性等设置)</span></span><br><span class="line">  textReport <span class="literal">true</span> <span class="comment">// true -&gt; 生成一个问题的纯文本报告(default -&gt; false)</span></span><br><span class="line">  textOuput <span class="string">&#x27;stdout&#x27;</span> <span class="comment">// 默认写入输出结果的位置，可能是一个文件或 stdout</span></span><br><span class="line">  xmlReport <span class="literal">false</span> <span class="comment">// true -&gt; 生成 xml 报告，jenkins 可以使用</span></span><br><span class="line">  xmlOutput file(<span class="string">&quot;lint-report.xml&quot;</span>) <span class="comment">// 写入报告的文件，默认 line-results.xml</span></span><br><span class="line">  htmlReport <span class="literal">true</span> <span class="comment">// html 报告</span></span><br><span class="line">  htmlOutput file(<span class="string">&#x27;lint-report.html&#x27;</span>) <span class="comment">// 写入报告的路径，可选(默认为构建目录下的 lint-results.html)</span></span><br><span class="line">  checkReleaseBuilds <span class="literal">true</span> <span class="comment">// true -&gt; 将使所有 release 构建都以 issus 的严重性级别为 fatal (serverity=false)的设置来运行 lint,且如果发现了致命(fatal)的问题,将会中止构建(由上面提到的 abortOnError 控制)</span></span><br><span class="line">  fatal <span class="string">&#x27;NewApi&#x27;</span>,<span class="string">&#x27;InlineApi&#x27;</span> <span class="comment">// 设置给定问题的严重级别(serverity)为 fatal（即将会在 release 构建期间检查,即使 lint 要检查的问题没有包含在代码中）</span></span><br><span class="line">  error <span class="string">&#x27;Wakelock&#x27;</span>,<span class="string">&#x27;TextViewEdits&#x27;</span> <span class="comment">// 设置给定问题的严重级别为 error</span></span><br><span class="line">  warning <span class="string">&#x27;ResourceAsColor&#x27;</span> <span class="comment">// 设置给定问题的严重级别为 warning</span></span><br><span class="line">  ignore <span class="string">&#x27;TypographyQUotes&#x27;</span> <span class="comment">// 设置给定问题的严重级别(serverity)为 ignore (和不检查该问题一样)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>dexOptions</code>: 热修复差分包</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dexOptions &#123;</span><br><span class="line">  additionalParameters <span class="string">&#x27;--minimal-main-dex&#x27;</span>,<span class="string">&#x27;--set-max-idx-number=10000&#x27;</span> <span class="comment">// dx 命令附加参数</span></span><br><span class="line">  javaMaxHeapSize <span class="string">&#x27;2048m&#x27;</span> <span class="comment">// 执行 dx 时 Java 虚拟机可用的最大内存大小</span></span><br><span class="line">  jumboMode <span class="literal">true</span> <span class="comment">// 开启大模式，所有的 class 打到一个 dex 中,可以忽略 65535 方法数的限制, 大于14版本可用</span></span><br><span class="line">  keepRuntimeAnnotatedClasses <span class="literal">true</span> <span class="comment">// 在 dex 中是否保留 Runtime 注解,默认 true</span></span><br><span class="line">  maxProcessCount <span class="number">4</span> <span class="comment">// dex 中的进程数,默认 4</span></span><br><span class="line">  threadCount <span class="number">4</span> <span class="comment">// 默认线程数</span></span><br><span class="line">  preDexLibraries <span class="literal">true</span> <span class="comment">// 对 library 预编译，提高编译效率，但 clean 时较慢，默认 true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>packagingOptions</code></li>
</ul>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">packagingOptions &#123;</span><br><span class="line">  pickFirsts = [<span class="string">&#x27;META-INF/LICENSE&#x27;</span>] <span class="comment">// 当有重复文件时，打包会报错。此配置会使用第一个匹配的文件打包进入 apk</span></span><br><span class="line">  merge <span class="string">&#x27;META-INF/LICENSE&#x27;</span> <span class="comment">// 重复文件会合并打包</span></span><br><span class="line">  exclue <span class="string">&#x27;META-INF/LICENSE&#x27;</span> <span class="comment">// 打包时排除匹配文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>sourceSets</code></li>
</ul>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">sourceSets &#123;</span><br><span class="line">  main &#123;</span><br><span class="line">    res.srcDirs <span class="string">&#x27;src/main/res&#x27;</span></span><br><span class="line">    jniLibs.srcDirs = [<span class="string">&#x27;libs&#x27;</span>]</span><br><span class="line">    aidl.srcDirs <span class="string">&#x27;src/main/aidl&#x27;</span></span><br><span class="line">    assets.srcDirs <span class="string">&#x27;src/main/assets&#x27;</span></span><br><span class="line">    java.srcDirs <span class="string">&#x27;src/main/java&#x27;</span></span><br><span class="line">    jni.srcDirs <span class="string">&#x27;src/main/jni&#x27;</span></span><br><span class="line">    renderscript.srcDirs <span class="string">&#x27;src/main/renderscript&#x27;</span></span><br><span class="line">    resources.srcDirs <span class="string">&#x27;src/main/resources&#x27;</span></span><br><span class="line">    manifest.srcFile <span class="string">&#x27;src/main/AndroidManifest.xml&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 除了 main,也可给不同的渠道指定不同的配置</span></span><br><span class="line">  free &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><code>splits</code>: google play 按 CPU&#x2F;屏幕像素密度打包</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">splits &#123;</span><br><span class="line">  abi &#123;</span><br><span class="line">    enable <span class="literal">true</span> <span class="comment">// 开启 abi 分包</span></span><br><span class="line">    universalApk <span class="literal">true</span> <span class="comment">// 是否创建一个包含所有有效动态库的 apk</span></span><br><span class="line">    reset() <span class="comment">// 清空 defaultConfig 配置</span></span><br><span class="line">    include <span class="string">&#x27;x86&#x27;</span>,<span class="string">&#x27;armeabi&#x27;</span> <span class="comment">// 和 defaultConfig 做和集</span></span><br><span class="line">    eclude <span class="string">&#x27;mips&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  density &#123;</span><br><span class="line">    enable <span class="literal">true</span> <span class="comment">// 开启 density 分包</span></span><br><span class="line">    reset() <span class="comment">// 清空默认</span></span><br><span class="line">    include  <span class="string">&#x27;xhdpi&#x27;</span>,<span class="string">&#x27;xxhdpi&#x27;</span> <span class="comment">// 和集</span></span><br><span class="line">    exclude <span class="string">&#x27;mdpi&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  language &#123;</span><br><span class="line">    enable <span class="literal">true</span></span><br><span class="line">    include <span class="string">&#x27;en&#x27;</span>,<span class="string">&#x27;cn&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>variantFilter</code>: 过滤通过 flavor 和 buildType 构建的 apk</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">variantFilter &#123; variant -&gt;</span><br><span class="line">  <span class="keyword">def</span> buildTypeName = variant.buildType.name</span><br><span class="line">  <span class="keyword">def</span> flavorName = variant.flavors.name</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (flavorName.contains(<span class="string">&quot;360&quot;</span>) &amp;&amp; buildTypeName.contains(<span class="string">&quot;debug&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// 不生成匹配的 apk</span></span><br><span class="line">    setIgnore(<span class="literal">true</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>com.android.library</code></li>
</ul>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android.libraryVariants.all &#123; variant -&gt;</span><br><span class="line">  <span class="keyword">def</span> mergedFlavor = variant.getMergedFlavor()</span><br><span class="line">  mergedFlavor.manifestPlaceholers = [<span class="attr">hostName:</span><span class="string">&#x27;www.example.com&#x27;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>kotlin</tag>
        <tag>gradle</tag>
        <tag>构建</tag>
      </tags>
  </entry>
  <entry>
    <title>libgit2 android交叉编译</title>
    <url>/2020/04/25/13/</url>
    <content><![CDATA[<p>libgit2 是一个跨平台、可在自己应用中链接的 git 实现库.</p>
<span id="more"></span>
<p><code>libgit2</code>是一个便携、纯C实现 git 核心功能的依赖库.当前已经实现了多种语言绑定,如 <code>Rugged(Ruby)</code>、<code>LibGit2Sharp(.NET)</code>、<code>pygit2(Python)</code>、<code>NodeGit(Node)</code>等.</p>
<p>git GUI 客户端如 <code>GitKraken</code> 和 <code>gmaster</code>,git 托管平台如 <code>GitHub</code>,<code>GitLab</code>和<code>Azure DevOps</code>都是基于此实现的.每一次<code>merge pull request</code> 都是通过 libgit2 来实现的.</p>
<p>最近 libgit2 刚刚放出 1.0 版本,那么先来个 android 交叉编译吧.</p>
<h4 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h4><pre><code>macos 
NDKr21
</code></pre>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><p>1、下载源码</p>
<pre><code>`git clone git@github.com:libgit2/libgit2.git`
</code></pre>
<p>2、配置 openSSL(可跳过)</p>
<pre><code>因为 libgit2 支持 openSSL,所以先编译 openSSL.
下载源码,configure/make 即可
</code></pre>
<p>3、配置工具链</p>
<ul>
<li><p>在 NDKr21 中,已经将各个架构、各个API的工具预编译好了,不用再如 README 所说(通过 make-standalone-toolchain.sh 脚本来准备了).</p>
</li>
<li><p>在项目根目录(随意) 添加 CMakeLists.android.txt(名称随意).</p>
</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span>(CMAKE_SYSTEM_NAME Linux)</span><br><span class="line"><span class="keyword">SET</span>(CMAKE_SYSTEM_VERSION Android)</span><br><span class="line"><span class="keyword">SET</span>(NDK_HOME /Users/aka/Library/Android/sdk/ndk/<span class="number">21.0</span>.<span class="number">6113669</span>/)</span><br><span class="line"><span class="keyword">SET</span>(OPENSSL_DYHOME /Users/aka/Downloads/source/openssl)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span>(CMAKE_C_COMPILER <span class="variable">$&#123;NDK_HOME&#125;</span>toolchains/llvm/prebuilt/darwin-x86_64/bin/aarch64-linux-android21-clang)</span><br><span class="line"><span class="keyword">SET</span>(CMAKE_CXX_COMPILER <span class="variable">$&#123;NDK_HOME&#125;</span>toolchains/llvm/prebuilt/darwin-x86_64/bin/aarch64-linux-android21-clang++)</span><br><span class="line"><span class="keyword">SET</span>(CMAKE_FIND_ROOT_PATH <span class="variable">$&#123;NDK_HOME&#125;</span>toolchains/llvm/prebuilt/darwin-x86_64/sysroot)</span><br><span class="line"><span class="keyword">SET</span>(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)</span><br><span class="line"><span class="keyword">SET</span>(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)</span><br><span class="line"><span class="keyword">SET</span>(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)</span><br><span class="line"><span class="keyword">SET</span>(OPENSSL_ROOT_DIR <span class="variable">$&#123;OPENSSL_DYHOME&#125;</span>)</span><br><span class="line"><span class="keyword">SET</span>(OPENSSL_INCLUDE_DIR <span class="variable">$&#123;OPENSSL_DYHOME&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">SET</span>(OPENSSL_CRYPTO_LIBRARY <span class="variable">$&#123;OPENSSL_DYHOME&#125;</span>/libcrypto.so)</span><br><span class="line"><span class="keyword">SET</span>(OPENSSL_SSL_LIBRARY <span class="variable">$&#123;OPENSSL_DYHOME&#125;</span>/libssl.so)</span><br><span class="line"><span class="keyword">add_definitions</span>(<span class="string">&quot;--sysroot=$&#123;CMAKE_FIND_ROOT_PATH&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>mkdir build &amp;&amp; cd build</code></li>
<li><code>cmake -DCMAKE_TOOLCHAIN_FILE=../CMakeLists.android.txt</code></li>
<li><code>cmake --build .</code></li>
</ul>
<p>4、大功告成!</p>
<h3 id="约定俗成"><a href="#约定俗成" class="headerlink" title="约定俗成"></a>约定俗成</h3><h4 id="公开-API"><a href="#公开-API" class="headerlink" title="公开 API"></a>公开 API</h4><p>调用函数时遵循以下几点在很大程度上可以少走弯路.</p>
<ul>
<li>属性访问通常会直接返回值(如 <code>int</code> 或 <code>const char *</code>),但如果函数调用失败,那么将返回一个<code>int</code>值,且返回值在参数列表的第一位,跟在此函数正在操作的对象之后,可能也会需要其他的参数</li>
<li>如果一个函数返回值是个对象,那么此函数是个 <code>getter</code> 函数,这个对象的生命周期和它的父对象绑定.如果函数返回值的第一个参数是指针类型的,那么它的生命周期由调用者控制,必要的时候应该被释放.返回的 <code>String</code> 通过 <code>git_buf</code> 代替,以便可以复用和安全释放.</li>
<li>大多数 <code>libgit2</code> 和 I&#x2F;O 相关的操作失败可能是因为从文件系统获取数据导致的各种个样的错误和复杂的原因.</li>
<li><code>Git</code> 系统中的路径之间是以 &#x2F; (0x2F) 分隔的.如果一个函数接受某个磁盘上的路径,那么在 Windows 上就可以使用 \ (0x5C) 作为分隔.</li>
<li>不要混用内存申请.在 <code>libgit2</code> 中如果需要申请内存,通常情况下没有合适的释放函数推荐.请使用针对各自对象类型的释放函数.</li>
</ul>
<h4 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h4><p><code>libgit2</code> 可以通过各种不同的编译器运行在不同的平台上.</p>
<p><code>libgit2</code> 的公开 API 是 <code>ANISI C(c89)</code> 兼容的.</p>
<p><code>libgit2</code> 内部使用 C99 的便携子集-以便最大兼容各种平台(如 MSVC),避免特定 C99 的扩展等.局部变量都是在块的顶部声明,同时避免使用 &#x2F;&#x2F; 注释.</p>
<p>为了提高扩展性,我们在代码内避免使用 <code>#ifdef</code> 语句.通常情况下,这是不可避免的,因为它会导致难以维护,所以我们尽量避免使用这些语句.</p>
<h4 id="和上下文匹配"><a href="#和上下文匹配" class="headerlink" title="和上下文匹配"></a>和上下文匹配</h4><p>如果要从此文档中只提炼一条规则出来,那就是<i style="background:white;color:black">新添加的代码应该和上下文匹配,使得看不出来新旧代码的区别</i>.对我们来说,代码的一致性比括号的位置或使用空格还是 tab 的争论更重要.</p>
<p>我们接受代码重构,但是拒绝仅仅格式化的提交.</p>
<h4 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h4><p>所有导出的类型和函数都是以 <code>git_</code> 开头,所有的 <code>#define</code> 宏都是以 <code>GIT_</code> 开头.<code>libgit2</code> 的 API 通常都是分散在和其头文件对应的函数模块中.模块中的所有函数都应该像这样命名 <code>git_modulename_functionname()（如 git_repository_open()）</code></p>
<p>仅有一个输出参数的函数的入参应命名为 <code>out</code>.多输出函数的入参应命名为 <code>foo_out</code>、<code>bar_out</code> 等.</p>
<p><code>git_oid</code> 类型的参数应该命名为 <code>id</code> 或 <code>foo_id</code>.返回 <code>git_oid</code> 类型的函数参数应命名为 <code>git_foo_id</code>.</p>
<p>如果传入闭包函数,那么同时应提供一个名为 <code>void*</code> 的额外输入参数负载以便在闭包被调用时传入.</p>
<h4 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a>类型定义</h4><p>无论何时都应使用 <code>typedef</code>.如果某个结构体仅是函数指针的集合,那么指针类型是不必单独定义的,但是松散的函数指针类型(此处应值非全函数指针的结构体)应该定义类型.</p>
<h4 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h4><p>所有导出的函数都应如下声明:<br><code>GIT_EXTERN(result_type) git_modulename_functionanme(arg_list);</code></p>
<h4 id="内部消息"><a href="#内部消息" class="headerlink" title="内部消息"></a>内部消息</h4><p>命名模块的函数应遵从两个下划线,如<code>git_odb__read_packed</code>,是半私有的函数.通常应该在 <code>libgit2</code> 内部使用,未来可能会被废弃或者声明发生变化.</p>
<h4 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h4><p>第一个是输出参数.</p>
<p>无论何时,出入的指针参数必须是 <code>const</code>,某些结构体内部通过可变结构来阻止这一特性(如 <code>git_repository 和 git_index</code>).</p>
<p>回调总是使用 <code>void*</code> 负载作为它的最后一个参数,回调指针总是和负载匹配,通常情况下都在参数列表的最后:<br><code>int git_foo(git_repository *repo,git_foo_cb callback,void *payload);</code></p>
<h4 id="内存所属"><a href="#内存所属" class="headerlink" title="内存所属"></a>内存所属</h4><p>谁申请的内存谁负责释放;但某些返回指向某个 buffer 的指针则归其他对象所有.</p>
<h4 id="返回代码"><a href="#返回代码" class="headerlink" title="返回代码"></a>返回代码</h4><p>大多数公开 API 都应返回 <code>int</code> 类型的错误码.和大多数 C 函数库类似,0 表示成功,负数表示失败.</p>
<p>某些绑定会把错误码转为精确的异常类型.所以返回一个语义明确的错误码hin重要.查看<code>include/git2/errors.h</code>了解更多错误码.</p>
<p>在你自己的实现中,使用 <code>git_error_set()</code> 给调用者提供更多的额外信息.</p>
<p>如果 <code>libgit2</code> 函数内部调用另一个函数报错,但是错误没有向上抛,使用 <code>git_error_clear()</code> 来阻止调用者之后获取到该错误信息.</p>
<h4 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h4><p>大多数公开的类型都应该是不透明的,如:<code>typedef struct git_odb git_odb;</code></p>
<p>在库函数声明时就返回一个新实例,而不是在应用里.这样有助于不改动客户端代码增加(压缩)大小.</p>
<p>为了保证 ABI 兼容性,在所有全局可见的结构体中引入 <code>int version</code> 属性,同时在初始化结构体时赋予最新的值.只要结构体发生变化,则增加 <code>latest</code> 值,并且此值仅在结构体末尾声明.</p>
<h4 id="可选结构体"><a href="#可选结构体" class="headerlink" title="可选结构体"></a>可选结构体</h4><p>如果某个函数参数列表过多,那么可以把他们封装为一个可选的结构体.确保他们的全局可见的,包含 version 属性,提供初始化常量或构造方法. 使用起来就hin简单了.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git_foo_option opts = GIT_FOO_OPTIONS_INIT;</span><br><span class="line">opts.baz = BAZ_OPTION_ONE;</span><br><span class="line">git_foo(&amp;opts);</span><br></pre></td></tr></table></figure>
<h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><p>定义所有的枚举类型.如果每个选项都是独立的,那么使用枚举类型作为传入参数.如果是位移操作后的标记,使用 <code>unsigned int 或 uint32_t</code> 或其他合适的类型.</p>
<h4 id="代码布局"><a href="#代码布局" class="headerlink" title="代码布局"></a>代码布局</h4><p>尽量保持一行最多80个字符.这个要求不是很严格,很明显超过 80 字符就很不好看了.按照惯例对代码对齐,公开函数声明可以使用不同的风格.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/** All on one line is okay if it fits */</span><br><span class="line">GIT_EXTERN(int) git_foo_simple(git_oid *id);</span><br><span class="line"></span><br><span class="line">/** Otherwise one argument per line is a good next step */</span><br><span class="line">GIT_EXTERN(int) git_foo_id(</span><br><span class="line">	git_oid **out,</span><br><span class="line">	int a,</span><br><span class="line">	int b);</span><br></pre></td></tr></table></figure>
<p>使用 tab 缩紧,8 位最佳.</p>
<p>避免多余空格,新行使用 Unix 风格(如仓库没有 CRLF-如果是在 windows 机器码字,那么设置 <code>core.autocrlf</code> 为 true)</p>
<h4 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h4><p>所有的注释都应以 Doxygen 的 <code>javadoc</code> 风格作为公开 API 函数的格式化风格.尽量对每个参数注释,如果参数列表改变,那么随手更新.</p>
<h4 id="公开头模版"><a href="#公开头模版" class="headerlink" title="公开头模版"></a>公开头模版</h4><p>如果创建新的公开头文件使用如下作为头模版:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifndef INCLUDE_git_$&#123;filename&#125;_h__</span><br><span class="line">#define INCLUDE_git_$&#123;filename&#125;_h__</span><br><span class="line"></span><br><span class="line">#include &quot;git/common.h&quot;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @file git/$&#123;filename&#125;.h</span><br><span class="line"> * @brief Git some description</span><br><span class="line"> * @defgroup git_$&#123;filename&#125; some description routines</span><br><span class="line"> * @ingroup Git</span><br><span class="line"> * @&#123;</span><br><span class="line"> */</span><br><span class="line">GIT_BEGIN_DECL</span><br><span class="line"></span><br><span class="line">/* ... definitions ... */</span><br><span class="line"></span><br><span class="line">/** @&#125; */</span><br><span class="line">GIT_END_DECL</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<h4 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h4><p>所有的内联函数都应如下声明</p>
<p><code>GIT_INLINE(result_type) git_modulename_functionname(arg_list); </code></p>
<p>为了保证 ANSI C 兼容,<code>GIT_INLINE 或 inline</code> 都不应该出现在公开 API 头文件.</p>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p><code>libgit2</code> 使用 <code>clar</code> 测试框架.</p>
<p>Balahbalah…J</p>
]]></content>
  </entry>
  <entry>
    <title>macOS Monterey V12 如何共享 sambda</title>
    <url>/2023/02/25/57/</url>
    <content><![CDATA[<p>关于如何在 macOS Monterey 12 上开启 smdba 文件共享的步骤</p>
<span id="more"></span>


<p>1、添加共享用户</p>
<p>打开用户与群组, 点击 + 新建用户, 新账户选择: 仅限共享<br><img src="http://picbed.dang8080.cn/202302252337775.png"/></p>
<p>2、共享</p>
<p>进入设置 -&gt; 共享, 1、打开文件共享选项 2、添加共享文件夹 3、添加刚才新建的共享用户</p>
<img src="http://picbed.dang8080.cn/202302252347284.png"/>

<p>接下来点击选项，勾选共享用户，即可通过 smdba 和共享用户访问共享文件夹了.</p>
<img src="http://picbed.dang8080.cn/202302252348813.png"/>]]></content>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx(docker) 如何更新 letsencrypt 证书</title>
    <url>/2023/02/25/16/</url>
    <content><![CDATA[<p>当前的个人主页是运行在 docker nginx 上的。为了安全起见，把所有的 http 请求已经转发到了 https, 免费的 SSL 证书过期了，所以使用了 letsencrypt 的免费证书来签名。但是它默认的是 3 个月有效期，所以必须得定期去更新。否则就会导致 nginx 服务不可用了。以下为如何在 docker 上更新 letsencrypt 证书.</p>
<span id="more"></span>

<h3 id="部署架构"><a href="#部署架构" class="headerlink" title="部署架构"></a>部署架构</h3><p>众所周知，docker 的命令配置大都很长，一般是通过shell 脚本或者 docker-compose.yaml 文件来进行管理的。而我采用的就是后者。</p>
<p>如果一台主机上运行了多个 docker 容器，那么这个 docker-compose.yaml 就可能会很大。每次调用 docker-compose up&#x2F;down 时都会导致所有的容器被销毁重建。所以这里采用了 sidecar 的模式，既可以保证各个容器的配置文件各自保存，又能保证容器之间可以互相访问。</p>
<p>以下以 nginx 和 couchdb 为例.</p>
<p>couchdb&#x2F;docker-compose.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.6&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">couchdb:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">couchdb</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">couchdb</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./config/local.ini:/opt/couchdb/etc/local.ini&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./data:/opt/couchdb/data&quot;</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;5984:5984&#x27;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">default</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">main</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">    <span class="attr">main:</span></span><br><span class="line">      <span class="attr">external:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>这里新建了一个名为 main 的 networks, 属性 <code>external</code> 设置为 true, 同时设置容器的 networks 为 default + main, 后面只要其他容器都在 main 这个网络内，都是可以直接 localhost 或者端口互相访问的。</p>
<p>nginx&#x2F;docker-compose.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.6&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">nginx:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">&quot;home&quot;</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;80:80&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;443:443&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./nginx/html:/usr/share/nginx/html:rw</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./nginx/etc/nginx:/etc/nginx:rw</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./certbot/letsencrypt/live:/etc/letsencrypt/live:rw</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./certbot/letsencrypt/archive:/etc/letsencrypt/archive:rw</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./certbot/dhparam-2048.pem:/etc/letsencrypt/dhparam-2048.pem:rw</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">default</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">main</span></span><br><span class="line">    <span class="attr">external_links:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">obsidian_couchdb</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">   <span class="attr">main:</span></span><br><span class="line">     <span class="attr">external:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>那么在 nginx 中就可以直接访问 couchdb 了.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location /couchdb &#123;</span><br><span class="line">  rewrite /couchdb(.*) $1 break;</span><br><span class="line">  proxy_pass http://couchdb:5984;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://picbed.dang8080.cn/nginx-letsencrypt.png" alt="docker sidecar arch"></p>
<h3 id="使用-letsencrypt-生成证书"><a href="#使用-letsencrypt-生成证书" class="headerlink" title="使用 letsencrypt 生成证书"></a>使用 letsencrypt 生成证书</h3><p>首先看下 letsencrypt 的 docker-compose</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.6&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">certbot:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">certbot/certbot:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">home_certbot</span></span><br><span class="line">    <span class="comment">#ports:</span></span><br><span class="line">    <span class="comment">#  - 80:80</span></span><br><span class="line">    <span class="comment">#  - 443:443</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./letsencrypt:/etc/letsencrypt:rw</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./log:/var/log:rw</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">certonly</span> <span class="string">-n</span> <span class="string">--webroot</span> <span class="string">-w=/etc/letsencrypt</span> <span class="string">--email</span> <span class="string">dang8080@qq.com</span> <span class="string">-d</span> <span class="string">dang8080.cn</span>  <span class="string">--agree-tos</span> <span class="string">--force-renewal</span></span><br><span class="line">    <span class="comment"># command: auth --standalone -m dang8080@qq.com --agree-tos -d dang8080.cn # 自动开启一个web服务，且外部能访问</span></span><br></pre></td></tr></table></figure>

<p>letsencrypt 提供了 certbot 命令行工具来生成 SSL 证书. 这里同样使用 docker-compose.</p>
<p>certbot 运行时，需要本机提供一个 http 服务，即外部能访问的 http:&#x2F;&#x2F;[本机域名]&#x2F;.well-known&#x2F;acme-challenge&#x2F;[随机字符串] http 服务。本机域名就是要申请 SSL 证书的域名。</p>
<p>这里的 http 服务有两个选择:</p>
<p>1、如果已经有了 nginx&#x2F;apache 等服务，那么使用它就行，不过需要配置路由和文件映射(因为是运行在 docker 中)</p>
<p>2、使用 certbot 提供的 http 服务</p>
<p>这里我选择了方案1, nginx 需要添加一条新 location 满足 letsencrypt 访问的需求</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">	listen 80;</span><br><span class="line">	listen [::]:80;</span><br><span class="line">	server_name dang8080.cn localhost;</span><br><span class="line">	root /usr/shar/nginx/html;</span><br><span class="line"></span><br><span class="line">	location / &#123;</span><br><span class="line">		root /usr/share/nginx/html;</span><br><span class="line">		return 301 https://dang8080.cn$request_uri;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	location ^~ /.well-known/acme-challenge/ &#123;</span><br><span class="line">		allow all;</span><br><span class="line">		default_type &quot;text/plain&quot;;</span><br><span class="line">		root /var/www/dang8080.cn;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意: <code>/.well-known/acme-challenge 的 root 必须是 /var/www/dang8080.cn 否则会报 404.</code></p>
<p>certbot 使用的参数</p>
<blockquote>
<p>–webroot -w 指定生成的 ssl 证书目录，注意这里是在 docker 中运行的，所以需要将其映射到本地文件系统</p>
</blockquote>
<blockquote>
<p>–agree-tos 跳过 cli 中的交互式问询</p>
</blockquote>
<blockquote>
<p>–force-renewal 如果指定目录有证书还没过期，那么也要强制重新更新</p>
</blockquote>
<blockquote>
<p>–standalone 就是 certbot 开启一个新的 http 服务.</p>
</blockquote>
<p>执行完后就能在本地看到生成的 ssl 证书了</p>
<p><img src="http://picbed.dang8080.cn/202302261012588.png"></p>
<h3 id="配置-nginx"><a href="#配置-nginx" class="headerlink" title="配置 nginx"></a>配置 nginx</h3><p>因为 nginx 运行在 docker 中，而生成的 ssl 证书在其他目录，所以需要将 ssl 证书目录也映射到 ngixn 容器中.</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">./certbot/letsencrypt/live:/etc/letsencrypt/live:rw</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">./certbot/letsencrypt/archive:/etc/letsencrypt/archive:rw</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">./certbot/dhparam-2048.pem:/etc/letsencrypt/dhparam-2048.pem:rw</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要说明的是：letsencrypt 生成的 live 目录证书会软链接到 archive 目录，而 docker 对软链接支持不友好，所以需要同时映射 archive 目录和 live 目录</p>
</blockquote>
<blockquote>
<p>同时为了 ssl 安全，使用 2048位的 DH 参数. 生成方式 <code>openssl dhparam -out dhparam-2048.pem 2048</code></p>
</blockquote>
<p>https.conf</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssl_certificate /etc/letsencrypt/live/dang8080.cn/fullchain.pem;</span><br><span class="line">ssl_certificate_key /etc/letsencrypt/live/dang8080.cn/privkey.pem;</span><br><span class="line">ssl_trusted_certificate /etc/letsencrypt/live/dang8080.cn/chain.pem;</span><br><span class="line"></span><br><span class="line">ssl_dhparam /etc/letsencrypt/dhparam-2048.pem;</span><br></pre></td></tr></table></figure>

<h3 id="定期更新"><a href="#定期更新" class="headerlink" title="定期更新"></a>定期更新</h3><p>前面提到，letsencrypt 生成的 ssl 证书一般只有3个月有效期，所以得定期更新.这里使用 crontab 更新就行.</p>
<p>rewnew.sh</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">! /usr/bin/env sh</span></span><br><span class="line"></span><br><span class="line">pushd ~/[]/certbot &amp;&amp;</span><br><span class="line">sudo docker-compose up -d &amp;&amp;</span><br><span class="line">sudo docker kill --signal=HUP [] &amp;&amp;</span><br><span class="line">sudo docker-compose down</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/usr/bin/env sh</span></span><br><span class="line"></span><br><span class="line">sudo docker run -it --rm \</span><br><span class="line">  -v /home/[]certbot/letsencrypt:/etc/letsencrypt \</span><br><span class="line">  -v /home/[]certbot/log:/var/log \</span><br><span class="line">  certbot/certbot \</span><br><span class="line">  renew --webroot -w /etc/letsencrypt --quiet &amp;&amp; sudo docker kill --signal=HUP []</span><br></pre></td></tr></table></figure>

<p>编辑 crontab: <code>crontab -e</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0 1 * * 0 ~/homepage/certbot/renew.sh</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>parcel + react</title>
    <url>/2023/02/26/59/</url>
    <content><![CDATA[<p>相比较 create-react-app 这么笨重的武器，parcel 是一个开箱即用的开发打包工具，在小项目、简单测试时用起来就非常得心应手了。</p>
<span id="more"></span>

<h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;devDependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;@babel/core&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^7.21.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;@babel/preset-env&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^7.20.2&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;@babel/preset-react&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^7.18.6&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;@types/react&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^18.0.28&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;@types/react-dom&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^18.0.11&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;babel-plugin-transform-react-jsx-source&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^6.22.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;parcel&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^2.8.3&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;react&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^18.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;react-dom&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^18.2.0&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>

<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;dev&quot;</span><span class="punctuation">:</span> <span class="string">&quot;parcel src/index.html&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>1、如果报错 <code>@parcel/core: Failed to resolve &#39;process&#39; from &#39;./node_modules/....&#39;</code>, 那么在 package.json 中添加以下内容即可</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;alias&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;process&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>2、tsx 文件中的 jsx 语法提示报错</p>
<blockquote>
<p>在文件头导入 react 即可, <code>import React from &#39;react&#39;</code></p>
</blockquote>
<p>3、如果使用 react-scripts 打包项目，部署时文件相对路径可能不太对</p>
<p>在 <code>package.json</code> 中添加 <code>homepage</code>, 值即为服务端部署域名</p>
]]></content>
  </entry>
  <entry>
    <title>rust android 交叉编译</title>
    <url>/2022/03/03/31/</url>
    <content><![CDATA[<p>记录下使用 rust 绑定 libgit2 动态库进行 安卓交叉编译时的过程。</p>
<span id="more"></span>

<h1 id="为-libgit2-生成-rust-binding"><a href="#为-libgit2-生成-rust-binding" class="headerlink" title="为 libgit2 生成 rust binding"></a>为 libgit2 生成 rust binding</h1><p>如前所述，我们生成好了 libgit2 的安卓动态库，如果需要 rust 调用安卓动态库的话，不但手写很麻烦，还需要用到 unsafe, 可能会出现各种问题。<br>所以我们采用官方提供的 bindgen 来为我们自动生成 binding.</p>
<p>1、新建 cargo 项目，并将 libgit2 头文件复制进去</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- deps</span><br><span class="line">  - libgit2</span><br><span class="line">    - include</span><br><span class="line">- src</span><br><span class="line">  build.rs</span><br><span class="line">  Cargo.toml</span><br></pre></td></tr></table></figure>

<p>2、添加 bindgen 依赖, 同时启用 build.rs</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[package]</span></span><br><span class="line">...</span><br><span class="line"><span class="attr">build</span>=<span class="string">&quot;build.rs</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[build-dependencies]</span></span><br><span class="line"><span class="string">bindgen = &quot;</span><span class="number">0.59</span>.<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>3、编辑 build.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> bindgen;</span><br><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"><span class="keyword">use</span> std::path::PathBuf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">header_path</span> = <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;/deps/libgit2/include&quot;</span>, env::<span class="title function_ invoke__">current_dir</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">bindings</span> = bindgen::Builder::<span class="title function_ invoke__">default</span>()</span><br><span class="line">        .<span class="title function_ invoke__">header</span>(<span class="string">&quot;deps/libgit2/include/git2.h&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">clang_arg</span>(<span class="built_in">format!</span>(<span class="string">&quot;-I&#123;&#125;&quot;</span>, git2_header_path))</span><br><span class="line">        .<span class="title function_ invoke__">clang_arg</span>(<span class="built_in">format!</span>(<span class="string">&quot;--sysroot=&#123;&#125;/toolchains/llvm/prebuilt/darwin-x86_64/sysroot&quot;</span>, env::<span class="title function_ invoke__">var</span>(<span class="string">&quot;ANDROID_NDK&quot;</span>)))</span><br><span class="line">        .<span class="title function_ invoke__">clang_arg</span>(<span class="string">&quot;--target=armv7-linux-androideabi&quot;</span>) <span class="comment">// 指定 arm 平台的编译，否则编译出来的 header 有问题</span></span><br><span class="line">        .<span class="title function_ invoke__">disable_header_comment</span>()</span><br><span class="line">        .<span class="title function_ invoke__">generate_comments</span>(<span class="literal">false</span>)</span><br><span class="line">        .<span class="title function_ invoke__">parse_callbacks</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(bindgen::CargoCallbacks))</span><br><span class="line">        .<span class="title function_ invoke__">generate</span>()</span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Unable to generate bindings&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">out_path</span> = PathBuf::<span class="title function_ invoke__">from</span>(env::<span class="title function_ invoke__">current_dir</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;can&#x27;t get current dir&quot;</span>).<span class="title function_ invoke__">join</span>(<span class="string">&quot;src&quot;</span>));</span><br><span class="line">    bindings</span><br><span class="line">        .<span class="title function_ invoke__">write_to_file</span>(out_path.<span class="title function_ invoke__">join</span>(<span class="string">&quot;lib.rs&quot;</span>))</span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Couldn&#x27;t write bindings!&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;cargo:warning=out:&#123;:?&#125;&quot;</span>, out_path.<span class="title function_ invoke__">clone</span>().<span class="title function_ invoke__">join</span>(<span class="string">&quot;bindings.rs&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、运行 cargo build 即可在 src 目录下生成 <code>lib.rs</code> binding 文件了</p>
<h1 id="用-rust-生成-jni-动态库"><a href="#用-rust-生成-jni-动态库" class="headerlink" title="用 rust 生成 jni 动态库"></a>用 rust 生成 jni 动态库</h1><p>1、首先新建 rust 项目</p>
<p><code>cargo new --lib git2-sys</code></p>
<p>2、将编译好的 libgit2 安卓动态库复制到项目</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-deps</span><br><span class="line">  - libgit2</span><br><span class="line">    - include</span><br><span class="line">    - lib</span><br><span class="line">      - android-arm64</span><br><span class="line">      - android-x86_64</span><br></pre></td></tr></table></figure>

<p>3、配置 rustup 安卓交叉编译工具链</p>
<p>可以使用 rustup target list 列出 rustup 当前支持的交叉编译工具链</p>
<p><code>rustup target add aarch64-linux-android x86_64-linux-android</code></p>
<p>4、 配置下 ar linker</p>
<p>在项目根目录新建 .cargo 目录, 配置文件为 config.toml</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[target.aarch64-linux-android]</span></span><br><span class="line"><span class="attr">ar</span> = <span class="string">&quot;/Users/shuttle/Library/Android/sdk/ndk/24.0.7956693/toolchains/llvm/prebuilt/darwin-x86_64/bin/aarch64-linux-android32-clang&quot;</span></span><br><span class="line"><span class="attr">linker</span> = <span class="string">&quot;/Users/shuttle/Library/Android/sdk/ndk/24.0.7956693/toolchains/llvm/prebuilt/darwin-x86_64/bin/aarch64-linux-android32-clang&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[target.armv7-linux-androideabi]</span></span><br><span class="line"><span class="attr">ar</span> = <span class="string">&quot;/Users/shuttle/Library/Android/sdk/ndk/24.0.7956693/toolchains/llvm/prebuilt/darwin-x86_64/bin/armv7a-linux-androideabi32-clang&quot;</span></span><br><span class="line"><span class="attr">linker</span> = <span class="string">&quot;/Users/shuttle/Library/Android/sdk/ndk/24.0.7956693/toolchains/llvm/prebuilt/darwin-x86_64/bin/armv7a-linux-androideabi32-clang&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[target.i686-linux-android]</span></span><br><span class="line"><span class="attr">ar</span> = <span class="string">&quot;/Users/shuttle/Library/Android/sdk/ndk/24.0.7956693/toolchains/llvm/prebuilt/darwin-x86_64/bin/i686-linux-android32-clang&quot;</span></span><br><span class="line"><span class="attr">linker</span> = <span class="string">&quot;/Users/shuttle/Library/Android/sdk/ndk/24.0.7956693/toolchains/llvm/prebuilt/darwin-x86_64/bin/i686-linux-android32-clang&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[target.x86_64-linux-android]</span></span><br><span class="line"><span class="attr">ar</span> = <span class="string">&quot;/Users/shuttle/Library/Android/sdk/ndk/24.0.7956693/toolchains/llvm/prebuilt/darwin-x86_64/bin/x86_64-linux-android32-clang&quot;</span></span><br><span class="line"><span class="attr">linker</span> = <span class="string">&quot;/Users/shuttle/Library/Android/sdk/ndk/24.0.7956693/toolchains/llvm/prebuilt/darwin-x86_64/bin/x86_64-linux-android32-clang&quot;</span></span><br></pre></td></tr></table></figure>

<p>5、配置项目生成动态库</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="section">[lib]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;tano&quot;</span></span><br><span class="line"><span class="attr">crate-type</span> = [<span class="string">&quot;staticlib&quot;</span>, <span class="string">&quot;cdylib&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>6、开始编译</p>
<p>如果直接运行 <code>cargo b --target x86_64-linux-android</code> 会报错 <code>unable to find library -lgcc</code>, 原因是 NDK r20+ 后移除了 gcc 库, 代替为 unwind 库。此时需要做特殊处理.</p>
<p>6.1 gcc 修复</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- deps</span><br><span class="line">  - gcc</span><br><span class="line">    libgcc.a</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>新建 <code>libgcc.a</code> 文件，内容为 <code>INPUT(-lunwind)</code></p>
<p>6.2 命令行编译 </p>
<p><code>cargo rustc --target x86_64-linux-android -- -L /Users/shuttle/Project/Android/Ide/git2-sys/deps/gcc</code></p>
<p>此时可以通过 -L 来配置执行</p>
<p>6.3 build.rs 配置</p>
<p>如果不想每次都在命令行后指定 -L 参数，可以使用 build.rs 来编译</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[package]</span></span><br><span class="line">...</span><br><span class="line"><span class="attr">build</span> = <span class="string">&quot;build.rs&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// CARGO_CFG_TARGET_OS</span></span><br><span class="line">  <span class="keyword">let</span> <span class="variable">TARGET</span> = env::<span class="title function_ invoke__">var</span>(<span class="string">&quot;TARGET&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">target</span> = <span class="keyword">if</span> TARGET.<span class="title function_ invoke__">contains</span>(<span class="string">&quot;x86_64-linux-android&quot;</span>) &#123;</span><br><span class="line">    <span class="string">&quot;android_x86-64&quot;</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> TARGET.<span class="title function_ invoke__">contains</span>(<span class="string">&quot;aarch64-linux-android&quot;</span>) &#123;</span><br><span class="line">    <span class="string">&quot;android_arm64&quot;</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="string">&quot;&quot;</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;cargo:rustc-link-search=native=./deps/libgit2/lib/&#123;&#125;&quot;</span>, target);</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;cargo:rustc-link-search=native=./deps/openssl/lib/&#123;&#125;&quot;</span>, target);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;cargo:rustc-link-lib=dylib=git2&quot;</span>);</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;cargo:rustc-link-lib=dylib=crypto&quot;</span>);</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;cargo:rustc-link-lib=dylib=ssl&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;cargo:rustc-flags=-L./deps/gcc&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7.1、接下来执行 <code>cargo b --target x86_64-linux-android</code> 即可<br>7.2、也可以配置 Makefile.toml 使用 cargo-make 工具简化命令行运行输入</p>
<p>首先安装 cargo-make 工具, <code>cargo install cargo-make</code></p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[tasks.a_arm64]</span></span><br><span class="line"><span class="attr">command</span> = <span class="string">&quot;cargo&quot;</span></span><br><span class="line"><span class="attr">args</span> = [<span class="string">&quot;b&quot;</span>, <span class="string">&quot;--target&quot;</span>, <span class="string">&quot;aarch64-linux-android&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="section">[tasks.a_x64]</span></span><br><span class="line"><span class="attr">command</span> = <span class="string">&quot;cargo&quot;</span></span><br><span class="line"><span class="attr">args</span> = [<span class="string">&quot;b&quot;</span>, <span class="string">&quot;--target&quot;</span>, <span class="string">&quot;x86_64-linux-android&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>然后执行 <code>cargo make a_arm64</code> 或者 <code>makers a_arm64</code> 即可</p>
<h1 id="rust-jni-代码（动态加载方式）"><a href="#rust-jni-代码（动态加载方式）" class="headerlink" title="rust jni 代码（动态加载方式）"></a>rust jni 代码（动态加载方式）</h1><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> core::panic;</span><br><span class="line"><span class="keyword">use</span> jni::&#123;</span><br><span class="line">    descriptors::Desc,</span><br><span class="line">    objects::&#123;GlobalRef, JClass, JMethodID&#125;,</span><br><span class="line">    strings::JNIString,</span><br><span class="line">    sys::&#123;jclass, jint, JNI_VERSION_1_6&#125;,</span><br><span class="line">    JNIEnv, JavaVM, NativeMethod,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">use</span> std::ffi::CString;</span><br><span class="line"><span class="keyword">use</span> std::sync::Once;</span><br><span class="line"><span class="keyword">use</span> std::&#123;os::raw::c_void, panic::catch_unwind&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> INVAL_JNI_VERSION: jint = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> INIT: Once = Once::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// JNI 动态加载的入口</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[allow(non_snake_case)]</span></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">&quot;system&quot;</span> <span class="keyword">fn</span> <span class="title function_">JNI_OnLoad</span>(vm: JavaVM, _: *<span class="keyword">mut</span> c_void) <span class="punctuation">-&gt;</span> jint &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">env</span> = vm.<span class="title function_ invoke__">get_env</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Cannot get reference to the JNIEnv&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">catch_unwind</span>(|| &#123;</span><br><span class="line">        <span class="title function_ invoke__">prepare</span>(&amp;env);</span><br><span class="line">        JNI_VERSION_1_6</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_ invoke__">unwrap_or</span>(INVAL_JNI_VERSION)</span><br><span class="line">    <span class="comment">// 如果使用 JNI_VERSION_1_8 会报错</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">pub</span>(<span class="keyword">crate</span>) <span class="keyword">fn</span> <span class="title function_">prepare</span>(env: &amp;JNIEnv) &#123;</span><br><span class="line">    INIT.<span class="title function_ invoke__">call_once</span>(|| <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="comment">// 在这里动态注册就行，不用写那么多冗余函数</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">host_jclass</span>: GlobalRef = <span class="title function_ invoke__">get_class</span>(env, <span class="string">&quot;io/shuttle/coder/MainActivity&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">native_methods</span> = [NativeMethod &#123;</span><br><span class="line">            name: <span class="string">&quot;hello&quot;</span>.<span class="title function_ invoke__">into</span>(),</span><br><span class="line">            sig: <span class="string">&quot;()Ljava/lang/String;&quot;</span>.<span class="title function_ invoke__">into</span>(),</span><br><span class="line">            fn_ptr: hello <span class="keyword">as</span> *<span class="keyword">const</span> c_void <span class="keyword">as</span> *<span class="keyword">mut</span> c_void,</span><br><span class="line">        &#125;];</span><br><span class="line">        env.<span class="title function_ invoke__">register_native_methods</span>(&amp;host_jclass, &amp;native_methods);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 类方法</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">hello</span>(env: JNIEnv, _: JClass) <span class="punctuation">-&gt;</span> jclass &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">output</span> = env</span><br><span class="line">        .<span class="title function_ invoke__">new_string</span>(<span class="string">&quot;from rust string!!!&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Couldn&#x27;t create java string!&quot;</span>);</span><br><span class="line">    output.<span class="title function_ invoke__">into_inner</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 静态方法</span></span><br><span class="line"><span class="comment">// env: JNIEnv, object: JObject</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">get_class</span>(env: &amp;JNIEnv, class: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;GlobalRef&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">class</span> = env</span><br><span class="line">        .<span class="title function_ invoke__">find_class</span>(class)</span><br><span class="line">        .<span class="title function_ invoke__">unwrap_or_else</span>(|_| <span class="built_in">panic!</span>(<span class="string">&quot;Class not found: &#123;&#125;&quot;</span>, class));</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(env.<span class="title function_ invoke__">new_global_ref</span>(class).<span class="title function_ invoke__">unwrap</span>())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">get_method_id</span>(env: &amp;JNIEnv, class: &amp;<span class="type">str</span>, name: &amp;<span class="type">str</span>, sig: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;JMethodID&lt;<span class="symbol">&#x27;static</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">method_id</span> = env</span><br><span class="line">        .<span class="title function_ invoke__">get_method_id</span>(class, name, sig)</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(|mid| mid.<span class="title function_ invoke__">into_inner</span>().<span class="title function_ invoke__">into</span>())</span><br><span class="line">        .<span class="title function_ invoke__">unwrap_or_else</span>(|_| &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(</span><br><span class="line">                <span class="string">&quot;Method &#123;&#125; with signature &#123;&#125; of class &#123;&#125; not found&quot;</span>,</span><br><span class="line">                name, sig, class</span><br><span class="line">            )</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(method_id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="生成-kotlin-文件-jni-头文件的函数签名方式"><a href="#生成-kotlin-文件-jni-头文件的函数签名方式" class="headerlink" title="生成 kotlin 文件 jni 头文件的函数签名方式"></a>生成 kotlin 文件 jni 头文件的函数签名方式</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">➜  Coder ./gradlew -v </span><br><span class="line"></span><br><span class="line">------------------------------------------------------------</span><br><span class="line">Gradle 7.4</span><br><span class="line">------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">Build time:   2022-02-08 09:58:38 UTC</span><br><span class="line">Revision:     f0d9291c04b90b59445041eaa75b2ee744162586</span><br><span class="line"></span><br><span class="line">Kotlin:       1.5.31</span><br><span class="line">Groovy:       3.0.9</span><br><span class="line">Ant:          Apache Ant(TM) version 1.10.11 compiled on July 10 2021</span><br><span class="line">JVM:          17.0.1 (Homebrew 17.0.1+0)</span><br><span class="line">OS:           Mac OS X 12.2.1 x86_64</span><br></pre></td></tr></table></figure>
<p>进入 <code>build/tmp/kotlin-classes/debug/io/shuttle/coder</code> 目录, 可以看到其下有两个 class 文件 <code>MainActivity</code> 和 <code>MainActivityKt.class</code></p>
<p>执行 <code>javap -s p MainActivity</code> 就可以看到对应的 jni 函数签名了.</p>
]]></content>
  </entry>
  <entry>
    <title>rust 中的字符串</title>
    <url>/2022/03/26/03/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://betterprogramming.pub/strings-in-rust-28c08a2d3130">Exploring Strings in Rust</a></p>
</blockquote>
<span id="more"></span>

<p>计算机如何存储解析字符序列的</p>
<ul>
<li>计算机按字节（8位）顺序存储</li>
<li>字节可以代表任意对象。只不过我们可以把某些字节转化为人可理解的对象。这也就是 ASCII &#x2F; Unicode 码表的功能.</li>
<li>字符串就是一系列可以通过码表进行解析的字节序列. 在 rust 中我们常用 <code>String</code>,<code>str</code>,<code>&amp;str</code>,<code>&amp;String</code>,<code>Box&lt;str&gt;</code>,<code>Box&lt;&amp;str&gt;</code> 等实现。</li>
</ul>
<p>C 语言中是这样处理字符串的.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> <span class="built_in">string</span>[] = <span class="string">&quot;banana&quot;</span>; <span class="comment">// c 在末尾添加 `\0`</span></span><br><span class="line"><span class="type">char</span> long_mostly_empty_string[<span class="number">42</span>] = <span class="string">&quot;banana&quot;</span>; <span class="comment">// c 在末尾添加 `\0`</span></span><br><span class="line"><span class="type">char</span> just_a_different_initialization[] = &#123;<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;; <span class="comment">// 必须明确添加 \0</span></span><br></pre></td></tr></table></figure>

<p>rust 不使用 null-terminated 字符串主要还是性能优化考量。</p>
<h3 id="str"><a href="#str" class="headerlink" title="str"></a>str</h3><p>C 的字符串内部没有强制编码类型。内部只是以 null terminator 结尾的字节序列. JS 使用 UTF-16 编码字符串，而 Rust 使用 UTF-8 编码字符串。</p>
<p>rust 中最常见的就是字符串切片： <code>&amp;str, &amp;&#39;static str, &amp;&#39;a str</code>.</p>
<p>rust 中的切片最终都会落脚到动态大小类型 (DST).也就是他们实现了 <code>!Sized</code> trait 或者没有实现 <code>Sized</code> trait</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">string</span>: <span class="type">Box</span>&lt;<span class="type">str</span>&gt; = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(*<span class="string">&quot;akaka&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>此处是无法获取动态类型大小的，因为解引用需要获取当前所指向的数据的所有权。</p>
<p>引用就是一个指针的大小（usize） <code>std::mem::size_of::&lt;&amp;str&gt;()</code></p>
]]></content>
  </entry>
  <entry>
    <title>teamcity自动化更新hexo博客</title>
    <url>/2019/03/09/22/</url>
    <content><![CDATA[<p>hexo deploy</p>
<span id="more"></span>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在知乎找到了一个更好的方法: [原文](使用 hexo，如果换了电脑怎么更新博客？ - CrazyMilk 的回答 - 知乎<br><a href="https://www.zhihu.com/question/21193762/answer/79109280">https://www.zhihu.com/question/21193762/answer/79109280</a>)<br>在这里我整理一下:</p>
<ul>
<li>创建仓库 xxx.github.io.</li>
<li>创建两个分支: master&#x2F;hexo.(可在 github 网页或本地创建)</li>
<li><code>git clone git@github.com:xxx/xxx.github.io.git</code></li>
<li>如果没有在网页创建分支,可以在此处创建.<code>git checkout -b master; git checkout -b hexo</code></li>
<li>接下来执行 <code>npm install hexo; hexo init; npm i; npm i hexo-deployer-git</code>,此处在 <code>hexo</code> 分支操作</li>
<li>修改 _config.yml 的 deploy 参数,此处在 <code>master</code> 分支操作.</li>
<li>我使用了<code>hexo-next-theme</code>,从 git 上下载后,进入 <code>themes/next</code> 执行 <code>git submodule init</code>,将 <code>next</code> 主题关联,此处在 <code>hexo</code> 分支操作</li>
<li><code>git add .; git commit -m &quot;blahblahblah&quot;; git push origin hexo;</code> 提交网站相关文件.</li>
<li><code>hexo g -d</code> 生成网站并部署到 <code>github</code>.</li>
</ul>
<h3 id="将-CNAME-图片等文件放入-source-目录下-可保证推送到-github-不会被删除"><a href="#将-CNAME-图片等文件放入-source-目录下-可保证推送到-github-不会被删除" class="headerlink" title="将 CNAME,图片等文件放入 source 目录下,可保证推送到 github 不会被删除."></a>将 CNAME,图片等文件放入 <code>source</code> 目录下,可保证推送到 github 不会被删除.</h3><h1 id="⚠️-👇-胡扯-观看请谨慎"><a href="#⚠️-👇-胡扯-观看请谨慎" class="headerlink" title="⚠️ 👇 胡扯,观看请谨慎!!!"></a>⚠️ 👇 胡扯,观看请谨慎!!!</h1><p><code>TeamCity</code> 是 <code>Jetbrains</code> 公司出品的持续化集成工具，类似<code>Jenkins</code>,界面更加现代化，功能更强大,而且它的 server 和 agent 是分离的，可以指定本机或远程的机器来运行构建策略，其中还有调度队列算法.<br><code>hexo</code> 是静态博客生成工具.<code>hexo d -g</code>命令可以自动生成 <code>public</code> 文件夹及 HTML，然后将其推送到 github(在<code>_config.yml</code>中已经配置过).<br>一般用户可能对<code>theme</code>自定义(修改<code>theme</code>下的<code>_config.yml</code>),当换机或备份时，希望将博客源文件(*.md)及修改的主题配置文件一并备份.而<code>hexo</code>默认只备份<code>public</code>文件夹,所以本文探索使用 CI<code>TeamCity</code>将推送到<code>Github</code>的源文件编译生成<code>public</code>文件,这样每次写完文章,只要将其推送到<code>Github</code>,<code>TeamCity</code>会自动生成博客<code>HTML</code>.</p>
<p>获取到该 Key.而实际上在 build 执行时 key 以 ing 被删除了,不可能获取到.这并不意味着绝对安全，只是增加了 key 被盗的难度. agent 必须安全.</p>
<h3 id="teamcity-安装"><a href="#teamcity-安装" class="headerlink" title="teamcity 安装"></a>teamcity 安装</h3><p><code>TeamCity</code>提供了 <code>Docker</code>安装方式，因此请提前安装好<code>Docker</code>.<br>文件目录如下(请提前创建),teamcity 支持多种数据存储方式，此处使用 mysql 来存储。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># - teamcity</span></span><br><span class="line">    - agent</span><br><span class="line">        - conf</span><br><span class="line">        - data</span><br><span class="line">    - server</span><br><span class="line">        - data</span><br><span class="line">        - datadir</span><br><span class="line">        - opt</span><br><span class="line">    - mysql</span><br><span class="line">        - backup</span><br><span class="line">        - data</span><br><span class="line">    dockery-compose.yml</span><br></pre></td></tr></table></figure>

<p>接下来是<code>docker-compose.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">``yaml</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.3&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">teamcity-server:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">jetbrains/teamcity-server</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">teamcity-server</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8111</span><span class="string">:8111</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$PWD/server/datadir:/data/teamcity_server/datadir</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$PWD/server/opt/logs:/opt/teamcity/logs</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$PWD/server/data:/data/teamcity_server/others</span> <span class="comment"># 其他的一些资源，可以从本机复制到 server 上</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="comment">#   TEAMCITY_SERVER_MEM_OPTS: -Xmx2g -XX:MaxPermSize=270m -XX:ReservedCodeCacheSize=350m</span></span><br><span class="line">      <span class="attr">MYSQL_USER:</span> <span class="string">team-user</span></span><br><span class="line">      <span class="attr">MYSQL_PASSWORD:</span> <span class="string">team-pwd</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">teamcity8080</span></span><br><span class="line">      <span class="attr">MYSQL_DATABASE:</span> <span class="string">teamcitydb</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db</span></span><br><span class="line">    <span class="attr">links:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">team</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">teamcity-db</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$PWD/mysql:/etc/mysql/conf.d</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$PWD/mysql/backup:/var/lib/mysql</span> <span class="comment"># 只有 /var/lib/mysql 对应本地文件为空，才会创建这个数据库,即初次创建时，这个对应的本地文件夹要为空</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$PWD/mysql/data:/others</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_USER:</span> <span class="string">team-user</span></span><br><span class="line">      <span class="attr">MYSQL_PASSWORD:</span> <span class="string">team-pwd</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">teamcity8080</span></span><br><span class="line">      <span class="attr">MYSQL_DATABASE:</span> <span class="string">teamcitydb</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">3306</span><span class="string">:3306</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">team</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># &lt;&gt;&lt;&gt; agent &lt;&gt;&lt;&gt;</span></span><br><span class="line">  <span class="attr">teamcity-agent:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">jetbrains/teamcity-agent</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">teamcity-agent</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$PWD/agent/conf:/data/teamcity_agent/conf</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$PWD/agent/data:/data/teamcity_agent/others</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">AGENT_NAME:</span> <span class="string">MacbookPro</span></span><br><span class="line">      <span class="attr">SERVER_URL:</span> <span class="string">http://xxx.xxx.x.xxx:8111</span> <span class="comment"># 此处对应的是 TeamCityServer 的IP, localhost/127.0.0.1 都不行，请使用正确的 IP,端口对应上面暴露出来的端口</span></span><br><span class="line">    <span class="attr">links:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">teamcity-server</span></span><br><span class="line">  <span class="comment"># teamcity_agent 默认的任务环境路径: opt/buildagent/work</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">team:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></table></figure>

<p>然后执行 <code>docker-compose up -d</code> 即可。</p>
<blockquote>
<p>需要先根据本机 OS 安装<code>docker-compose</code> &gt; <code>docker-compose up -d</code> 生成服务<br><code>docker-compose down</code> 解体服务，删除容器,网络<br><code>docker-compose start/stop</code> 启动终止服务</p>
</blockquote>
<ul>
<li><p>打开 <code>http://localhost:8111</code> 或 <code>http://[ip]:8111</code> 即可进入 TeamCity Server web 交互环境.按照提示初始化.登录时默认没有访客创建新用户的权限，所以需要已超级用户权限登录，点击下面的以超级权限登录后提示输入 token,可以进入 TeamCity Server 本地映射文件中查找，或是使用 <code>docker logs teamcity-server</code> 即可看到 token。</p>
</li>
<li><p>创建项目时，TeamCity 默认使用用户名密码连接 Github,当然可以通过上传本地 ssh key 密钥到 TeamCity Server,通过 TeamCity Server 连接.</p>
</li>
<li><p>设置编译步骤,我再次执行了<code>shell 脚本</code></p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 nodejs</span></span><br><span class="line">VERSION=v10.15.2</span><br><span class="line">DISTRO=linux-x64</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">checkNode</span></span>() &#123;</span><br><span class="line">  ISNODESUCCEED=$(node -v)</span><br><span class="line">  <span class="keyword">if</span> [ ISNODESUCCEED != <span class="variable">$VERSION</span> ]; <span class="keyword">then</span></span><br><span class="line">    installNode</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;NodeJS已安装&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">insallNode</span></span>() &#123;</span><br><span class="line">  <span class="built_in">mkdir</span> -p /usr/local/lib/nodejs</span><br><span class="line">  tar -xJf /data/teamcity_agent/others/node-<span class="variable">$VERSION</span>-<span class="variable">$DISTRO</span> <span class="comment"># -v 会输出解压日志，此处太多，所以关闭</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">export</span> PATH=/usr/local/lib/nodejs/node-<span class="variable">$VERSION</span>-<span class="variable">$DISTRO</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">source</span> ~/.profile</span><br><span class="line"></span><br><span class="line">  checkNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">checkNode</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line">npm i</span><br><span class="line"><span class="comment"># 生成public文件</span></span><br><span class="line">./node_modules/hexo/bin/hexo g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为 github.io 配置 CNAME</span></span><br><span class="line"><span class="keyword">if</span> [ ! -f <span class="string">&quot;/CNAME&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;blog.dang8080.cn&quot;</span> &gt; CNAME</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置 git</span></span><br><span class="line"></span><br><span class="line">git config --global credential.helper store <span class="comment"># 保存 github 提交者信息，下次不用再输密码</span></span><br><span class="line">git config --global user.name <span class="string">&quot;Humphrey&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;dang8080@qq.com&quot;</span></span><br><span class="line"></span><br><span class="line">git add --all</span><br><span class="line">git commit -m <span class="string">&quot;TeamCity CI 提交部署: <span class="subst">$(date)</span>&quot;</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure>

<h3 id="问题"><a href="#问题" class="headerlink" title="问题:"></a>问题:</h3><blockquote>
<p>所以问题来了,配置完了点击 <code>run</code> 查看 Build log 会发现 push 失败。因为通过 https 向 github 提交代码需要交互式输入用户密码。而此处没有提供，将密码硬编码到此 shell 里提交到 github 也不安全。<br>或者即使是通过修改 VCS root 使用 <a href="mailto:&#103;&#x69;&#116;&#x40;&#103;&#105;&#116;&#x68;&#117;&#98;&#46;&#99;&#111;&#109;">&#103;&#x69;&#116;&#x40;&#103;&#105;&#116;&#x68;&#117;&#98;&#46;&#99;&#111;&#109;</a> ssh checkout 的代码，也无法推送到 github.</p>
</blockquote>
<h4 id="问题定位"><a href="#问题定位" class="headerlink" title="问题定位:"></a>问题定位:</h4><blockquote>
<p>TeamCity SSH agent 使用本机(Linux&#x2F;MacOS)的 OpenSSH 管理 SSH,对于 Windows,需要手动安装 OpenSSH (CygWin,MinGW,Git for Windows).<br>SSH agent 必须添加到 <code>$PATH</code> 中.<br>第一次连接到远程地址时，SSH agent 会询问是否保存远程地址的 fingerprint 到地址数据库 <code>~/.ssh/known_hosts</code>中.<br>为了避免询问，可以提前配置。如果相信该远程地址，可以禁用远程地址检查</p>
</blockquote>
<blockquote>
<p>对所有的连接都禁用，<code>~/.ssh/config</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Host \*</span><br><span class="line">StrictHostKeyChecking no</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>特定连接,<code>-o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no</code></p>
</blockquote>
<blockquote>
<p>TeamCity 当前仅支持 PEM 格式的 key.如果使用了其他格式的 key，请将其转换为 PEM.可以在 TeamCity web 界面 <code>Conversions -&gt; Export OpenSSH key</code> 中转换.</p>
</blockquote>
<blockquote>
<p>OpenSSH 最近版本默认不生成 PEM 格式 key.使用下列方式生成 PEM: <code>ssh-keygen -t rsa -m PEM</code></p>
</blockquote>
<blockquote>
<p>上传到 TeamCity Server 的 SSH key 默认保存在 <code>&lt;TeamCity Data Directory&gt;/config/projects/&lt;project&gt;/pluginData/ssh_keys</code>，TeamCity 会追踪此文件夹保证 SSH key 更新。SSH key 适用于本项目及子项目.</p>
</blockquote>
<blockquote>
<p>在 TeamCity agent checkout 执行时，Git 插件会从 TeamCity Server 下载 SSH key 到 agent.该 key 会暂时保存在 TeamCity agent 的文件系统里，在 <code>fetch/clone</code> 结束后就被删除.</p>
</blockquote>
<blockquote>
<p>key 被删除的原因是：通过 build 执行的 test 可能会留下恶意代码，之后会访问 TeamCity agent 文件系统,</p>
</blockquote>
<p>TeamCity 是不支持 git ssh 推动代码到 github 的.（支持 ssh 传送文件）</p>
<h4 id="方案一"><a href="#方案一" class="headerlink" title="方案一:"></a>方案一:</h4><p>当 <code>run</code> 一次之后，执行 <code>docker exec -it teamcity-agent bash</code> 进入 <code>opt/buildagent/work/xxxxx/</code> 下,手动 <code>git push origin master</code>。这样后续就不用再配置了</p>
<h4 id="方案二-硬核"><a href="#方案二-硬核" class="headerlink" title="方案二:(硬核)"></a>方案二:(硬核)</h4><p><code>github</code> 需要保存本机的 SSH pub key,才接受 git ssh 推送.那我们就在 TeamCity 生成 ssh key,然后添加到 github.</p>
<h5 id="实践一"><a href="#实践一" class="headerlink" title="实践一"></a>实践一</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docekr <span class="built_in">exec</span> -it teamcity-agent bash</span><br><span class="line">ssh-keygen -t rsa</span><br><span class="line">ssh-add [id_rsa]</span><br><span class="line"><span class="comment"># 然后复制 id_rsa.pub 的内容到 github 即可</span></span><br></pre></td></tr></table></figure>

<h5 id="实践二"><a href="#实践二" class="headerlink" title="实践二"></a>实践二</h5><p>连 TeamCity agent bash 也不想进，使用 shell 构建<br>先安装 expect tcl tk</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get update &amp;&amp; apt-get install tcl tk expect</span><br><span class="line"><span class="comment"># 下面是 shell</span></span><br><span class="line"><span class="comment">#! /usr/bin/expect -f</span></span><br><span class="line"><span class="built_in">set</span> context <span class="variable">$PWD</span></span><br><span class="line"><span class="comment"># 删除旧key</span></span><br><span class="line">spawn <span class="built_in">rm</span> -f <span class="string">&quot;<span class="variable">$context</span>/id_rsa&quot;</span> <span class="string">&quot;<span class="variable">$context</span>/id_rsa.pub&quot;</span></span><br><span class="line">expect&#123;&#125;</span><br><span class="line"><span class="comment"># 生成新key</span></span><br><span class="line">spawn ssh-keygen -t rsa</span><br><span class="line">expect&#123;</span><br><span class="line">  <span class="string">&quot;*save the key*&quot;</span> &#123; send <span class="string">&quot;<span class="variable">$context</span>/id_rsa\r&quot;</span>;exp_continue &#125;</span><br><span class="line">  <span class="string">&quot;*passphrase*&quot;</span> &#123; send <span class="string">&quot;\r&quot;</span>;exp_continue &#125;</span><br><span class="line">  <span class="string">&quot;*again*&quot;</span> &#123; send <span class="string">&quot;\r&quot;</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line">spawn ssh-add <span class="string">&quot;<span class="variable">$context</span>/id_rsa&quot;</span></span><br><span class="line">sshcheck=$(ssh -vT git@github.com)</span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$sshcheck</span> =~ <span class="string">&quot;successfully authenticated&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;ssh 配置成功&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;ssh 配置失败&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># 复制 pub</span></span><br><span class="line">pubkey=$(<span class="built_in">cat</span> <span class="string">&quot;<span class="variable">$context</span>/id_rsa)</span></span><br><span class="line"><span class="string">curl -H &quot;</span>Content-Type:application/json<span class="string">&quot; -X POST --data &#x27;&#123; &quot;</span>title<span class="string">&quot;:&quot;</span>TeamCityAgentAuto<span class="string">&quot;,&quot;</span>key<span class="string">&quot;:&quot;</span><span class="variable">$pubkey</span><span class="string">&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>teamcity</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 NAPI 或者 Context Aware 在渲染进程中加载 native 模块</title>
    <url>/2022/03/26/29/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://github.com/electron/electron/issues/18397">Requiring Native Modules in the Renderer Process to be NAPI or Context Aware</a></p>
</blockquote>
<p>当前在 electron 中加载 native 模块有些困难。比如编译 native 模块时，需要确保 <code>NODE_MODULE_VERSION</code> 版本正确。在同一个进程中加载多个 native 模块实例等问题。</p>
<span id="more"></span>

<p>之前官方团队实现了对 chromium 打 patch 的方案，却碰到了很多 tricky 的问题。现在随着 Node 12 Worker Threads 的发布，就可以轻松实现这个功能了。</p>
<p>其实 Node 团队在实现 Worker Thread 时也遇到了在多个 worker 线程中无法加载 native 模块的问题。他们的解决方案是提供了 <code>Context Aware</code> 的 native 模块方案。也就是 native 模块会告诉 Node, 他们可以被安全加载进多个 <code>v8::Context</code> 中，NAN 有个方便的宏 <code>NAN_MODULE_WORKER_ENABLED</code> 可以实现。</p>
<p>所以，Context Aware 模块和 NAPI 模块就可以在 node 中被多次实例化。</p>
<p>也就是说，任何想在渲染进程被加载的 native 模块必须得是 NAPI 或者 Context Aware.</p>
<h3 id="计划时间线"><a href="#计划时间线" class="headerlink" title="计划时间线."></a>计划时间线.</h3><p>1、在 <code>Electron6</code> 添加 <code>app.allowRendererProcessReuses</code> 选项<br>2、在 <code>Electron 7</code> 对非 context-aware 的 native 模块开始提出弃用警告<br>3、在 <code>Electron 8</code> 对需要使用 <code>app.allowRendererProcessReuses</code> 默认值提出弃用警告<br>4、在 <code>Electron 9</code> 中切换 <code>app.allowRendererProcessReuses</code> 默认值为 true<br>5、在 <code>Electron 10</code> 中弃用切换 <code>app.allowRendererProcessReuses</code> 的能力<br>6、在 <code>Electron 14</code> 中移除切换 <code>app.allowRendererProcessReuses</code> 的能力</p>
<blockquote>
<p><a href="https://nodejs.org/api/addons.html#addons_context_aware_addons">Context-aware addons</a></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>常用命令记录</title>
    <url>/2019/03/28/30/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="Homebrew"><a href="#Homebrew" class="headerlink" title="Homebrew"></a>Homebrew</h2><h3 id="gradle-completion"><a href="#gradle-completion" class="headerlink" title="gradle-completion"></a>gradle-completion</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install gradle-completion</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$fpath</span> | grep <span class="string">&quot;/usr/local/share/zsh/site-functions&quot;</span></span><br><span class="line"><span class="comment"># 执行结果</span></span><br><span class="line">Add the following line to your ~/.bash_profile:</span><br><span class="line">  [[ -r <span class="string">&quot;/usr/local/etc/profile.d/bash_completion.sh&quot;</span> ]] &amp;&amp; . <span class="string">&quot;/usr/local/etc/profile.d/bash_completion.sh&quot;</span></span><br><span class="line"></span><br><span class="line">Bash completion has been installed to:</span><br><span class="line">  /usr/local/etc/bash_completion.d</span><br><span class="line">==&gt; gradle-completion</span><br><span class="line">Bash completion has been installed to:</span><br><span class="line">  /usr/local/etc/bash_completion.d</span><br><span class="line"></span><br><span class="line">zsh completions have been installed to:</span><br><span class="line">  /usr/local/share/zsh/site-functions</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>移动优先的响应式网页设计</title>
    <url>/2019/04/12/33/</url>
    <content><![CDATA[<p><a href="https://www.html5rocks.com/en/mobile/responsivedesign/">原文</a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本文将探索如何创建移动优先的网页设计体验。</p>
<ul>
<li>为什么我们需要创建移动优先，响应式，适应式网页设计体验?</li>
<li>如何针对适应式站点组织 HTML 结构以便优化性能，优先考虑灵活性?</li>
<li>如何书写优先定义共享样式、针对大屏和媒体查询构建、使用相对单位的 CSS?</li>
<li>如何编写不引人注目的 Javascript 来有条件地加载内容片段，利用触摸事件和地理定位</li>
<li>我们可以做些什么来进一步增强我们的适应性体验<span id="more"></span></li>
</ul>
<h2 id="适应性的必要性"><a href="#适应性的必要性" class="headerlink" title="适应性的必要性"></a>适应性的必要性</h2><p>随着网络环境越来越复杂，为越来越多的环境提供可靠的网络体验变得极为重要.幸运的是，响应式 web 设计给 web 开发者提供了一些可以匹配任意大小屏幕的工具来组织布局.</p>
]]></content>
      <tags>
        <tag>翻译</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>安卓中的viewModelScope</title>
    <url>/2022/02/25/04/</url>
    <content><![CDATA[<blockquote><p>Easy Coroutines in Android: viewModelScope</p>
<footer><strong>原文</strong><cite><a href="https://medium.com/androiddevelopers/easy-coroutines-in-android-viewmodelscope-25bffb605471">medium.com/androiddevelopers/easy-coroutines-in-android-viewmodelscope-25bffb605471</a></cite></footer></blockquote>


<p>取消一个已经不再使用的协程，通常需要写一堆繁琐的代码。而 <code>viewModelScope</code> 通过为 <code>ViewModel</code> 类添加扩展属性来实现结构化并发，从而在 <code>ViewModel</code> 被销毁时，自动取消它内部的子协程.</p>
<span id="more"></span>

]]></content>
  </entry>
  <entry>
    <title>译-Kotlin-Coroutine(1) case)</title>
    <url>/2019/08/26/11/</url>
    <content><![CDATA[<p>Kotlin Coroutine</p>
<span id="more"></span>

<h3 id="提取函数-重构"><a href="#提取函数-重构" class="headerlink" title="提取函数-重构"></a>提取函数-重构</h3><p>但是如果提取出来的函数包含了一个在当前作用域调用的协程构造器怎么办?这种情况下,<code>suspend</code> 修饰符就不能满足需求了使<code>doWorld</code> 成为 <code>CoroutineScopr</code>的一个扩展函数是一种解决方案,但这种方法使得API不清晰而不适用其他情况.理想的解决方案是<code>CoroutineScope</code> 作为一个包含目标函数的类的一个属性存在,或者这个类实现<code>CoroutineScope</code>接口.最后一种方案就是适用<code>CoroutineScope(coroutineContext)</code>,但是这种方法会因为无法控制此方法的执行范围而表现出结构不安全性.只有一些私有 APIs 可以使用这个协程构造器.</p>
<h3 id="类似守护线程的-Global-Coroutines"><a href="#类似守护线程的-Global-Coroutines" class="headerlink" title="类似守护线程的 Global Coroutines"></a>类似守护线程的 Global Coroutines</h3><p><code>GlobalScope</code>启动的活动线程不会挂住线程,他们的行为类似守护线程.</p>
<h1 id="取消与超时"><a href="#取消与超时" class="headerlink" title="取消与超时"></a>取消与超时</h1><h3 id="取消协程的执行"><a href="#取消协程的执行" class="headerlink" title="取消协程的执行"></a>取消协程的执行</h3><p>在一个长时间运行的应用中,你可能需要精确控制后台运行的协程.例如用户可能关闭一个开启了协程的页面,那这个协程就需要被取消.<code>launch</code>函数返回一个<code>Job</code>对象可以取消此协程的执行.</p>
<h3 id="同时取消"><a href="#同时取消" class="headerlink" title="同时取消"></a>同时取消</h3><p>协程可以同时取消.所有在 <code>kotlinx.coroutines</code>中挂起的函数都是可取消的.在取消时,检查协程的取消标记然后抛出<code>CancellationException</code>.然而,如果一个协程在<code>computation</code> 中运行,而且没有检查取消标记,那就不能被取消.</p>
<h3 id="使-computation-代码可以被取消"><a href="#使-computation-代码可以被取消" class="headerlink" title="使 computation 代码可以被取消"></a>使 computation 代码可以被取消</h3><p>有两种方式可以取消 computation 代码.第一种是周期性的调起一个挂起函数去检测取消标记.<code>yield</code>函数可以实现这个需求.另一种是精确的检查取消标记状态.</p>
<h3 id="使用-finally-关闭资源"><a href="#使用-finally-关闭资源" class="headerlink" title="使用 finally 关闭资源"></a>使用 <code>finally</code> 关闭资源</h3><p>在取消具有可取消属性的挂起函数时会抛出 <code>CancellationException</code>,可以在 coroutine 被取消时使用常用的方法处理.如 <code>try&#123;...&#125;finally&#123;...&#125;</code>表达式和 <code>use</code>函数执行最终任务.<br><code>join</code>和<code>cancelAndJoin</code>等待所有的最终任务执行完成才结束.</p>
<h3 id="运行不可取消的代码块"><a href="#运行不可取消的代码块" class="headerlink" title="运行不可取消的代码块"></a>运行不可取消的代码块</h3><p>任何在<code>finally</code>块中使用挂起函数都将导致<code>CancellationException</code>,因为运行此代码的 coroutine 已经被取消了.通常,这不是个问题,因为良好的关闭操作(关闭文件、取消任务或关闭任意类型的消息通道)通常都是非阻塞的,而且也不会挂起任何函数.在已经取消的协程里,如果竞态条件下想挂起,你可以使用<code>withContext</code>函数和<code>NonCancellable</code>上下文在<code>withContext(NonCancellable)&#123;...&#125;</code>中封装响应的代码.</p>
<h3 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h3><p>取消一个正在执行的协程的最常见的理由可能是他的执行时长已经超过了超时时间.当然,你可以手动追踪相应<code>Job</code>的引用,然后启动一个独立的协程延时后取消追踪的这个<code>Job</code>,<code>withTimeout</code>函数可以实现这个需求.<br><code>withTimeout</code>抛出的<code>TimeoutCancellationException</code>是<code>CancellationException</code>的子类.之前没有看到控制台打印异常堆栈信息的原因是在一个被取消的协程抛出的 <code>CancellationExcepiton</code>被认为是协程正常执行结束的标记.<br>因为 cancellation 仅仅是一个异常,所有的资源都可以使用正常的逻辑处理.如果你需要在任何超时时添加某些特殊逻辑,可以把超时的这些代码放在<code>try&#123;...&#125;catch(e:TimeoutCancellationException)&#123;...&#125;</code>块中,或者使用<code>withTimeoutOrNull</code>函数(类似<code>withTimeout</code>但是在超时返回 null 而不是抛出异常).</p>
<h1 id="组合挂起函数"><a href="#组合挂起函数" class="headerlink" title="组合挂起函数"></a>组合挂起函数</h1><h3 id="默认顺序"><a href="#默认顺序" class="headerlink" title="默认顺序"></a>默认顺序</h3><p>假设有定义在其他地方的两个挂起函数执行如远程服务或计算等任务.我们认为这些任务有用,实际上每隔任务只是为了其特殊目的延时了1秒.</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSomethingUsefulOne</span><span class="params">()</span></span>:<span class="built_in">Int</span> &#123;</span><br><span class="line">  delay(<span class="number">1000</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">13</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSomethingUsefulTwo</span><span class="params">()</span></span>:<span class="built_in">Int</span> &#123;</span><br><span class="line">  delay(<span class="number">1000</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">29</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们需要上面的函数按顺序被调用,然后计算他们的结果?实际中,我们都是先拿第一个函数的结果在决定是否调用第二个函数或如何调用.<br>和普通的代码一样,在协程里的代码也是按顺序执行的.</p>
<h3 id="使用-async-并发"><a href="#使用-async-并发" class="headerlink" title="使用 async 并发"></a>使用 async 并发</h3><p>如果两个函数之间没有相关,而且我们想更快的获取到结果,可以同时执行两个函数吗?<code>async</code>可以实现.<br>理论山,<code>async</code>类似<code>launch</code>.它会开启一个新的协程和其他协程并发的执行.不同之处在于<code>launch</code>返回一个没有携带结果的<code>Job</code>,而<code>async</code>返回一个<code>Deferred</code>(一个轻量级的非阻塞 future 表示在未来的某一时刻会返回结果).可以对<code>Deferred</code>使用<code>.await()</code>来获取最终的结果,但是<code>Deferred</code>同时也是一个<code>Job</code>,所以必要的时候也可以取消.<br>协程的并发性总是精确的.</p>
<h3 id="使用-async-延迟启动"><a href="#使用-async-延迟启动" class="headerlink" title="使用 async 延迟启动"></a>使用 async 延迟启动</h3><p><code>async</code>可以设置它的<code>start</code>参数为<code>CoroutineStart.LAZY</code>来延迟启动.在此场景下,只有在<code>await</code>调用获取结果时才启动,或者它的<code>Job</code>的<code>start</code>函数被调用时启动.<br>如果仅仅调用<code>await</code>而没在之前调用各自协程的<code>start</code>,这将会导致序列化行为,因为<code>await</code>启动协程执行代码然后等待它结束,这不是用户角度的延迟.当调用挂起函数计算某个值时使用<code>async(start=CoroutineStart.LAZY)</code>可以替换标准的<code>lazy</code>函数.</p>
<h3 id="async-风格的函数"><a href="#async-风格的函数" class="headerlink" title="async 风格的函数"></a>async 风格的函数</h3><p>使用<code>async</code>协程构造器和明确的<code>GlobalScope</code>引用异步调用函数就可以实现async风格的函数.一般这样的函数以<code>...Async</code>后缀结尾以表明只启动了异步执行,需要使用<code>Deferred</code>来获取结果.<br><code>xxxAsync</code>函数不是挂起函数.这种函数可在任意地方调用.这种函数就意味着异步(此处即为并发)执行他们的任务和代码.</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"><span class="keyword">import</span> kotlin.system.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">    <span class="keyword">val</span> one = somethingUsefulOneAsync()</span><br><span class="line">    <span class="keyword">val</span> two = somethingUsefulTwoAsync()</span><br><span class="line">    <span class="comment">// 等待结果必须在挂起函数或者阻塞</span></span><br><span class="line">    <span class="comment">// 所以使用 runBlocking&#123;&#125; 阻塞主线程</span></span><br><span class="line">    runBlocking &#123;</span><br><span class="line">      println(<span class="string">&quot;<span class="subst">$&#123;one.await() + two.await()&#125;</span>&quot;</span>)<span class="string">&#x27;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fun somethingUsefulOneAsync() = GlobalScope.async &#123;</span></span><br><span class="line"><span class="string">    doSomethingUsefulOne()</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fun somethingUsefulTwoAsync() = GlobalScope.async &#123;</span></span><br><span class="line"><span class="string">    doSomethingUsefulTwo()</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">suspend fun doSomethingUsefulOne(): Int &#123;</span></span><br><span class="line"><span class="string">    delay(1000L) // pretend we are doing something useful here</span></span><br><span class="line"><span class="string">    return 13</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">suspend fun doSomethingUsefulTwo(): Int &#123;</span></span><br><span class="line"><span class="string">    delay(1000L) // pretend we are doing something useful here, too</span></span><br><span class="line"><span class="string">    return 29</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>这段代码类似其他语言的异步(js).假设<code>xxxAsync</code>在执行过程中发生了异常,通常全局错误处理器会捕获该异常,记录报告此错误,程序可以继续执行其他操作.但是此处的函数在后台运行,而不会被打断,即使初始化调用它的操作已经被终止了.所以不鼓励使用这样的代码风格.</p>
<h3 id="使用-async-进行结构化并发"><a href="#使用-async-进行结构化并发" class="headerlink" title="使用 async 进行结构化并发"></a>使用 async 进行结构化并发</h3><p>因为<code>async</code>协程构造器是<code>CoroutineScope</code>的扩展函数,所以需要使用<code>coroutineScope函数</code>提供执行范围.</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">concurrentSum</span><span class="params">()</span></span>: <span class="built_in">Int</span> = coroutineScope &#123;</span><br><span class="line">  <span class="keyword">val</span> one = async &#123; doOne()&#125;</span><br><span class="line">  <span class="keyword">val</span> two = async &#123; doTwo()&#125;</span><br><span class="line">  one.await+two.await()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果在上面的函数里出错抛出异常,那么在这个范围里启动的所有协程都将被取消.</p>
<h1 id="协程上下文和分发器"><a href="#协程上下文和分发器" class="headerlink" title="协程上下文和分发器"></a>协程上下文和分发器</h1><p>协程总是在 kotlin 标准库定义的 <code>CoroutineContext</code> 类型的某个上下文中执行.<br>协程是一系列不同元素的集合.主元素是协程的 <code>Job</code>,<code>dispatcher</code>.</p>
<h3 id="分发器和线程"><a href="#分发器和线程" class="headerlink" title="分发器和线程"></a>分发器和线程</h3><p>协程上下文包含了一个协程分发器(决定哪个线程或相应协程执行其代码的线程).协程分发器可以限制协程在某个指定的线程,线程池,或者未定义的线程去执行.<br>所有的协程构造器如<code>launch</code>和<code>async</code>接收一个可选的<code>CoroutineContext</code>参数(可以精确的指定为一个新协程或者其他上下文元素).<br>当<code>launch&#123;...&#125;</code>未传参数时,它继承了从它被启动的地方的<code>CoroutineScope</code>的上下文(和分发器).<br><code>Dispatchers.Unconfined</code>是一个也运行在<code>main</code>线程的特殊分发器,但实际机制是不同的.<br>当协程从<code>GlobalScope</code>(即<code>Dispatchers.Default</code>)启动时使用的是默认分发器.使用了一个共享后台线程池,所以<code>launch(Dispatchers.Default)&#123;...&#125;</code>和<code>GloablScope.launch&#123;...&#125;</code>使用了相同的分发器.<br><code>newSingleThreadContext</code>为协程创建了一个新线程去运行.专用线程是一种非常昂贵的资源.在真实应用下,当不在使用时,它必须使用 <code>close</code> 函数 release,或者存储在一个顶级变量中,然后在整个应用中复用.</p>
<h3 id="无限制和受限制的分发器"><a href="#无限制和受限制的分发器" class="headerlink" title="无限制和受限制的分发器"></a>无限制和受限制的分发器</h3><p><code>Dispatchers.Unconfined</code>协程分发器仅在第一个挂起点时才在调用者线程启动一个协程.挂起后,线程中的协程完全由被调用的挂起函数决定是否恢复.无限制协程分发器适用于既不消耗CPU时间,也不更新限定于特定线程的共享数据(如UI)的协程.<br>此外,此协程默认继承其外部的<code>CoroutineScope</code>.<code>runBlocking</code>协程的默认分发器受限于其被调用的线程,所以它将具有在此线程执行可预测FIFO调度的影响.</p>
<blockquote>
<p>无限制分发器属于高级技巧:在分发一个协程后不需要或产生不可期的副作用时很有效果（因为在一个协程里的某些操作必须被正确的执行）.在正常代码中不要使用无限制分发器.</p>
</blockquote>
<h3 id="调试协程和线程"><a href="#调试协程和线程" class="headerlink" title="调试协程和线程"></a>调试协程和线程</h3><p>协程可以在一个线程被挂起,在另一个线程被唤醒.即使是一个单线程分发器也很难检测协程在什么时间,什么位置,执行了什么操作.最常用调试线程的方式是在每条日志语句打印出线程名.几乎所有的日志框架都支持这个特性.使用协程时,线程没有提供更多的上下文信息,而<code>kotlinx.coroutines</code>包含了许多调试工具可以更方便的实现这个需求.<br>在 JVM 参数时配置 <code>-DKotlinx.coroutines.debug</code>.</p>
<blockquote>
<p>JVM 配置 <code>-ea</code> 参数debug模式自动开启.</p>
</blockquote>
<h3 id="在线程之间跳转"><a href="#在线程之间跳转" class="headerlink" title="在线程之间跳转"></a>在线程之间跳转</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">log</span><span class="params">(msg:<span class="type">String</span>)</span></span> = println(<span class="string">&quot;[<span class="subst">$&#123;Thread.currentThread().name&#125;</span>] <span class="variable">$msg</span>&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  newSingleThreadContext(<span class="string">&quot;Ctx1).use&#123;ctx1 -&gt;</span></span><br><span class="line"><span class="string">    newSingleThreadContext(&quot;</span>Ctx2).use&#123;ctx2 -&gt;</span><br><span class="line">      runBlocking(ctx1) &#123;</span><br><span class="line">        log(<span class="string">&quot;started in ctx1&quot;</span>)</span><br><span class="line">        withContext(ctx2) &#123;</span><br><span class="line">          log(<span class="string">&quot;working in ctx2&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        log(<span class="string">&quot;back to ctx1&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>runBlocking</code>可以指定上下文对象.<code>withContext</code>函数可以改变一个协程的上下文对象.<br>kotlin标准库里的<code>use</code>函数会主动释放<code>newSingleThreadContext</code>创建的线程(不再使用时).</p>
<h3 id="上下文里的-Job"><a href="#上下文里的-Job" class="headerlink" title="上下文里的 Job"></a>上下文里的 Job</h3><p>协程里的 Job 是上下文的一部分,可以通过<code>coroutineContext[Jon]</code>表达式获取到.</p>
<blockquote>
<p><code>CoroutineScope</code>里的<code>isActive</code>仅仅是<code>coroutineCOntext[Job]?.isActive == true</code>的简写.</p>
</blockquote>
<h3 id="子协程"><a href="#子协程" class="headerlink" title="子协程"></a>子协程</h3><p>当从另一个协程的<code>CoroutineScope</code>中启动一个新协程时,后者通过前者的<code>CoroutineScope.coroutineContext</code>和新协程的Job继承了前者的上下文,变成了父协程 job的子job.当父协程被取消时,所有的子job都会被迭代取消.<br>然而,当使用<code>GlobalScope</code>启动一个协程时,新协程的Job是没有父Job的.所以它不会绑定到任何 scope,运行是独立的.</p>
<h3 id="父协程的职责"><a href="#父协程的职责" class="headerlink" title="父协程的职责"></a>父协程的职责</h3><p>父协程总会等待所有的子Job执行完成才结束.父协程不需要刻意追踪它启动的所有子Job,也不需要使用<code>Job.join</code>去等待.</p>
<h3 id="命名协程"><a href="#命名协程" class="headerlink" title="命名协程"></a>命名协程</h3><p>自动分配的协程id可以在需要的时候过滤关注的协程信息.如果一个协程是进行特殊请求或执行特殊后台任务,对其进行合适的命名更利于debug.context的<code>CoroutineName</code>元素属性类似线程名可以给协程命名.当 debug 模式开启时,它会包含此协程所在线程的名字.</p>
<h3 id="组合上下文对象元素"><a href="#组合上下文对象元素" class="headerlink" title="组合上下文对象元素"></a>组合上下文对象元素</h3><p>有时需要为一个协程上下文定义多个元素.可以使用<code>+</code>实现.</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">launch(Dispatchers.Default + CoroutineNmae(<span class="string">&quot;Test&quot;</span>)) &#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="协程范围"><a href="#协程范围" class="headerlink" title="协程范围"></a>协程范围</h3><p>假设我们的应用有一个有生命周期的对象,但是这个对象不是协程.例如我们的android应用在Actiivty的上下文下启动了许多的协程去执行异步操作(如获取更新数据、执行动画等).当activity被销毁时所有的协程必须被取消以避免内存泄漏.我们当然可以手动的将协程和job绑定到activity的上下文,但是<code>kotlinx.coroutines</code>提供了一个抽象的封装对象:<code>CoroutineScope</code>.所有的协程构造器都是作为其扩展而存在.<br>创建一个绑定到activity的<code>CoroutineScope</code>对象来管理生命周期.<code>CoroutineScope</code>实例可以通过<code>CoroutineScope()</code>或<code>MainScope()</code>工厂函数创建.前者创建一个通用的scope,而后者使用<code>Dispatchers.Main</code> 作为默认分发器创建一个专为UI应用构造的scope.</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Activity</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> mainScope = MainScope()</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">destroy</span><span class="params">()</span></span>&#123;</span><br><span class="line">    mainScope.cancel()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以为 <code>Activity</code>类继承 <code>CoroutineScope</code>接口.最佳方案是使用代理实现默认工厂函数.</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Activity</span> : <span class="type">CoroutineScope</span> <span class="title">by</span> <span class="title">CoroutineScope</span>(Dispatchers.Default) &#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线程本地数据-Thread-local-data"><a href="#线程本地数据-Thread-local-data" class="headerlink" title="线程本地数据(Thread-local data)"></a>线程本地数据(Thread-local data)</h3><p>有时候在协程之间能传递线程本地数据将会很方便.但是因为这是数据没有绑定到任意特定的线程,所以可能需要写很多重复的代码.</p>
<p><code>asContextElement</code>扩展函数可以作为<code>ThreadLocal</code>使用.它会创建一个额外的上下文元素保存<code>ThreadLocal</code>值,在每次协程切换它的上下文是自动恢复.</p>
<p>很容易忘记设置相应的上下文元素.如果线程运行的协程不同,从协程访问thread-local变量可能会出现未知的值.为了避免这样的情况,推荐使用<code>ensurePresent</code>方法和在不正确使用时<code>fail-fast</code>.</p>
<p><code>ThreadLocal</code>属于顶级元素支持,可以在<code>kotlinx.coroutines</code>提供原生支持.仅有一个限制:即这个thread-local值发生变化,协程调用者不会收到通知(因为协程上下文元素不会追踪所有的<code>ThreadLocal</code>对象访问路径),那么更新的元素在下次挂起时将会丢失.在协程中使用<code>withContext</code>更新一个thread-local对象的值.</p>
<p>当然,数据也可以存储在一个可变的box如<code>class Counter(var i:Int)</code>中,最终会被转为存储在thread-local变量中.这样你就需要自己同步数据的变更.</p>
<p><code>ThreadContextElement</code></p>
<h1 id="异步流"><a href="#异步流" class="headerlink" title="异步流"></a>异步流</h1><p>挂起函数异步返回一个值,但是如何返回多个异步值?异步流可以实现这样的需求.</p>
<h3 id="展示多个值"><a href="#展示多个值" class="headerlink" title="展示多个值"></a>展示多个值</h3><h6 id="collections"><a href="#collections" class="headerlink" title="collections"></a>collections</h6><p>在 kotlin 使用 <code>collections</code>表示多个值.</p>
<h6 id="sequence"><a href="#sequence" class="headerlink" title="sequence"></a>sequence</h6><p>如果数据是需要花费CPU阻塞计算出来的,那可以使用 <code>Sequence</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span>: Sequence&lt;<span class="built_in">Int</span>&gt; = sequence &#123;</span><br><span class="line">  <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">    Thread.sleep(<span class="number">100</span>)</span><br><span class="line">    yield(i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  foo().forEach &#123;value -&gt; println(value)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="挂起函数"><a href="#挂起函数" class="headerlink" title="挂起函数"></a>挂起函数</h5><p>但是上面这样的代码会阻塞主线程.</p>
<h5 id="Flows"><a href="#Flows" class="headerlink" title="Flows"></a>Flows</h5><p>使用 <code>List&lt;Int&gt;</code>会一次性返回所有的值.可以使用<code>Flow&lt;int&gt;</code>异步的计算值来表示数据流.</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123;</span><br><span class="line">  <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">    delay(<span class="number">100</span>)</span><br><span class="line">    emit(i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">  launch &#123;</span><br><span class="line">    <span class="keyword">for</span> (k <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">      println(<span class="string">&quot;I am not blocked<span class="variable">$K</span>&quot;</span>)</span><br><span class="line">      delay(<span class="number">100</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  foo().collect&#123;value -&gt; println(value)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>flow&#123;...&#125;</code> 构造器可以挂起</li>
<li><code>foo()</code> 函数不再被标记为<code>suspend</code></li>
</ul>
<h3 id="Flows-属于冷启动"><a href="#Flows-属于冷启动" class="headerlink" title="Flows 属于冷启动"></a>Flows 属于冷启动</h3><p>Flows 类似 sequences 是冷启动的-在 flow 构造器中的代码在 flow 被 collect 前是不会运行的.这就是为什么 <code>foo()</code>函数没有被标记<code>suspend</code>.</p>
<h3 id="Flows-取消"><a href="#Flows-取消" class="headerlink" title="Flows 取消"></a>Flows 取消</h3><p>flow 遵循协程的取消规则.flow 没有提供其他额外的挂起点.当flow被一个可取消的挂起函数(<code>delay</code>)挂起时是可以被取消的.否则是不可被取消的.</p>
<h3 id="Flow-构造器"><a href="#Flow-构造器" class="headerlink" title="Flow 构造器"></a>Flow 构造器</h3><ul>
<li><code>flow&#123;...&#125;</code></li>
<li><code>flowOf</code>构造器发射固定带下的数据流</li>
<li>不同的 collections 和 sequence 可以使用 <code>.asFlow()</code> 扩展函数转为 flow.</li>
</ul>
<h3 id="flow-的中间操作"><a href="#flow-的中间操作" class="headerlink" title="flow 的中间操作"></a>flow 的中间操作</h3><p>Flows 可以使用类似 collections 和 sequences 进行转换.中间操作应用在上游流,然后返回下游流.这些流都是冷启动流.这样的操作不是挂起函数.立即返回新的转换流.</p>
<p>最基本操作名称如<code>map</code>,<code>filter</code>.不同于 sequence 的是在这些操作里的代码块可以调用挂起函数.</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">performRequest</span><span class="params">(request: <span class="type">Int</span>)</span></span>: String &#123;</span><br><span class="line">  delay(<span class="number">1000</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;response <span class="variable">$request</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">  (<span class="number">1.</span><span class="number">.3</span>).asFlow()</span><br><span class="line">        .map&#123; request -&gt; performRequest(request)&#125;</span><br><span class="line">        .collect&#123; response -&gt; println(response)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="转换操作符"><a href="#转换操作符" class="headerlink" title="转换操作符"></a>转换操作符</h3><p>flow 转换符中,最常用的被称为<code>transform</code>.它可以实现比<code>map</code>和<code>filter</code>更复杂的转换操作.使用 <code>transform</code>操作符,可以发射任意值任意次.</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">performRequest</span><span class="params">(request: <span class="type">Int</span>)</span></span>: String &#123;</span><br><span class="line">  delay(<span class="number">1000</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;response <span class="variable">$request</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">  (<span class="number">1.</span><span class="number">.3</span>).asFlow()</span><br><span class="line">        .transform&#123; request -&gt;</span><br><span class="line">          emit(<span class="string">&quot;making request <span class="variable">$request</span>&quot;</span>)</span><br><span class="line">          emit(performRequest(request))</span><br><span class="line">        &#125;</span><br><span class="line">        .collect&#123; resposne -&gt; println(response)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="大小限制操作符"><a href="#大小限制操作符" class="headerlink" title="大小限制操作符"></a>大小限制操作符</h3><p>大小限制操作符如<code>take</code>在相应的限制到期时会取消执行.协程里的取消总是会抛出异常,所以所有的资源管理函数如(<code>try&#123;...&#125;finally&#123;...&#125;</code>)和普通的操作类似.</p>
<h3 id="终止flow操作符"><a href="#终止flow操作符" class="headerlink" title="终止flow操作符"></a>终止flow操作符</h3><p>终止操作符是一个启动收集流的挂起函数.<code>collect</code>函数是最长用的一个.其他的有:</p>
<ul>
<li>转换为不同的 collections如: <code>toList</code>,<code>toSet</code></li>
<li>获取第一个值并且确定流只发送了一个值.</li>
<li>使用 <code>reduce</code>和<code>fold</code>把流压缩为一个值.</li>
</ul>
<h3 id="流是连续的"><a href="#流是连续的" class="headerlink" title="流是连续的"></a>流是连续的</h3><p>一个流的每个独立收集都是连续的除非某些特殊操作处理了多个流.协程里的流收集会调用一个终止操作符.默认不会启动新协程.每一个发射的数据都会被从上游到下游的中间处理操作符处理.最后被传送到终止操作符.</p>
<h3 id="Flow-context"><a href="#Flow-context" class="headerlink" title="Flow context"></a>Flow context</h3><p>流的收集操作总是处于正在被调用的协程中,而不是flow所在的协程.</p>
<p>流的这个操作被称为上下文保存.<br>所以默认<code>flow&#123;...&#125;</code>里的代码运行的上下文是由流的相应收集者提供的.对于快速运行或异步代码而言,这是个完美的默认设置,它不关心上下文执行者,也不阻塞调用者.</p>
<h6 id="withContext-发射错误"><a href="#withContext-发射错误" class="headerlink" title="withContext 发射错误"></a>withContext 发射错误</h6><p>长时间消耗CPU的代码需运行在<code>Dispatchers.Default</code>上下文,UI更新代码需运行在<code>Dispatchers.Main</code>上下文中.通常,在协程中使用 <code>withContext</code>切换上下文,但是<code>flow&#123;...&#125;</code>中的代码有上下文保留特性,不允许在其他上下文发射数据.</p>
<h6 id="flowOn-操作符"><a href="#flowOn-操作符" class="headerlink" title="flowOn 操作符"></a>flowOn 操作符</h6><p>指向 flowOn 函数的异常可以用来更改 flow 发射的上下文.改变flow上下文的正确操作如下:</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span>:Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123;</span><br><span class="line">  <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">    delay(<span class="number">100</span>)</span><br><span class="line">    emit(i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;.flowOn(Dispatchers.Default)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">  foo().collect&#123; value -&gt;</span><br><span class="line">    log(<span class="string">&quot;llll&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>flowOn</code>操作符改变了流的默认顺序.现在收集者在一个协程,而发射却并发的运行在在另一个线程的一个协程中.当在它的上下文中改变<code>CoroutineDispatcher</code>时<code>flowOn</code>操作符为上游创建了另一个协程.</p>
<h3 id="Buffering"><a href="#Buffering" class="headerlink" title="Buffering"></a>Buffering</h3><p>在涉及长时间运行的异步操作时,在不同协程运行流的不同部分对流收集的总时间很有帮助.<br>使用<code>buffer</code>操作符操作操作正在发射数据的流,并发的收集而不是顺序收集.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val time = measureTimeMillis &#123;</span><br><span class="line">  foo()</span><br><span class="line">    .buffer()</span><br><span class="line">    .collect &#123; value -&gt;</span><br><span class="line">      delay(300)</span><br><span class="line">      println(value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">println(&quot;Collected in $time ms&quot;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当改变 <code>CoroutineDispatcher</code>时<code>flowOn</code>操作符使用相似的机制,但是此处不需要改变执行上下文.</p>
</blockquote>
<h5 id="异步合并"><a href="#异步合并" class="headerlink" title="异步合并"></a>异步合并</h5><p>当流表示了部分操作结果或参数更新状态,处理每个值可能没必要,但是需要处理最近的一个.当收集者处理太慢时<code>conflate</code>操作符可以跳过某些中间值.</p>
<h5 id="处理最后一个值"><a href="#处理最后一个值" class="headerlink" title="处理最后一个值"></a>处理最后一个值</h5><p>当生产者和消费者处理都很慢时,conflate 是一种加速的方法.它丢弃了一部分数据.另一种方式是取消慢消费者,然后只要生产者发送一个数据就重启.</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">foo()</span><br><span class="line">  .follectLastes &#123;value -&gt;</span><br><span class="line">    println(<span class="string">&quot;collection <span class="variable">$value</span>&quot;</span>)</span><br><span class="line">    delay(<span class="number">300</span>)</span><br><span class="line">    pritln(<span class="string">&quot;Done <span class="variable">$value</span>&quot;</span>)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="组合多个流"><a href="#组合多个流" class="headerlink" title="组合多个流"></a>组合多个流</h3><h6 id="Zip"><a href="#Zip" class="headerlink" title="Zip"></a>Zip</h6><p>类似<code>Sequence.zip</code>扩展函数,流也有<code>自拍</code>操作符</p>
<h6 id="Combine"><a href="#Combine" class="headerlink" title="Combine"></a>Combine</h6><p>当流表示某些变量或操作最近的值时(见<code>conflation</code>),它可能需要根据相应流的最新值和上游发射的新数据计算,<code>combine</code>可以实现.使用<code>zip</code>的话就得等时间最长的哪个流收到值才能计算.</p>
<h3 id="展开流"><a href="#展开流" class="headerlink" title="展开流"></a>展开流</h3><p>因为流表示异步接受到的数据流,所以每个值可以转为另一个序列的流.如<code>Flow&lt;Flow&lt;String&gt;&gt;</code></p>
<h6 id="flatMapConcat"><a href="#flatMapConcat" class="headerlink" title="flatMapConcat"></a>flatMapConcat</h6><p><code>flatMapConcat</code>和<code>flattenConcat</code>操作符实现了拼接模式.这是最接近 sequence的操作符.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import kotlinx.coroutines.*</span><br><span class="line">import kotlinx.coroutines.flow.*</span><br><span class="line"></span><br><span class="line">fun requestFlow(i: Int): Flow&lt;String&gt; = flow &#123;</span><br><span class="line">    emit(&quot;$i: First&quot;)</span><br><span class="line">    delay(500) // wait 500 ms</span><br><span class="line">    emit(&quot;$i: Second&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() = runBlocking&lt;Unit&gt; &#123;</span><br><span class="line">//sampleStart</span><br><span class="line">    val startTime = currentTimeMillis() // remember the start time</span><br><span class="line">    (1..3).asFlow().onEach &#123; delay(100) &#125; // a number every 100 ms</span><br><span class="line">        .flatMapConcat &#123; requestFlow(it) &#125;</span><br><span class="line">        .collect &#123; value -&gt; // collect and print</span><br><span class="line">            println(&quot;$value at $&#123;System.currentTimeMillis() - startTime&#125; ms from start&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">//sampleEnd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="flatMapMerge"><a href="#flatMapMerge" class="headerlink" title="flatMapMerge"></a>flatMapMerge</h6><p>另一种展开模式是并发的收集所有进来的流,然后把他们合并为一个单一流,这样值就可以尽快被发出去.<code>flatMapMerge</code>,<code>flattenMerge</code>.它们都接受一个<code>concurrency</code>参数限制并发流的数量.</p>
<h6 id="flatmapLatest"><a href="#flatmapLatest" class="headerlink" title="flatmapLatest"></a>flatmapLatest</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import kotlinx.coroutines.*</span><br><span class="line">import kotlinx.coroutines.flow.*</span><br><span class="line"></span><br><span class="line">fun requestFlow(i: Int): Flow&lt;String&gt; = flow &#123;</span><br><span class="line">    emit(&quot;$i: First&quot;)</span><br><span class="line">    delay(500) // wait 500 ms</span><br><span class="line">    emit(&quot;$i: Second&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() = runBlocking&lt;Unit&gt; &#123;</span><br><span class="line">//sampleStart</span><br><span class="line">    val startTime = currentTimeMillis() // remember the start time</span><br><span class="line">    (1..3).asFlow().onEach &#123; delay(100) &#125; // a number every 100 ms</span><br><span class="line">        .flatMapLatest &#123; requestFlow(it) &#125;</span><br><span class="line">        .collect &#123; value -&gt; // collect and print</span><br><span class="line">            println(&quot;$value at $&#123;System.currentTimeMillis() - startTime&#125; ms from start&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">//sampleEnd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>[译]-LiveData with SnackBar,Navigation and other events(the SingleLiveEvent case)</title>
    <url>/2019/02/28/11/</url>
    <content><![CDATA[<p><a href="https://medium.com/androiddevelopers/livedata-with-snackbar-navigation-and-other-events-the-singleliveevent-case-ac2622673150">原文</a></p>
<p>view(activity&#x2F;fragment) 和 ViewModel 交流的比较好的方式是 LiveData observables. view 订阅 LiveData 的改变且随时响应。这适用于连续不断的显示在一个屏幕的数据。<br><img src="http://qiniu.picbed.dang8080.cn/20190228202711.png" alt="LiveData"><br>但是某些数据却更应该被消费一次，比如 Snackbar 消息，navigation 事件 或 dialog 触发器。<br><img src="http://qiniu.picbed.dang8080.cn/20190228202852.png" alt="LiveData once"><br>与其试着通过扩展 Architecture Components 扩展或库解决这个问题，不如我们可以直面这是个设计缺陷。我们推荐你把你的事件看作是状态的一部分。本文我们将列举一些常见的错误和推荐的解决方案。</p>
<span id="more"></span>
<h3 id="❌-Bad-1-对事件使用-LiveData"><a href="#❌-Bad-1-对事件使用-LiveData" class="headerlink" title="❌ Bad: 1. 对事件使用 LiveData"></a>❌ Bad: 1. 对事件使用 LiveData</h3><p>在 LiveData 对象内部直接持有 Snackbar 消息或 navigation 信号。原则上普通的 LiveData 对象可以这样使用，但实际上会暴露一些问题。<br>在 master&#x2F;detail 架构的 app 中，如下是 maters 的 ViewModel</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 请不要对事件这样用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListViewModel</span> : <span class="type">ViewModel</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> _navigateToDetails = MutableLiveData&lt;<span class="built_in">Boolean</span>&gt;()</span><br><span class="line">  <span class="keyword">val</span> navigateToDetails : LiveData&lt;<span class="built_in">Boolean</span>&gt;</span><br><span class="line">      <span class="keyword">get</span>() = _navigateToDetails</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">userClicksOnButton</span><span class="params">()</span></span> &#123;</span><br><span class="line">    _navigateToDetails.value = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 View(activity&#x2F;fragment) 中</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">myViewModel.navigateToDetails.observe(<span class="keyword">this</span>,Observer &#123;</span><br><span class="line">  <span class="keyword">if</span> (it) startActivity(DetailsActivity....)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>此方案的不足在于 <code>_navigateToDetails</code>将会一直为 true,而且不可能回到首屏:</p>
<ul>
<li>用户点击按钮启动 Details Activity</li>
<li>用户按返回按钮，回到主 Activity</li>
<li>当 activity 进入回退栈时 observers 失活，现在再次激活</li>
</ul>
<p>从 ViewModel 中调用 navigation 且立即将其设为 false</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">userClicksOnButton</span><span class="params">()</span></span> &#123;</span><br><span class="line">  _navigateToDetails.value = <span class="literal">true</span></span><br><span class="line">  _navigateToDetails.value = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是请注意： LiveData 保存数据但不会保证在接受到事件时发送任何数据。例如，当没有观察者活跃时更新值，那么一个新值将替换原来的值。同时，从不同线程设置属性将会导致竞争状态，此时仅能保证一个观察者被调用。</p>
<p>最主要的问题是，这个方案很难理解而且代码垃圾。所以我们如何保证在 navigation 事件发生时值重置？</p>
<h3 id="❌Better-2-使用-LiveData-wrapper-事件，在观察者中重置属性"><a href="#❌Better-2-使用-LiveData-wrapper-事件，在观察者中重置属性" class="headerlink" title="❌Better: 2.使用 LiveData wrapper 事件，在观察者中重置属性."></a>❌Better: 2.使用 LiveData wrapper 事件，在观察者中重置属性.</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">listViewModel.navigateToDetails.observe(<span class="keyword">this</span>,Observer &#123;</span><br><span class="line">  <span class="keyword">if</span> (it) &#123;</span><br><span class="line">    myViewModel.navigateToDetailsHandled()</span><br><span class="line">    startActivity(DetailsActivity...)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListViewModel</span>: <span class="type">ViewModel</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> _navigateToDetails = MutableLiveData&lt;<span class="built_in">Boolean</span>&gt;()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> navigateToDetails: LiveData&lt;<span class="built_in">Boolean</span>&gt;</span><br><span class="line">    <span class="keyword">get</span>() = _navigateToDetails</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">userClicksOnButton</span><span class="params">()</span></span> &#123;</span><br><span class="line">    _navigateToDetails.value = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">navigateToDetailsHandled</span><span class="params">()</span></span> &#123;</span><br><span class="line">    _navigateToDetails.value = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此方案的不足之处在于有些冗余代码</p>
<h3 id="✅-ok：使用-SingleLiveEvent"><a href="#✅-ok：使用-SingleLiveEvent" class="headerlink" title="✅ ok：使用 SingleLiveEvent"></a>✅ ok：使用 SingleLiveEvent</h3><p>SingleLiveEvent 只适用于部分场景。只发送和更新一次状态的 LiveData</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListViewModel</span>: <span class="type">ViewModel</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> _navigateToDetails = SingleLiveEvent&lt;Any&gt;()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> navigateToDetails: LiveData&lt;Any&gt;</span><br><span class="line">    <span class="keyword">get</span>() = _navigateToDetails</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">userClicksOnButton</span><span class="params">()</span></span> &#123;</span><br><span class="line">    _navigateToDetails.call()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">myViewModel.navigateToDetails.observe(<span class="keyword">this</span>, Observer &#123;</span><br><span class="line">    startActivity(DetailsActivity...)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SingleLiveEvent</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleLiveEvent</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">MutableLiveData</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TAG</span> <span class="operator">=</span> <span class="string">&quot;SingleLiveEvent&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicBoolean</span> <span class="variable">mPending</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">observe</span><span class="params">(LifecycleOwner owner, <span class="keyword">final</span> Observer&lt;T&gt; observer)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hasActiveObservers()) &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">&quot;Multiple observers registered but only one will be notified of changes.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Observe the internal MutableLiveData</span></span><br><span class="line">        <span class="built_in">super</span>.observe(owner, <span class="keyword">new</span> <span class="title class_">Observer</span>&lt;T&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onChanged</span><span class="params">(<span class="meta">@Nullable</span> T t)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (mPending.compareAndSet(<span class="literal">true</span>, <span class="literal">false</span>)) &#123;</span><br><span class="line">                    observer.onChanged(t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(<span class="meta">@Nullable</span> T t)</span> &#123;</span><br><span class="line">        mPending.set(<span class="literal">true</span>);</span><br><span class="line">        <span class="built_in">super</span>.setValue(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Used for cases where T is Void, to make calls cleaner.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        setValue(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此方案的不足之处在于只有一个订阅者。如果你有多个观察者，那么只有一个被调用且不保证顺序。<br><img src="http://qiniu.picbed.dang8080.cn/20190303082724.png" alt="SingleLiveEvent"></p>
<h3 id="✅-推荐：使用-Event-Wrapper"><a href="#✅-推荐：使用-Event-Wrapper" class="headerlink" title="✅ 推荐：使用 Event Wrapper"></a>✅ 推荐：使用 Event Wrapper</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Event</span>&lt;<span class="type">out T</span>&gt;(<span class="keyword">private</span> <span class="keyword">val</span> content: T) &#123;</span><br><span class="line">  <span class="keyword">val</span> hasBeenHandled = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">set</span> <span class="comment">// 只读属性</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 返回 content, 阻止其再次调用</span></span><br><span class="line"><span class="comment">  fun getContentIfNotHandled(): T? &#123;</span></span><br><span class="line"><span class="comment">    return if (hasBeenHandled) &#123;</span></span><br><span class="line"><span class="comment">        null</span></span><br><span class="line"><span class="comment">    &#125; else &#123;</span></span><br><span class="line"><span class="comment">        hasBeenHandled = true</span></span><br><span class="line"><span class="comment">        content</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  fun peekContent(): T = content</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListViewModel</span> : <span class="type">ViewModel</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _navigateToDetails = MutableLiveData&lt;Event&lt;String&gt;&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> navigateToDetails : LiveData&lt;Event&lt;String&gt;&gt;</span><br><span class="line">        <span class="keyword">get</span>() = _navigateToDetails</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">userClicksOnButton</span><span class="params">(itemId: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        _navigateToDetails.value = Event(itemId)  <span class="comment">// Trigger the event by setting a new Event as a new value</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListViewModel</span> : <span class="type">ViewModel</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _navigateToDetails = MutableLiveData&lt;Event&lt;String&gt;&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> navigateToDetails : LiveData&lt;Event&lt;String&gt;&gt;</span><br><span class="line">        <span class="keyword">get</span>() = _navigateToDetails</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">userClicksOnButton</span><span class="params">(itemId: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        _navigateToDetails.value = Event(itemId)  <span class="comment">// Trigger the event by setting a new Event as a new value</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此方案的优势是用户需要使用 <code>getContentIfNotHandled() 或 peekContent()</code>指定意图。此方法把事件抽象为 state 的一部分：变成仅表示是否被消费的消息。<br><img src="http://qiniu.picbed.dang8080.cn/20190303074902.png" alt="使用 Event wrapper,可以在单一用户事件上添加多个观察者"></p>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>总之，把事件作为状态的一部分。<br>使用这个 EventObserver 在大量事件结束后移除它</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EventObserver</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">private</span> <span class="keyword">val</span> onEventUnhandledContent: (T) -&gt; <span class="built_in">Unit</span>) : Observer&lt;Event&lt;T&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onChanged</span><span class="params">(event: <span class="type">Event</span>&lt;<span class="type">T</span>&gt;?)</span></span> &#123;</span><br><span class="line">        event?.getContentIfNotHandled()?.let &#123; value -&gt;</span><br><span class="line">            onEventUnhandledContent(value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> LiveData<span class="type">&lt;Event&lt;T&gt;</span>&gt;.<span class="title">observeEvent</span><span class="params">(owner: <span class="type">LifecycleOwner</span>, <span class="keyword">crossinline</span> onEventUnhandledContent: (<span class="type">T</span>) -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    observe(owner, Observer &#123; it?.getContentIfNotHandled()?.let(onEventUnhandledContent) &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>翻译</tag>
        <tag>LiveData</tag>
        <tag>Navigation</tag>
      </tags>
  </entry>
  <entry>
    <title>xmake quickjs-ng 交叉编译实践</title>
    <url>/2024/11/17/09/</url>
    <content><![CDATA[<p>xmake 是一个国人 waruqi(ruki)[<a href="https://github.com/waruqi]">https://github.com/waruqi]</a> 基于 lua 脚本语言实现的跨平台够看工具.对标 CMake, 但是远优于它. 以下是两者的简单对比.</p>
<p>Xmake &#x3D; Build backend + Project Generator + Package Manager + [Remote|Distributed] Build + Cache</p>
<p>Xmake ≈ Make&#x2F;Ninja + CMake&#x2F;Meson + Vcpkg&#x2F;Conan + distcc + ccache&#x2F;sccache</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>CMake</th>
<th>xmake</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>跨平台</td>
<td>✅</td>
<td>✅</td>
<td></td>
</tr>
<tr>
<td>配置简单</td>
<td>❌</td>
<td>✅</td>
<td></td>
</tr>
<tr>
<td>配置文件格式</td>
<td>lua</td>
<td>自定义脚本语言</td>
<td></td>
</tr>
<tr>
<td>易上手</td>
<td>❌</td>
<td>✅</td>
<td></td>
</tr>
<tr>
<td>构建产物缓存</td>
<td>✅</td>
<td>✅</td>
<td></td>
</tr>
<tr>
<td>远程仓库</td>
<td>❌</td>
<td>✅ xrepo</td>
<td></td>
</tr>
<tr>
<td>语法简单</td>
<td>❌</td>
<td>✅</td>
<td></td>
</tr>
<tr>
<td>文档详细</td>
<td>✅</td>
<td>❌</td>
<td></td>
</tr>
<tr>
<td>自动依赖管理</td>
<td>✅</td>
<td>✅</td>
<td></td>
</tr>
<tr>
<td>IDE 集成</td>
<td>✅</td>
<td>✅</td>
<td></td>
</tr>
<tr>
<td>编译器支持</td>
<td>GCC, Clang, MSVC, ICC等</td>
<td>GCC, Clang, MSVC, ICC等</td>
<td></td>
</tr>
<tr>
<td>并行构建</td>
<td>✅</td>
<td>✅</td>
<td></td>
</tr>
<tr>
<td>生成器支持</td>
<td>✅(Makefile, Ninja, Visual Studio 等)</td>
<td>✅(Makefile, Ninja, Visual Studio 等)</td>
<td></td>
</tr>
</tbody></table>
<p>以上是对 xmake 的简介.虽然工具很好用,但是文档比较少,所以进阶部分还是需要研究一番.</p>
<p>因为自己正在写的一个 flutter binding js engine 插件 依赖 quickjs 引擎, 项目采用 flutter ffi 的方式绑定, 所以需要提前构建好 quickjs 跨平台产物.为了简便这里选择 xmake.</p>
<p>1、安装 xmake</p>
<p>按<a href="https://xmake.io/#/">官网</a>指引即可</p>
<p>2、下载 quickjs 源码</p>
<p>这里选择的是 quickjs-ng 项目</p>
<p>3、在项目根目录编写 xmake.lua</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">set_project(<span class="string">&quot;quickjs&quot;</span>)</span><br><span class="line">set_xmakever(<span class="string">&quot;2.7.3&quot;</span>)</span><br><span class="line"></span><br><span class="line">add_rules(<span class="string">&quot;mode.release&quot;</span>)</span><br><span class="line">set_policy(<span class="string">&quot;build.optimization.lto&quot;</span>, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">target(<span class="string">&quot;qjs&quot;</span>)</span><br><span class="line">  set_kind(<span class="string">&quot;shared&quot;</span>)</span><br><span class="line">  add_files(<span class="string">&quot;quickjs.c&quot;</span>, <span class="string">&quot;libregexp.c&quot;</span>, <span class="string">&quot;libunicode.c&quot;</span>, <span class="string">&quot;cutils.c&quot;</span>, <span class="string">&quot;quickjs-libc.c&quot;</span>, <span class="string">&quot;libbf.c&quot;</span>)</span><br><span class="line">  add_headerfiles(<span class="string">&quot;*.h&quot;</span>)</span><br><span class="line">  add_includedirs(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">  on_load(<span class="function"><span class="keyword">function</span> <span class="params">(target)</span></span></span><br><span class="line">    target:add(<span class="string">&quot;defines&quot;</span>,  <span class="string">&quot;_GNU_SOURCE&quot;</span> )</span><br><span class="line">  <span class="keyword">end</span>)</span><br></pre></td></tr></table></figure>

<p>可以看到这里的配置非常简单,因为是 lua 脚本语言.相比 CMake 是相当亲切.</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">set_project(<span class="string">&quot;quickjs&quot;</span>)</span><br><span class="line">set_xmakever(<span class="string">&quot;2.7.3&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>这两句配置项目名和xmake最低支持的版本.</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">add_rules(<span class="string">&quot;mode.release&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><code>add_rules</code> 内置的规则.规则是一种 hook, 可以在构建的各个回调中执行对应的策略. 这里添加的是生成 release 产物. TODO: 做了哪些改动</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">set_policy(<span class="string">&quot;build.optimization.lto&quot;</span>, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>
<p><code>set_policy</code> 设置策略,指明使用 lto 优化</p>
<p>4、然后执行 <code>xmake build/b</code> 构建即可</p>
<p>这样简单的执行,生成的就是当前平台构建的产物.<br>要跨平台交叉编译,需要先执行平台配置</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># android</span></span><br><span class="line">xmake f -p android -a arm64-v8a</span><br><span class="line">xmake b</span><br><span class="line">xmake f -p android -a armeabi-v7a</span><br><span class="line">xmake b</span><br><span class="line">xmake f -p android -a x86_64</span><br><span class="line">xmake b</span><br><span class="line"><span class="comment"># ios</span></span><br><span class="line">xmake f -p iphoneos -a ...</span><br><span class="line">xmake b</span><br><span class="line"><span class="comment"># macos</span></span><br><span class="line">xmake f -p macosx -a ...</span><br><span class="line">xmake b</span><br><span class="line"><span class="comment"># linux</span></span><br><span class="line">xmake f -p linux -a ...</span><br><span class="line">xmake b</span><br><span class="line"><span class="comment"># windows</span></span><br><span class="line">xmake f -p mingw -a ...</span><br><span class="line">xmake b</span><br></pre></td></tr></table></figure>

<p>因为我是在 mac m3 上编译,所以可以构建 android&#x2F;ios&#x2F;macos 产物.而 linux&#x2F;windows 需要在linux上执行,我是选择了 orbstack 上创建 ubuntu 编译的.</p>
<h4 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a>交叉编译</h4><p>可以看到上面跨平台交叉编译比较麻烦,需要一个一个平台执行.最简单的版本是写一个脚本.很显然,这样做就失去了这篇文章的意义.</p>
<p>xmake 提供了自定义 task 的功能,可以实现如 <code>xmake [taks]</code> 执行命令.下面就来实现一下.</p>
<p>首先在项目根目录创建如下文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plugins</span><br><span class="line">  - main.lua</span><br><span class="line">  - xmake.lua</span><br></pre></td></tr></table></figure>

<p>main.lua</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">import(<span class="string">&quot;core.base.option&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> pari = &#123;</span><br><span class="line">  iphoneos = &#123; <span class="string">&quot;armv7&quot;</span>, <span class="string">&quot;armv7s&quot;</span>, <span class="string">&quot;arm64&quot;</span>, <span class="string">&quot;i386&quot;</span>, <span class="string">&quot;x86_64&quot;</span> &#125;,</span><br><span class="line">  linux = &#123; <span class="string">&quot;arm64&quot;</span>, <span class="string">&quot;x86_64&quot;</span> &#125;,</span><br><span class="line">  macosx = &#123; <span class="string">&quot;arm64&quot;</span>, <span class="string">&quot;x86_64&quot;</span> &#125;,</span><br><span class="line">  mingw = &#123;  <span class="string">&quot;arm64&quot;</span>, <span class="string">&quot;x86_64&quot;</span> &#125;,</span><br><span class="line">  android = &#123; <span class="string">&quot;arm64-v8a&quot;</span>, <span class="string">&quot;armeabi-v7a&quot;</span>, <span class="string">&quot;x86_64&quot;</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">indexOf</span><span class="params">(array, value)</span></span></span><br><span class="line">  <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">ipairs</span>(array) <span class="keyword">do</span></span><br><span class="line">      <span class="keyword">if</span> v == value <span class="keyword">then</span></span><br><span class="line">          <span class="keyword">return</span> i  </span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">xmakeBuild</span><span class="params">(platf, archf)</span></span></span><br><span class="line">  <span class="keyword">if</span> platf <span class="keyword">and</span> archf <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;🔥 &quot;</span>.. platf .. <span class="string">&quot;🌹 &quot;</span> .. archf)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">local</span> <span class="built_in">config</span> = &#123; <span class="string">&quot;f&quot;</span> &#125;</span><br><span class="line">  <span class="keyword">if</span> platf <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">table</span>.<span class="built_in">insert</span>(<span class="built_in">config</span>, <span class="string">&quot;-p&quot;</span>)</span><br><span class="line">    <span class="built_in">table</span>.<span class="built_in">insert</span>(<span class="built_in">config</span>, platf)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">if</span> archf <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">table</span>.<span class="built_in">insert</span>(<span class="built_in">config</span>, <span class="string">&quot;-a&quot;</span>)</span><br><span class="line">    <span class="built_in">table</span>.<span class="built_in">insert</span>(<span class="built_in">config</span>, archf)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="built_in">os</span>.execv(<span class="string">&quot;xmake&quot;</span>, <span class="built_in">config</span>)</span><br><span class="line">  <span class="built_in">os</span>.execv(<span class="string">&quot;xmake&quot;</span>, &#123; <span class="string">&quot;package&quot;</span>, <span class="string">&quot;-P&quot;</span>, <span class="string">&quot;.&quot;</span>&#125;)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildForPlatformArch</span><span class="params">(platf, archf)</span></span></span><br><span class="line">  <span class="keyword">local</span> hasTarget = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">local</span> archs = pari[platf]</span><br><span class="line">  <span class="keyword">if</span> archs <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">if</span> archf <span class="keyword">then</span></span><br><span class="line">      <span class="keyword">if</span> indexOf(archs, archf) <span class="keyword">then</span></span><br><span class="line">        xmakeBuild(platf, archf)</span><br><span class="line">        hasTarget = <span class="literal">true</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">for</span> _, arch <span class="keyword">in</span> <span class="built_in">ipairs</span>(archs) <span class="keyword">do</span></span><br><span class="line">        xmakeBuild(platf, arch)</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      hasTarget = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> hasTarget <span class="keyword">then</span></span><br><span class="line">    platf = platf <span class="keyword">or</span> <span class="string">&quot;Unknown platform&quot;</span></span><br><span class="line">    archf = archf <span class="keyword">or</span> <span class="string">&quot;Unknown architecture&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;🍄&quot;</span> .. platf .. <span class="string">&quot;-&quot;</span>.. archf .. <span class="string">&quot; not supported!&quot;</span>) </span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line">  <span class="keyword">local</span> platf = option.get(<span class="string">&quot;platform&quot;</span>)</span><br><span class="line">  <span class="keyword">local</span> archf = option.get(<span class="string">&quot;arch&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span> platf <span class="keyword">or</span> arch <span class="keyword">then</span></span><br><span class="line">    buildForPlatformArch(platf, archf)</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    xmakeBuild()</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>xmake.lua</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">task(<span class="string">&quot;xross&quot;</span>)</span><br><span class="line">  set_category(<span class="string">&quot;plugin&quot;</span>)</span><br><span class="line">  on_run(<span class="string">&quot;main&quot;</span>)</span><br><span class="line">  set_menu &#123;</span><br><span class="line">    usage = <span class="string">&quot;xmake xross [platform] [arch]&quot;</span>,</span><br><span class="line">    description = <span class="string">&quot;build cross platform&quot;</span>,</span><br><span class="line">    options = &#123;</span><br><span class="line">      &#123;<span class="literal">nil</span>, <span class="string">&quot;platform&quot;</span>, <span class="string">&quot;v&quot;</span>, <span class="literal">nil</span>, <span class="string">&quot;target platform.\n\tiphoneos|linux|macosx|mingw|android&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="literal">nil</span>, <span class="string">&quot;arch&quot;</span>, <span class="string">&quot;v&quot;</span>, <span class="literal">nil</span>, <span class="string">&quot;target arch.\n\tiphoneos: armv7|armv7s|arm64|i386|x86_64\n\tlinux: arm64|x86_64\n\tmacosx: arm64|x86_64\n\tmingw: arm64|x86_64\n\tandroid: arm64-v8a|armeabi-v7a|x86_64&quot;</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>然后在项目根目录的 xmake.lua 中添加就可以了.</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="addition">++add_plugindirs(&quot;plugins&quot;)</span></span><br><span class="line">target(&quot;qjs&quot;)</span><br></pre></td></tr></table></figure>

<p>执行 <code>xmake xross android</code>, 一键生成 android arm64-v8a|armeabi-v7a|x86_64 三个CPU架构的产物.</p>
<h4 id="另一种方式"><a href="#另一种方式" class="headerlink" title="另一种方式"></a>另一种方式</h4><p>上面是通过 <code>add_plugindirs</code> 导入自定义 task, 还有一种方式是通过 <code>includes()</code></p>
<p>比如创建如下目录文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xmake</span><br><span class="line">  - actions</span><br><span class="line">    xross.lua</span><br><span class="line">  - rules</span><br><span class="line">    xcode_framework2.lua</span><br></pre></td></tr></table></figure>

<p>然后在根目录 <code>xmake.lua</code> 中导入</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="addition">++includes(&quot;xmake/**.lua&quot;)</span></span><br><span class="line">target(&quot;qjs&quot;)</span><br></pre></td></tr></table></figure>

<p>其中 xross.lua 就是上面的自定义 task, 不过有点区别</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">task(<span class="string">&quot;xross&quot;</span>)</span><br><span class="line">set_category(<span class="string">&quot;plugin&quot;</span>)</span><br><span class="line"></span><br><span class="line">set_menu(&#123;</span><br><span class="line">  usage = <span class="string">&quot;xmake xross [platform] [arch]&quot;</span>,</span><br><span class="line">  description = <span class="string">&quot;build cross platform&quot;</span>,</span><br><span class="line">  options = &#123;</span><br><span class="line">    &#123;<span class="string">&#x27;p&#x27;</span>, <span class="string">&quot;platform&quot;</span>, <span class="string">&quot;v&quot;</span>, <span class="literal">nil</span>, <span class="string">&quot;target platform.\n\tiphoneos|linux|macosx|mingw|android&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="literal">nil</span>, <span class="string">&quot;arch&quot;</span>, <span class="string">&quot;v&quot;</span>, <span class="literal">nil</span>, <span class="string">&quot;target arch.\n\tiphoneos: armv7|armv7s|arm64|i386|x86_64\n\tlinux: arm64|x86_64\n\tmacosx: arm64|x86_64\n\tmingw: arm64|x86_64\n\tandroid: arm64-v8a|armeabi-v7a|x86_64&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&quot;archive&quot;</span>, <span class="string">&quot;k&quot;</span>, <span class="literal">nil</span>, <span class="string">&quot;xcode archive&quot;</span>&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> pari = &#123;</span><br><span class="line">  iphoneos = &#123; <span class="string">&quot;armv7&quot;</span>, <span class="string">&quot;armv7s&quot;</span>, <span class="string">&quot;arm64&quot;</span>, <span class="string">&quot;i386&quot;</span>, <span class="string">&quot;x86_64&quot;</span> &#125;,</span><br><span class="line">  watchos = &#123; <span class="string">&quot;arm64_32&quot;</span>, <span class="string">&quot;armv7k&quot;</span> &#125;,</span><br><span class="line">  appletvos = &#123; <span class="string">&quot;arm64&quot;</span> &#125;,</span><br><span class="line">  iphonesimulator = &#123; <span class="string">&quot;arm64&quot;</span>, <span class="string">&quot;x86_64&quot;</span> &#125;,</span><br><span class="line">  watchsimulator = &#123; <span class="string">&quot;arm64&quot;</span>, <span class="string">&quot;x86_64&quot;</span> &#125;,</span><br><span class="line">  appletvsimulator = &#123; <span class="string">&quot;arm64&quot;</span>, <span class="string">&quot;x86_64&quot;</span> &#125;,</span><br><span class="line">  linux = &#123; <span class="string">&quot;arm64&quot;</span>, <span class="string">&quot;x86_64&quot;</span> &#125;,</span><br><span class="line">  macosx = &#123; <span class="string">&quot;arm64&quot;</span>, <span class="string">&quot;x86_64&quot;</span> &#125;,</span><br><span class="line">  mingw = &#123;  <span class="string">&quot;arm64&quot;</span>, <span class="string">&quot;x86_64&quot;</span> &#125;,</span><br><span class="line">  android = &#123; <span class="string">&quot;armeabi&quot;</span>, <span class="string">&quot;arm64-v8a&quot;</span>, <span class="string">&quot;armeabi-v7a&quot;</span>, <span class="string">&quot;x86_64&quot;</span>, <span class="string">&quot;x86&quot;</span>, &#125; <span class="comment">-- &quot;mips&quot;, &quot;mips64&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">indexOf</span><span class="params">(array, value)</span></span></span><br><span class="line">  <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">ipairs</span>(array) <span class="keyword">do</span></span><br><span class="line">      <span class="keyword">if</span> v == value <span class="keyword">then</span></span><br><span class="line">          <span class="keyword">return</span> i  </span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">printTable</span><span class="params">(t, indent)</span></span></span><br><span class="line">  indent = indent <span class="keyword">or</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">local</span> indentStr = <span class="built_in">string</span>.<span class="built_in">rep</span>(<span class="string">&quot;  &quot;</span>, indent)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">type</span>(t) ~= <span class="string">&quot;table&quot;</span> <span class="keyword">then</span></span><br><span class="line">      <span class="built_in">print</span>(indentStr .. <span class="built_in">tostring</span>(t))</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(indentStr .. <span class="string">&quot;&#123;&quot;</span>)</span><br><span class="line">  <span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">pairs</span>(t) <span class="keyword">do</span></span><br><span class="line">      <span class="keyword">local</span> keyStr = <span class="built_in">tostring</span>(k)</span><br><span class="line">      <span class="keyword">if</span> <span class="built_in">type</span>(v) == <span class="string">&quot;table&quot;</span> <span class="keyword">then</span></span><br><span class="line">          <span class="built_in">print</span>(indentStr .. <span class="string">&quot;  &quot;</span> .. keyStr .. <span class="string">&quot; = &quot;</span>)</span><br><span class="line">          printTable(v, indent + <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          <span class="keyword">local</span> valueStr = <span class="built_in">tostring</span>(v)</span><br><span class="line">          <span class="built_in">print</span>(indentStr .. <span class="string">&quot;  &quot;</span> .. keyStr .. <span class="string">&quot; = &quot;</span> .. valueStr)</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="built_in">print</span>(indentStr .. <span class="string">&quot;&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">xmakeBuild</span><span class="params">(platf, archf, execvFn)</span></span></span><br><span class="line">  <span class="keyword">if</span> platf <span class="keyword">and</span> archf <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;🔥 &quot;</span>.. platf .. <span class="string">&quot;🌹 &quot;</span> .. archf)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">local</span> <span class="built_in">config</span> = &#123; <span class="string">&quot;f&quot;</span> &#125;</span><br><span class="line">  <span class="keyword">if</span> platf <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">table</span>.<span class="built_in">insert</span>(<span class="built_in">config</span>, <span class="string">&quot;-p&quot;</span>)</span><br><span class="line">    <span class="built_in">table</span>.<span class="built_in">insert</span>(<span class="built_in">config</span>, platf)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">if</span> archf <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">table</span>.<span class="built_in">insert</span>(<span class="built_in">config</span>, <span class="string">&quot;-a&quot;</span>)</span><br><span class="line">    <span class="built_in">table</span>.<span class="built_in">insert</span>(<span class="built_in">config</span>, archf)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;⛰️ xmakeBuild: &quot;</span> .. <span class="built_in">table</span>.<span class="built_in">concat</span>(<span class="built_in">config</span>, <span class="string">&quot;, &quot;</span>))</span><br><span class="line">  printTable(<span class="built_in">os</span>)</span><br><span class="line">  printTable(sudo)</span><br><span class="line">  execvFn(<span class="string">&quot;xmake&quot;</span>, <span class="built_in">config</span>)</span><br><span class="line">  execvFn(<span class="string">&quot;xmake&quot;</span>, &#123; <span class="string">&quot;package&quot;</span>, <span class="string">&quot;-P&quot;</span>, <span class="string">&quot;.&quot;</span>&#125;) <span class="comment">-- &quot;--verbose&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">buildForPlatformArch</span><span class="params">(platf, archf, execvFn)</span></span></span><br><span class="line">  <span class="keyword">local</span> hasTarget = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">local</span> archs = pari[platf]</span><br><span class="line">  <span class="keyword">if</span> archs <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">if</span> archf <span class="keyword">then</span></span><br><span class="line">      <span class="keyword">if</span> indexOf(archs, archf) <span class="keyword">then</span></span><br><span class="line">        xmakeBuild(platf, archf, execvFn)</span><br><span class="line">        hasTarget = <span class="literal">true</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">for</span> _, arch <span class="keyword">in</span> <span class="built_in">ipairs</span>(archs) <span class="keyword">do</span></span><br><span class="line">        xmakeBuild(platf, arch, execvFn)</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      hasTarget = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> hasTarget <span class="keyword">then</span></span><br><span class="line">    platf = platf <span class="keyword">or</span> <span class="string">&quot;Unknown platform&quot;</span></span><br><span class="line">    archf = archf <span class="keyword">or</span> <span class="string">&quot;Unknown architecture&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;🍄&quot;</span> .. platf .. <span class="string">&quot;-&quot;</span>.. archf .. <span class="string">&quot; not supported!&quot;</span>) </span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">on_run(<span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">  import(<span class="string">&quot;core.base.option&quot;</span>)</span><br><span class="line">  <span class="keyword">local</span> platf = option.get(<span class="string">&quot;platform&quot;</span>)</span><br><span class="line">  <span class="keyword">local</span> archf = option.get(<span class="string">&quot;arch&quot;</span>)</span><br><span class="line">  printTable(<span class="built_in">os</span>)</span><br><span class="line">  <span class="keyword">if</span> platf <span class="keyword">or</span> arch <span class="keyword">then</span></span><br><span class="line">    buildForPlatformArch(platf, archf, <span class="built_in">os</span>.execv)</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    xmakeBuild(<span class="literal">nil</span>, <span class="literal">nil</span>, <span class="built_in">os</span>.execv)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>)</span><br></pre></td></tr></table></figure>
<p>主要就是在非<code>on_run</code> scope 定义的 local function 中,无法访问到 os 模块的扩展函数 <code>execv</code>, 所以这里通过将 <code>execv</code> function 传递到函数中去. 具体修复方案等待后续排查…</p>
<blockquote>
<p>具体原因在 <a href="https://xmake.io/mirror/manual/builtin_modules.html">内置模块 os</a> 中有说明</p>
</blockquote>
<blockquote>
<p>Only some readonly interfaces (for example: os.getenv, os.arch) in the os module can be used in the description scope. Other interfaces can only be used in the script domain, for example: os.cp, os .rmetc.</p>
</blockquote>
<p>另外,在 xmake 目录中新建了一个 xcode_framework2 的 rule. 原因是内置的 <code>xcode.framework</code> 在 ios 打包 framework 时会自动签名.而本机是没有开发者账号的,所以将内置的 <a href="https://github.com/xmake-io/xmake/blob/dev/xmake/rules/xcode/framework/xmake.lua"><code>xcode.framework</code></a> 代码复制出来修改一下</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">--rule(&quot;xcode.framework&quot;)</span></span><br><span class="line"><span class="addition">++rule(&quot;xcode.framework2&quot;)</span></span><br><span class="line"># do codesign, only for dynamic library</span><br><span class="line"><span class="deletion">--local codesign_skip = target:values(&quot;xcode.codesign_skip&quot;)</span></span><br><span class="line"><span class="addition">++local codesign_skip = target:values(&quot;xcode.codesign_skip&quot;) or get_config(&quot;xcode_codesign_skip&quot;)</span></span><br><span class="line">if target:is_shared() and not codesign_skip then</span><br></pre></td></tr></table></figure>
<p>然后在 xmake.lua 中的 target 添加自定义 rule <code>xcode.framework2</code> 并且设置 <code>xcode_codesign_skip</code> 跳过签名.</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">target(&quot;qjs&quot;)</span><br><span class="line">  set_kind(&quot;shared&quot;)</span><br><span class="line">  add_files(&quot;quickjs.c&quot;, &quot;libregexp.c&quot;, &quot;libunicode.c&quot;, &quot;cutils.c&quot;, &quot;quickjs-libc.c&quot;, &quot;libbf.c&quot;)</span><br><span class="line">  add_headerfiles(&quot;*.h&quot;)</span><br><span class="line">  add_includedirs(&quot;.&quot;)</span><br><span class="line">  if is_plat(&quot;linux&quot;) and get_config(&quot;arch&quot;) == &quot;x86_64&quot; then</span><br><span class="line">    -- 使用 add_toolchain 来设置工具链 在 linux x86 上可以编译 arm,x86, linux arm 上只能编译 arm</span><br><span class="line">    set_arch(&quot;x86_64&quot;)</span><br><span class="line">    set_toolchains(&quot;gcc&quot;)</span><br><span class="line">  end</span><br><span class="line">  if is_plat(&quot;macosx&quot;, &quot;iphoneos&quot;, &quot;iphonesimulator&quot;) then</span><br><span class="line">    ++add_rules(&quot;xcode.framework2&quot;)</span><br><span class="line">    add_files(&quot;Info.plist&quot;)</span><br><span class="line">    ++add_values(&quot;xcode.codesign_skip&quot;, true)</span><br><span class="line">  end</span><br><span class="line">  on_load(function (target)</span><br><span class="line">    target:add(&quot;defines&quot;,  &quot;_GNU_SOURCE&quot; )</span><br><span class="line">  end)</span><br></pre></td></tr></table></figure>

<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://xmake.io/mirror/manual/plugin_task.html#:~:text=Xmake%20can%20implement%20custom%20tasks,plugins%20are%20implemented%20with%20task%20.">xmake plugin_task</a></p>
<p><a href="https://xmake.io/mirror/manual/extension_modules.html">xmake extension_modules</a></p>
<p><a href="https://xmake.io/mirror/guide/syntax_description.html">xmake syntax_description</a></p>
]]></content>
      <tags>
        <tag>xmake, cross compile</tag>
      </tags>
  </entry>
</search>
