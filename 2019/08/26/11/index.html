<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>译-Kotlin-Coroutine(1) case) | HumphreyIO</title><meta name="keywords" content="翻译"><meta name="author" content="HumphreyDan"><meta name="copyright" content="HumphreyDan"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="译-Kotlin-Coroutine(1) case)"><meta name="application-name" content="译-Kotlin-Coroutine(1) case)"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta name="description" content="Kotlin Coroutine   提取函数-重构但是如果提取出来的函数包含了一个在当前作用域调用的协程构造器怎么办?这种情况下,suspend 修饰符就不能满足需求了使doWorld 成为 CoroutineScopr的一个扩展函数是一种解决方案,但这种方法使得API不清晰而不适用其他情况.理想"><link rel="shortcut icon" href="/source/images/favicon.ico"><link rel="canonical" href="https://shuttlespace.github.io/2019/08/26/11/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2023/09/03/125766904/ee23df8517f3c3e3efc4145658269c06_5714860933110284659.png"},
  postHeadAiDescription: undefined,
  diytitle: undefined,
  LA51: undefined,
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":true,"limitCount":50,"languages":{"author":"作者: HumphreyDan","link":"链接: ","source":"来源: HumphreyIO","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"bottom-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: {"enable":true,"delay":100,"shiftDelay":200},
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'HumphreyIO',
  title: '译-Kotlin-Coroutine(1) case)',
  postAI: '',
  pageFillDescription: '提取函数-重构, 类似守护线程的 Global Coroutines, 取消与超时, 取消协程的执行, 同时取消, 使 computation 代码可以被取消, 使用 finally 关闭资源, 运行不可取消的代码块, 超时, 组合挂起函数, 默认顺序, 使用 async 并发, 使用 async 延迟启动, async 风格的函数, 使用 async 进行结构化并发, 协程上下文和分发器, 分发器和线程, 无限制和受限制的分发器, 调试协程和线程, 在线程之间跳转, 上下文里的 Job, 子协程, 父协程的职责, 命名协程, 组合上下文对象元素, 协程范围, 线程本地数据(Thread-local data), 异步流, 展示多个值, collections, sequence, 挂起函数, Flows, Flows 属于冷启动, Flows 取消, Flow 构造器, flow 的中间操作, 转换操作符, 大小限制操作符, 终止flow操作符, 流是连续的, Flow context, withContext 发射错误, flowOn 操作符, Buffering, 异步合并, 处理最后一个值, 组合多个流, Zip, Combine, 展开流, flatMapConcat, flatMapMerge, flatmapLatest提取函数重构但是如果提取出来的函数包含了一个在当前作用域调用的协程构造器怎么办这种情况下修饰符就不能满足需求了使成为的一个扩展函数是一种解决方案但这种方法使得不清晰而不适用其他情况理想的解决方案是作为一个包含目标函数的类的一个属性存在或者这个类实现接口最后一种方案就是适用但是这种方法会因为无法控制此方法的执行范围而表现出结构不安全性只有一些私有可以使用这个协程构造器类似守护线程的启动的活动线程不会挂住线程他们的行为类似守护线程取消与超时取消协程的执行在一个长时间运行的应用中你可能需要精确控制后台运行的协程例如用户可能关闭一个开启了协程的页面那这个协程就需要被取消函数返回一个对象可以取消此协程的执行同时取消协程可以同时取消所有在中挂起的函数都是可取消的在取消时检查协程的取消标记然后抛出然而如果一个协程在中运行而且没有检查取消标记那就不能被取消使代码可以被取消有两种方式可以取消代码第一种是周期性的调起一个挂起函数去检测取消标记函数可以实现这个需求另一种是精确的检查取消标记状态使用关闭资源在取消具有可取消属性的挂起函数时会抛出可以在被取消时使用常用的方法处理如表达式和函数执行最终任务和等待所有的最终任务执行完成才结束运行不可取消的代码块任何在块中使用挂起函数都将导致因为运行此代码的已经被取消了通常这不是个问题因为良好的关闭操作关闭文件取消任务或关闭任意类型的消息通道通常都是非阻塞的而且也不会挂起任何函数在已经取消的协程里如果竞态条件下想挂起你可以使用函数和上下文在中封装响应的代码超时取消一个正在执行的协程的最常见的理由可能是他的执行时长已经超过了超时时间当然你可以手动追踪相应的引用然后启动一个独立的协程延时后取消追踪的这个函数可以实现这个需求抛出的是的子类之前没有看到控制台打印异常堆栈信息的原因是在一个被取消的协程抛出的被认为是协程正常执行结束的标记因为仅仅是一个异常所有的资源都可以使用正常的逻辑处理如果你需要在任何超时时添加某些特殊逻辑可以把超时的这些代码放在块中或者使用函数类似但是在超时返回而不是抛出异常组合挂起函数默认顺序假设有定义在其他地方的两个挂起函数执行如远程服务或计算等任务我们认为这些任务有用实际上每隔任务只是为了其特殊目的延时了秒如果我们需要上面的函数按顺序被调用然后计算他们的结果实际中我们都是先拿第一个函数的结果在决定是否调用第二个函数或如何调用和普通的代码一样在协程里的代码也是按顺序执行的使用并发如果两个函数之间没有相关而且我们想更快的获取到结果可以同时执行两个函数吗可以实现理论山类似它会开启一个新的协程和其他协程并发的执行不同之处在于返回一个没有携带结果的而返回一个一个轻量级的非阻塞表示在未来的某一时刻会返回结果可以对使用来获取最终的结果但是同时也是一个所以必要的时候也可以取消协程的并发性总是精确的使用延迟启动可以设置它的参数为来延迟启动在此场景下只有在调用获取结果时才启动或者它的的函数被调用时启动如果仅仅调用而没在之前调用各自协程的这将会导致序列化行为因为启动协程执行代码然后等待它结束这不是用户角度的延迟当调用挂起函数计算某个值时使用可以替换标准的函数风格的函数使用协程构造器和明确的引用异步调用函数就可以实现风格的函数一般这样的函数以后缀结尾以表明只启动了异步执行需要使用来获取结果函数不是挂起函数这种函数可在任意地方调用这种函数就意味着异步此处即为并发执行他们的任务和代码等待结果必须在挂起函数或者阻塞所以使用阻塞主线程这段代码类似其他语言的异步假设在执行过程中发生了异常通常全局错误处理器会捕获该异常记录报告此错误程序可以继续执行其他操作但是此处的函数在后台运行而不会被打断即使初始化调用它的操作已经被终止了所以不鼓励使用这样的代码风格使用进行结构化并发因为协程构造器是的扩展函数所以需要使用函数提供执行范围如果在上面的函数里出错抛出异常那么在这个范围里启动的所有协程都将被取消协程上下文和分发器协程总是在标准库定义的类型的某个上下文中执行协程是一系列不同元素的集合主元素是协程的分发器和线程协程上下文包含了一个协程分发器决定哪个线程或相应协程执行其代码的线程协程分发器可以限制协程在某个指定的线程线程池或者未定义的线程去执行所有的协程构造器如和接收一个可选的参数可以精确的指定为一个新协程或者其他上下文元素当未传参数时它继承了从它被启动的地方的的上下文和分发器是一个也运行在线程的特殊分发器但实际机制是不同的当协程从即启动时使用的是默认分发器使用了一个共享后台线程池所以和使用了相同的分发器为协程创建了一个新线程去运行专用线程是一种非常昂贵的资源在真实应用下当不在使用时它必须使用函数或者存储在一个顶级变量中然后在整个应用中复用无限制和受限制的分发器协程分发器仅在第一个挂起点时才在调用者线程启动一个协程挂起后线程中的协程完全由被调用的挂起函数决定是否恢复无限制协程分发器适用于既不消耗时间也不更新限定于特定线程的共享数据如的协程此外此协程默认继承其外部的协程的默认分发器受限于其被调用的线程所以它将具有在此线程执行可预测调度的影响无限制分发器属于高级技巧在分发一个协程后不需要或产生不可期的副作用时很有效果因为在一个协程里的某些操作必须被正确的执行在正常代码中不要使用无限制分发器调试协程和线程协程可以在一个线程被挂起在另一个线程被唤醒即使是一个单线程分发器也很难检测协程在什么时间什么位置执行了什么操作最常用调试线程的方式是在每条日志语句打印出线程名几乎所有的日志框架都支持这个特性使用协程时线程没有提供更多的上下文信息而包含了许多调试工具可以更方便的实现这个需求在参数时配置配置参数模式自动开启在线程之间跳转可以指定上下文对象函数可以改变一个协程的上下文对象标准库里的函数会主动释放创建的线程不再使用时上下文里的协程里的是上下文的一部分可以通过表达式获取到里的仅仅是的简写子协程当从另一个协程的中启动一个新协程时后者通过前者的和新协程的继承了前者的上下文变成了父协程的子当父协程被取消时所有的子都会被迭代取消然而当使用启动一个协程时新协程的是没有父的所以它不会绑定到任何运行是独立的父协程的职责父协程总会等待所有的子执行完成才结束父协程不需要刻意追踪它启动的所有子也不需要使用去等待命名协程自动分配的协程可以在需要的时候过滤关注的协程信息如果一个协程是进行特殊请求或执行特殊后台任务对其进行合适的命名更利于的元素属性类似线程名可以给协程命名当模式开启时它会包含此协程所在线程的名字组合上下文对象元素有时需要为一个协程上下文定义多个元素可以使用实现协程范围假设我们的应用有一个有生命周期的对象但是这个对象不是协程例如我们的应用在的上下文下启动了许多的协程去执行异步操作如获取更新数据执行动画等当被销毁时所有的协程必须被取消以避免内存泄漏我们当然可以手动的将协程和绑定到的上下文但是提供了一个抽象的封装对象所有的协程构造器都是作为其扩展而存在创建一个绑定到的对象来管理生命周期实例可以通过或工厂函数创建前者创建一个通用的而后者使用作为默认分发器创建一个专为应用构造的也可以为类继承接口最佳方案是使用代理实现默认工厂函数线程本地数据有时候在协程之间能传递线程本地数据将会很方便但是因为这是数据没有绑定到任意特定的线程所以可能需要写很多重复的代码扩展函数可以作为使用它会创建一个额外的上下文元素保存值在每次协程切换它的上下文是自动恢复很容易忘记设置相应的上下文元素如果线程运行的协程不同从协程访问变量可能会出现未知的值为了避免这样的情况推荐使用方法和在不正确使用时属于顶级元素支持可以在提供原生支持仅有一个限制即这个值发生变化协程调用者不会收到通知因为协程上下文元素不会追踪所有的对象访问路径那么更新的元素在下次挂起时将会丢失在协程中使用更新一个对象的值当然数据也可以存储在一个可变的如中最终会被转为存储在变量中这样你就需要自己同步数据的变更异步流挂起函数异步返回一个值但是如何返回多个异步值异步流可以实现这样的需求展示多个值在使用表示多个值如果数据是需要花费阻塞计算出来的那可以使用挂起函数但是上面这样的代码会阻塞主线程使用会一次性返回所有的值可以使用异步的计算值来表示数据流构造器可以挂起函数不再被标记为属于冷启动类似是冷启动的在构造器中的代码在被前是不会运行的这就是为什么函数没有被标记取消遵循协程的取消规则没有提供其他额外的挂起点当被一个可取消的挂起函数挂起时是可以被取消的否则是不可被取消的构造器构造器发射固定带下的数据流不同的和可以使用扩展函数转为的中间操作可以使用类似和进行转换中间操作应用在上游流然后返回下游流这些流都是冷启动流这样的操作不是挂起函数立即返回新的转换流最基本操作名称如不同于的是在这些操作里的代码块可以调用挂起函数转换操作符转换符中最常用的被称为它可以实现比和更复杂的转换操作使用操作符可以发射任意值任意次大小限制操作符大小限制操作符如在相应的限制到期时会取消执行协程里的取消总是会抛出异常所以所有的资源管理函数如和普通的操作类似终止操作符终止操作符是一个启动收集流的挂起函数函数是最长用的一个其他的有转换为不同的如获取第一个值并且确定流只发送了一个值使用和把流压缩为一个值流是连续的一个流的每个独立收集都是连续的除非某些特殊操作处理了多个流协程里的流收集会调用一个终止操作符默认不会启动新协程每一个发射的数据都会被从上游到下游的中间处理操作符处理最后被传送到终止操作符流的收集操作总是处于正在被调用的协程中而不是所在的协程流的这个操作被称为上下文保存所以默认里的代码运行的上下文是由流的相应收集者提供的对于快速运行或异步代码而言这是个完美的默认设置它不关心上下文执行者也不阻塞调用者发射错误长时间消耗的代码需运行在上下文更新代码需运行在上下文中通常在协程中使用切换上下文但是中的代码有上下文保留特性不允许在其他上下文发射数据操作符指向函数的异常可以用来更改发射的上下文改变上下文的正确操作如下操作符改变了流的默认顺序现在收集者在一个协程而发射却并发的运行在在另一个线程的一个协程中当在它的上下文中改变时操作符为上游创建了另一个协程在涉及长时间运行的异步操作时在不同协程运行流的不同部分对流收集的总时间很有帮助使用操作符操作操作正在发射数据的流并发的收集而不是顺序收集当改变时操作符使用相似的机制但是此处不需要改变执行上下文异步合并当流表示了部分操作结果或参数更新状态处理每个值可能没必要但是需要处理最近的一个当收集者处理太慢时操作符可以跳过某些中间值处理最后一个值当生产者和消费者处理都很慢时是一种加速的方法它丢弃了一部分数据另一种方式是取消慢消费者然后只要生产者发送一个数据就重启组合多个流类似扩展函数流也有自拍操作符当流表示某些变量或操作最近的值时见它可能需要根据相应流的最新值和上游发射的新数据计算可以实现使用的话就得等时间最长的哪个流收到值才能计算展开流因为流表示异步接受到的数据流所以每个值可以转为另一个序列的流如和操作符实现了拼接模式这是最接近的操作符另一种展开模式是并发的收集所有进来的流然后把他们合并为一个单一流这样值就可以尽快被发出去它们都接受一个参数限制并发流的数量',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2022-01-16 11:04:27',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="http://picbed.dang8080.cn/site/avatar.jpeg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="http://picbed.dang8080.cn/site/loading-bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">HumphreyIO</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="http://picbed.dang8080.cn/site/wechatpay.png" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="http://picbed.dang8080.cn/site/wechatpay.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="http://picbed.dang8080.cn/site/wechatpay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="http://picbed.dang8080.cn/site/wechatpay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Architecture-Components/" style="font-size: 1.05rem;">Architecture Components<sup>1</sup></a><a href="/tags/Dart/" style="font-size: 1.05rem;">Dart<sup>1</sup></a><a href="/tags/DataFetcher/" style="font-size: 1.05rem;">DataFetcher<sup>1</sup></a><a href="/tags/Kotlin/" style="font-size: 1.05rem;">Kotlin<sup>1</sup></a><a href="/tags/Kotlin-%E5%8D%8F%E7%A8%8B/" style="font-size: 1.05rem;">Kotlin 协程<sup>1</sup></a><a href="/tags/LiveData/" style="font-size: 1.05rem;">LiveData<sup>1</sup></a><a href="/tags/Navigation/" style="font-size: 1.05rem;">Navigation<sup>1</sup></a><a href="/tags/ObjectBox/" style="font-size: 1.05rem;">ObjectBox<sup>18</sup></a><a href="/tags/Room/" style="font-size: 1.05rem;">Room<sup>1</sup></a><a href="/tags/cmake/" style="font-size: 1.05rem;">cmake<sup>1</sup></a><a href="/tags/container/" style="font-size: 1.05rem;">container<sup>1</sup></a><a href="/tags/docker/" style="font-size: 1.05rem;">docker<sup>1</sup></a><a href="/tags/flutter/" style="font-size: 1.05rem;">flutter<sup>1</sup></a><a href="/tags/git/" style="font-size: 1.05rem;">git<sup>1</sup></a><a href="/tags/gradle/" style="font-size: 1.05rem;">gradle<sup>1</sup></a><a href="/tags/hexo/" style="font-size: 1.05rem;">hexo<sup>1</sup></a><a href="/tags/java/" style="font-size: 1.05rem;">java<sup>1</sup></a><a href="/tags/kotlin/" style="font-size: 1.05rem;">kotlin<sup>2</sup></a><a href="/tags/teamcity/" style="font-size: 1.05rem;">teamcity<sup>1</sup></a><a href="/tags/web/" style="font-size: 1.05rem;">web<sup>1</sup></a><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 1.05rem;">多线程<sup>1</sup></a><a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" style="font-size: 1.05rem;">学习笔记<sup>1</sup></a><a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 1.05rem;">并发<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 1.05rem;">数据库<sup>19</sup></a><a href="/tags/%E6%97%A5%E5%B8%B8/" style="font-size: 1.05rem;">日常<sup>1</sup></a><a href="/tags/%E6%9E%84%E5%BB%BA/" style="font-size: 1.05rem;">构建<sup>1</sup></a><a href="/tags/%E7%BF%BB%E8%AF%91/" style="font-size: 1.05rem;">翻译<sup>3</sup></a><a href="/tags/%E7%BF%BB%E8%AF%91-JS-Unicode/" style="font-size: 1.05rem;">翻译,JS,Unicode<sup>1</sup></a><a href="/tags/%E8%AF%91/" style="font-size: 1.05rem;">译<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/08/"><span class="card-archive-list-date">八月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/02/"><span class="card-archive-list-date">二月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/03/"><span class="card-archive-list-date">三月 2022</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/02/"><span class="card-archive-list-date">二月 2022</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2020/04/"><span class="card-archive-list-date">四月 2020</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2020/03/"><span class="card-archive-list-date">三月 2020</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2020/02/"><span class="card-archive-list-date">二月 2020</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2019/12/"><span class="card-archive-list-date">十二月 2019</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div><div class="console-btn-item" id="consoleKeyboard" onclick="anzhiyu.keyboardToggle()" title="快捷键开关"><a class="keyboard-switch"><i class="anzhiyufont anzhiyu-icon-keyboard"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="article-meta tags"><a class="article-meta__tags" href="/tags/%E7%BF%BB%E8%AF%91/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>翻译</span></a></span></div></div><h1 class="post-title" itemprop="name headline">译-Kotlin-Coroutine(1) case)<a class="post-edit-link" href="undefined_posts/译-Kotlin-Coroutine(1).md" title="在 GitHub 上编辑 - 译-Kotlin-Coroutine(1) case)" target="_blank"><i class="anzhiyufont anzhiyu-icon-pencil"></i></a></h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2019-08-26T12:23:11.000Z" title="发表于 2019-08-26 20:23:11">2019-08-26</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2022-01-16T03:04:27.666Z" title="更新于 2022-01-16 11:04:27">2022-01-16</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">5.6k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>19分钟</span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为华夏"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>华夏</span></div></div></div><article class="post-content" id="article-container" itemscope itemtype="https://shuttlespace.github.io/2019/08/26/11/"><header><a href="/tags/%E7%BF%BB%E8%AF%91/" tabindex="-1" itemprop="url">翻译</a><h1 id="CrawlerTitle" itemprop="name headline">译-Kotlin-Coroutine(1) case)</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">HumphreyDan</span><time itemprop="dateCreated datePublished" datetime="2019-08-26T12:23:11.000Z" title="发表于 2019-08-26 20:23:11">2019-08-26</time><time itemprop="dateCreated datePublished" datetime="2022-01-16T03:04:27.666Z" title="更新于 2022-01-16 11:04:27">2022-01-16</time></header><p>Kotlin Coroutine</p>
<span id="more"></span>

<h3 id="提取函数-重构"><a href="#提取函数-重构" class="headerlink" title="提取函数-重构"></a>提取函数-重构</h3><p>但是如果提取出来的函数包含了一个在当前作用域调用的协程构造器怎么办?这种情况下,<code>suspend</code> 修饰符就不能满足需求了使<code>doWorld</code> 成为 <code>CoroutineScopr</code>的一个扩展函数是一种解决方案,但这种方法使得API不清晰而不适用其他情况.理想的解决方案是<code>CoroutineScope</code> 作为一个包含目标函数的类的一个属性存在,或者这个类实现<code>CoroutineScope</code>接口.最后一种方案就是适用<code>CoroutineScope(coroutineContext)</code>,但是这种方法会因为无法控制此方法的执行范围而表现出结构不安全性.只有一些私有 APIs 可以使用这个协程构造器.</p>
<h3 id="类似守护线程的-Global-Coroutines"><a href="#类似守护线程的-Global-Coroutines" class="headerlink" title="类似守护线程的 Global Coroutines"></a>类似守护线程的 Global Coroutines</h3><p><code>GlobalScope</code>启动的活动线程不会挂住线程,他们的行为类似守护线程.</p>
<h1 id="取消与超时"><a href="#取消与超时" class="headerlink" title="取消与超时"></a>取消与超时</h1><h3 id="取消协程的执行"><a href="#取消协程的执行" class="headerlink" title="取消协程的执行"></a>取消协程的执行</h3><p>在一个长时间运行的应用中,你可能需要精确控制后台运行的协程.例如用户可能关闭一个开启了协程的页面,那这个协程就需要被取消.<code>launch</code>函数返回一个<code>Job</code>对象可以取消此协程的执行.</p>
<h3 id="同时取消"><a href="#同时取消" class="headerlink" title="同时取消"></a>同时取消</h3><p>协程可以同时取消.所有在 <code>kotlinx.coroutines</code>中挂起的函数都是可取消的.在取消时,检查协程的取消标记然后抛出<code>CancellationException</code>.然而,如果一个协程在<code>computation</code> 中运行,而且没有检查取消标记,那就不能被取消.</p>
<h3 id="使-computation-代码可以被取消"><a href="#使-computation-代码可以被取消" class="headerlink" title="使 computation 代码可以被取消"></a>使 computation 代码可以被取消</h3><p>有两种方式可以取消 computation 代码.第一种是周期性的调起一个挂起函数去检测取消标记.<code>yield</code>函数可以实现这个需求.另一种是精确的检查取消标记状态.</p>
<h3 id="使用-finally-关闭资源"><a href="#使用-finally-关闭资源" class="headerlink" title="使用 finally 关闭资源"></a>使用 <code>finally</code> 关闭资源</h3><p>在取消具有可取消属性的挂起函数时会抛出 <code>CancellationException</code>,可以在 coroutine 被取消时使用常用的方法处理.如 <code>try&#123;...&#125;finally&#123;...&#125;</code>表达式和 <code>use</code>函数执行最终任务.<br><code>join</code>和<code>cancelAndJoin</code>等待所有的最终任务执行完成才结束.</p>
<h3 id="运行不可取消的代码块"><a href="#运行不可取消的代码块" class="headerlink" title="运行不可取消的代码块"></a>运行不可取消的代码块</h3><p>任何在<code>finally</code>块中使用挂起函数都将导致<code>CancellationException</code>,因为运行此代码的 coroutine 已经被取消了.通常,这不是个问题,因为良好的关闭操作(关闭文件、取消任务或关闭任意类型的消息通道)通常都是非阻塞的,而且也不会挂起任何函数.在已经取消的协程里,如果竞态条件下想挂起,你可以使用<code>withContext</code>函数和<code>NonCancellable</code>上下文在<code>withContext(NonCancellable)&#123;...&#125;</code>中封装响应的代码.</p>
<h3 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h3><p>取消一个正在执行的协程的最常见的理由可能是他的执行时长已经超过了超时时间.当然,你可以手动追踪相应<code>Job</code>的引用,然后启动一个独立的协程延时后取消追踪的这个<code>Job</code>,<code>withTimeout</code>函数可以实现这个需求.<br><code>withTimeout</code>抛出的<code>TimeoutCancellationException</code>是<code>CancellationException</code>的子类.之前没有看到控制台打印异常堆栈信息的原因是在一个被取消的协程抛出的 <code>CancellationExcepiton</code>被认为是协程正常执行结束的标记.<br>因为 cancellation 仅仅是一个异常,所有的资源都可以使用正常的逻辑处理.如果你需要在任何超时时添加某些特殊逻辑,可以把超时的这些代码放在<code>try&#123;...&#125;catch(e:TimeoutCancellationException)&#123;...&#125;</code>块中,或者使用<code>withTimeoutOrNull</code>函数(类似<code>withTimeout</code>但是在超时返回 null 而不是抛出异常).</p>
<h1 id="组合挂起函数"><a href="#组合挂起函数" class="headerlink" title="组合挂起函数"></a>组合挂起函数</h1><h3 id="默认顺序"><a href="#默认顺序" class="headerlink" title="默认顺序"></a>默认顺序</h3><p>假设有定义在其他地方的两个挂起函数执行如远程服务或计算等任务.我们认为这些任务有用,实际上每隔任务只是为了其特殊目的延时了1秒.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSomethingUsefulOne</span><span class="params">()</span></span>:<span class="built_in">Int</span> &#123;</span><br><span class="line">  delay(<span class="number">1000</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">13</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSomethingUsefulTwo</span><span class="params">()</span></span>:<span class="built_in">Int</span> &#123;</span><br><span class="line">  delay(<span class="number">1000</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">29</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们需要上面的函数按顺序被调用,然后计算他们的结果?实际中,我们都是先拿第一个函数的结果在决定是否调用第二个函数或如何调用.<br>和普通的代码一样,在协程里的代码也是按顺序执行的.</p>
<h3 id="使用-async-并发"><a href="#使用-async-并发" class="headerlink" title="使用 async 并发"></a>使用 async 并发</h3><p>如果两个函数之间没有相关,而且我们想更快的获取到结果,可以同时执行两个函数吗?<code>async</code>可以实现.<br>理论山,<code>async</code>类似<code>launch</code>.它会开启一个新的协程和其他协程并发的执行.不同之处在于<code>launch</code>返回一个没有携带结果的<code>Job</code>,而<code>async</code>返回一个<code>Deferred</code>(一个轻量级的非阻塞 future 表示在未来的某一时刻会返回结果).可以对<code>Deferred</code>使用<code>.await()</code>来获取最终的结果,但是<code>Deferred</code>同时也是一个<code>Job</code>,所以必要的时候也可以取消.<br>协程的并发性总是精确的.</p>
<h3 id="使用-async-延迟启动"><a href="#使用-async-延迟启动" class="headerlink" title="使用 async 延迟启动"></a>使用 async 延迟启动</h3><p><code>async</code>可以设置它的<code>start</code>参数为<code>CoroutineStart.LAZY</code>来延迟启动.在此场景下,只有在<code>await</code>调用获取结果时才启动,或者它的<code>Job</code>的<code>start</code>函数被调用时启动.<br>如果仅仅调用<code>await</code>而没在之前调用各自协程的<code>start</code>,这将会导致序列化行为,因为<code>await</code>启动协程执行代码然后等待它结束,这不是用户角度的延迟.当调用挂起函数计算某个值时使用<code>async(start=CoroutineStart.LAZY)</code>可以替换标准的<code>lazy</code>函数.</p>
<h3 id="async-风格的函数"><a href="#async-风格的函数" class="headerlink" title="async 风格的函数"></a>async 风格的函数</h3><p>使用<code>async</code>协程构造器和明确的<code>GlobalScope</code>引用异步调用函数就可以实现async风格的函数.一般这样的函数以<code>...Async</code>后缀结尾以表明只启动了异步执行,需要使用<code>Deferred</code>来获取结果.<br><code>xxxAsync</code>函数不是挂起函数.这种函数可在任意地方调用.这种函数就意味着异步(此处即为并发)执行他们的任务和代码.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"><span class="keyword">import</span> kotlin.system.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">    <span class="keyword">val</span> one = somethingUsefulOneAsync()</span><br><span class="line">    <span class="keyword">val</span> two = somethingUsefulTwoAsync()</span><br><span class="line">    <span class="comment">// 等待结果必须在挂起函数或者阻塞</span></span><br><span class="line">    <span class="comment">// 所以使用 runBlocking&#123;&#125; 阻塞主线程</span></span><br><span class="line">    runBlocking &#123;</span><br><span class="line">      println(<span class="string">&quot;<span class="subst">$&#123;one.await() + two.await()&#125;</span>&quot;</span>)<span class="string">&#x27;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fun somethingUsefulOneAsync() = GlobalScope.async &#123;</span></span><br><span class="line"><span class="string">    doSomethingUsefulOne()</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fun somethingUsefulTwoAsync() = GlobalScope.async &#123;</span></span><br><span class="line"><span class="string">    doSomethingUsefulTwo()</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">suspend fun doSomethingUsefulOne(): Int &#123;</span></span><br><span class="line"><span class="string">    delay(1000L) // pretend we are doing something useful here</span></span><br><span class="line"><span class="string">    return 13</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">suspend fun doSomethingUsefulTwo(): Int &#123;</span></span><br><span class="line"><span class="string">    delay(1000L) // pretend we are doing something useful here, too</span></span><br><span class="line"><span class="string">    return 29</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>这段代码类似其他语言的异步(js).假设<code>xxxAsync</code>在执行过程中发生了异常,通常全局错误处理器会捕获该异常,记录报告此错误,程序可以继续执行其他操作.但是此处的函数在后台运行,而不会被打断,即使初始化调用它的操作已经被终止了.所以不鼓励使用这样的代码风格.</p>
<h3 id="使用-async-进行结构化并发"><a href="#使用-async-进行结构化并发" class="headerlink" title="使用 async 进行结构化并发"></a>使用 async 进行结构化并发</h3><p>因为<code>async</code>协程构造器是<code>CoroutineScope</code>的扩展函数,所以需要使用<code>coroutineScope函数</code>提供执行范围.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">concurrentSum</span><span class="params">()</span></span>: <span class="built_in">Int</span> = coroutineScope &#123;</span><br><span class="line">  <span class="keyword">val</span> one = async &#123; doOne()&#125;</span><br><span class="line">  <span class="keyword">val</span> two = async &#123; doTwo()&#125;</span><br><span class="line">  one.await+two.await()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果在上面的函数里出错抛出异常,那么在这个范围里启动的所有协程都将被取消.</p>
<h1 id="协程上下文和分发器"><a href="#协程上下文和分发器" class="headerlink" title="协程上下文和分发器"></a>协程上下文和分发器</h1><p>协程总是在 kotlin 标准库定义的 <code>CoroutineContext</code> 类型的某个上下文中执行.<br>协程是一系列不同元素的集合.主元素是协程的 <code>Job</code>,<code>dispatcher</code>.</p>
<h3 id="分发器和线程"><a href="#分发器和线程" class="headerlink" title="分发器和线程"></a>分发器和线程</h3><p>协程上下文包含了一个协程分发器(决定哪个线程或相应协程执行其代码的线程).协程分发器可以限制协程在某个指定的线程,线程池,或者未定义的线程去执行.<br>所有的协程构造器如<code>launch</code>和<code>async</code>接收一个可选的<code>CoroutineContext</code>参数(可以精确的指定为一个新协程或者其他上下文元素).<br>当<code>launch&#123;...&#125;</code>未传参数时,它继承了从它被启动的地方的<code>CoroutineScope</code>的上下文(和分发器).<br><code>Dispatchers.Unconfined</code>是一个也运行在<code>main</code>线程的特殊分发器,但实际机制是不同的.<br>当协程从<code>GlobalScope</code>(即<code>Dispatchers.Default</code>)启动时使用的是默认分发器.使用了一个共享后台线程池,所以<code>launch(Dispatchers.Default)&#123;...&#125;</code>和<code>GloablScope.launch&#123;...&#125;</code>使用了相同的分发器.<br><code>newSingleThreadContext</code>为协程创建了一个新线程去运行.专用线程是一种非常昂贵的资源.在真实应用下,当不在使用时,它必须使用 <code>close</code> 函数 release,或者存储在一个顶级变量中,然后在整个应用中复用.</p>
<h3 id="无限制和受限制的分发器"><a href="#无限制和受限制的分发器" class="headerlink" title="无限制和受限制的分发器"></a>无限制和受限制的分发器</h3><p><code>Dispatchers.Unconfined</code>协程分发器仅在第一个挂起点时才在调用者线程启动一个协程.挂起后,线程中的协程完全由被调用的挂起函数决定是否恢复.无限制协程分发器适用于既不消耗CPU时间,也不更新限定于特定线程的共享数据(如UI)的协程.<br>此外,此协程默认继承其外部的<code>CoroutineScope</code>.<code>runBlocking</code>协程的默认分发器受限于其被调用的线程,所以它将具有在此线程执行可预测FIFO调度的影响.</p>
<blockquote>
<p>无限制分发器属于高级技巧:在分发一个协程后不需要或产生不可期的副作用时很有效果（因为在一个协程里的某些操作必须被正确的执行）.在正常代码中不要使用无限制分发器.</p>
</blockquote>
<h3 id="调试协程和线程"><a href="#调试协程和线程" class="headerlink" title="调试协程和线程"></a>调试协程和线程</h3><p>协程可以在一个线程被挂起,在另一个线程被唤醒.即使是一个单线程分发器也很难检测协程在什么时间,什么位置,执行了什么操作.最常用调试线程的方式是在每条日志语句打印出线程名.几乎所有的日志框架都支持这个特性.使用协程时,线程没有提供更多的上下文信息,而<code>kotlinx.coroutines</code>包含了许多调试工具可以更方便的实现这个需求.<br>在 JVM 参数时配置 <code>-DKotlinx.coroutines.debug</code>.</p>
<blockquote>
<p>JVM 配置 <code>-ea</code> 参数debug模式自动开启.</p>
</blockquote>
<h3 id="在线程之间跳转"><a href="#在线程之间跳转" class="headerlink" title="在线程之间跳转"></a>在线程之间跳转</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">log</span><span class="params">(msg:<span class="type">String</span>)</span></span> = println(<span class="string">&quot;[<span class="subst">$&#123;Thread.currentThread().name&#125;</span>] <span class="variable">$msg</span>&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  newSingleThreadContext(<span class="string">&quot;Ctx1).use&#123;ctx1 -&gt;</span></span><br><span class="line"><span class="string">    newSingleThreadContext(&quot;</span>Ctx2).use&#123;ctx2 -&gt;</span><br><span class="line">      runBlocking(ctx1) &#123;</span><br><span class="line">        log(<span class="string">&quot;started in ctx1&quot;</span>)</span><br><span class="line">        withContext(ctx2) &#123;</span><br><span class="line">          log(<span class="string">&quot;working in ctx2&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        log(<span class="string">&quot;back to ctx1&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>runBlocking</code>可以指定上下文对象.<code>withContext</code>函数可以改变一个协程的上下文对象.<br>kotlin标准库里的<code>use</code>函数会主动释放<code>newSingleThreadContext</code>创建的线程(不再使用时).</p>
<h3 id="上下文里的-Job"><a href="#上下文里的-Job" class="headerlink" title="上下文里的 Job"></a>上下文里的 Job</h3><p>协程里的 Job 是上下文的一部分,可以通过<code>coroutineContext[Jon]</code>表达式获取到.</p>
<blockquote>
<p><code>CoroutineScope</code>里的<code>isActive</code>仅仅是<code>coroutineCOntext[Job]?.isActive == true</code>的简写.</p>
</blockquote>
<h3 id="子协程"><a href="#子协程" class="headerlink" title="子协程"></a>子协程</h3><p>当从另一个协程的<code>CoroutineScope</code>中启动一个新协程时,后者通过前者的<code>CoroutineScope.coroutineContext</code>和新协程的Job继承了前者的上下文,变成了父协程 job的子job.当父协程被取消时,所有的子job都会被迭代取消.<br>然而,当使用<code>GlobalScope</code>启动一个协程时,新协程的Job是没有父Job的.所以它不会绑定到任何 scope,运行是独立的.</p>
<h3 id="父协程的职责"><a href="#父协程的职责" class="headerlink" title="父协程的职责"></a>父协程的职责</h3><p>父协程总会等待所有的子Job执行完成才结束.父协程不需要刻意追踪它启动的所有子Job,也不需要使用<code>Job.join</code>去等待.</p>
<h3 id="命名协程"><a href="#命名协程" class="headerlink" title="命名协程"></a>命名协程</h3><p>自动分配的协程id可以在需要的时候过滤关注的协程信息.如果一个协程是进行特殊请求或执行特殊后台任务,对其进行合适的命名更利于debug.context的<code>CoroutineName</code>元素属性类似线程名可以给协程命名.当 debug 模式开启时,它会包含此协程所在线程的名字.</p>
<h3 id="组合上下文对象元素"><a href="#组合上下文对象元素" class="headerlink" title="组合上下文对象元素"></a>组合上下文对象元素</h3><p>有时需要为一个协程上下文定义多个元素.可以使用<code>+</code>实现.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">launch(Dispatchers.Default + CoroutineNmae(<span class="string">&quot;Test&quot;</span>)) &#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="协程范围"><a href="#协程范围" class="headerlink" title="协程范围"></a>协程范围</h3><p>假设我们的应用有一个有生命周期的对象,但是这个对象不是协程.例如我们的android应用在Actiivty的上下文下启动了许多的协程去执行异步操作(如获取更新数据、执行动画等).当activity被销毁时所有的协程必须被取消以避免内存泄漏.我们当然可以手动的将协程和job绑定到activity的上下文,但是<code>kotlinx.coroutines</code>提供了一个抽象的封装对象:<code>CoroutineScope</code>.所有的协程构造器都是作为其扩展而存在.<br>创建一个绑定到activity的<code>CoroutineScope</code>对象来管理生命周期.<code>CoroutineScope</code>实例可以通过<code>CoroutineScope()</code>或<code>MainScope()</code>工厂函数创建.前者创建一个通用的scope,而后者使用<code>Dispatchers.Main</code> 作为默认分发器创建一个专为UI应用构造的scope.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Activity</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> mainScope = MainScope()</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">destroy</span><span class="params">()</span></span>&#123;</span><br><span class="line">    mainScope.cancel()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以为 <code>Activity</code>类继承 <code>CoroutineScope</code>接口.最佳方案是使用代理实现默认工厂函数.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Activity</span> : <span class="type">CoroutineScope</span> <span class="title">by</span> <span class="title">CoroutineScope</span>(Dispatchers.Default) &#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线程本地数据-Thread-local-data"><a href="#线程本地数据-Thread-local-data" class="headerlink" title="线程本地数据(Thread-local data)"></a>线程本地数据(Thread-local data)</h3><p>有时候在协程之间能传递线程本地数据将会很方便.但是因为这是数据没有绑定到任意特定的线程,所以可能需要写很多重复的代码.</p>
<p><code>asContextElement</code>扩展函数可以作为<code>ThreadLocal</code>使用.它会创建一个额外的上下文元素保存<code>ThreadLocal</code>值,在每次协程切换它的上下文是自动恢复.</p>
<p>很容易忘记设置相应的上下文元素.如果线程运行的协程不同,从协程访问thread-local变量可能会出现未知的值.为了避免这样的情况,推荐使用<code>ensurePresent</code>方法和在不正确使用时<code>fail-fast</code>.</p>
<p><code>ThreadLocal</code>属于顶级元素支持,可以在<code>kotlinx.coroutines</code>提供原生支持.仅有一个限制:即这个thread-local值发生变化,协程调用者不会收到通知(因为协程上下文元素不会追踪所有的<code>ThreadLocal</code>对象访问路径),那么更新的元素在下次挂起时将会丢失.在协程中使用<code>withContext</code>更新一个thread-local对象的值.</p>
<p>当然,数据也可以存储在一个可变的box如<code>class Counter(var i:Int)</code>中,最终会被转为存储在thread-local变量中.这样你就需要自己同步数据的变更.</p>
<p><code>ThreadContextElement</code></p>
<h1 id="异步流"><a href="#异步流" class="headerlink" title="异步流"></a>异步流</h1><p>挂起函数异步返回一个值,但是如何返回多个异步值?异步流可以实现这样的需求.</p>
<h3 id="展示多个值"><a href="#展示多个值" class="headerlink" title="展示多个值"></a>展示多个值</h3><h6 id="collections"><a href="#collections" class="headerlink" title="collections"></a>collections</h6><p>在 kotlin 使用 <code>collections</code>表示多个值.</p>
<h6 id="sequence"><a href="#sequence" class="headerlink" title="sequence"></a>sequence</h6><p>如果数据是需要花费CPU阻塞计算出来的,那可以使用 <code>Sequence</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span>: Sequence&lt;<span class="built_in">Int</span>&gt; = sequence &#123;</span><br><span class="line">  <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">    Thread.sleep(<span class="number">100</span>)</span><br><span class="line">    yield(i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  foo().forEach &#123;value -&gt; println(value)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="挂起函数"><a href="#挂起函数" class="headerlink" title="挂起函数"></a>挂起函数</h5><p>但是上面这样的代码会阻塞主线程.</p>
<h5 id="Flows"><a href="#Flows" class="headerlink" title="Flows"></a>Flows</h5><p>使用 <code>List&lt;Int&gt;</code>会一次性返回所有的值.可以使用<code>Flow&lt;int&gt;</code>异步的计算值来表示数据流.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123;</span><br><span class="line">  <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">    delay(<span class="number">100</span>)</span><br><span class="line">    emit(i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">  launch &#123;</span><br><span class="line">    <span class="keyword">for</span> (k <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">      println(<span class="string">&quot;I am not blocked<span class="variable">$K</span>&quot;</span>)</span><br><span class="line">      delay(<span class="number">100</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  foo().collect&#123;value -&gt; println(value)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>flow&#123;...&#125;</code> 构造器可以挂起</li>
<li><code>foo()</code> 函数不再被标记为<code>suspend</code></li>
</ul>
<h3 id="Flows-属于冷启动"><a href="#Flows-属于冷启动" class="headerlink" title="Flows 属于冷启动"></a>Flows 属于冷启动</h3><p>Flows 类似 sequences 是冷启动的-在 flow 构造器中的代码在 flow 被 collect 前是不会运行的.这就是为什么 <code>foo()</code>函数没有被标记<code>suspend</code>.</p>
<h3 id="Flows-取消"><a href="#Flows-取消" class="headerlink" title="Flows 取消"></a>Flows 取消</h3><p>flow 遵循协程的取消规则.flow 没有提供其他额外的挂起点.当flow被一个可取消的挂起函数(<code>delay</code>)挂起时是可以被取消的.否则是不可被取消的.</p>
<h3 id="Flow-构造器"><a href="#Flow-构造器" class="headerlink" title="Flow 构造器"></a>Flow 构造器</h3><ul>
<li><code>flow&#123;...&#125;</code></li>
<li><code>flowOf</code>构造器发射固定带下的数据流</li>
<li>不同的 collections 和 sequence 可以使用 <code>.asFlow()</code> 扩展函数转为 flow.</li>
</ul>
<h3 id="flow-的中间操作"><a href="#flow-的中间操作" class="headerlink" title="flow 的中间操作"></a>flow 的中间操作</h3><p>Flows 可以使用类似 collections 和 sequences 进行转换.中间操作应用在上游流,然后返回下游流.这些流都是冷启动流.这样的操作不是挂起函数.立即返回新的转换流.</p>
<p>最基本操作名称如<code>map</code>,<code>filter</code>.不同于 sequence 的是在这些操作里的代码块可以调用挂起函数.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">performRequest</span><span class="params">(request: <span class="type">Int</span>)</span></span>: String &#123;</span><br><span class="line">  delay(<span class="number">1000</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;response <span class="variable">$request</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">  (<span class="number">1.</span><span class="number">.3</span>).asFlow()</span><br><span class="line">        .map&#123; request -&gt; performRequest(request)&#125;</span><br><span class="line">        .collect&#123; response -&gt; println(response)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="转换操作符"><a href="#转换操作符" class="headerlink" title="转换操作符"></a>转换操作符</h3><p>flow 转换符中,最常用的被称为<code>transform</code>.它可以实现比<code>map</code>和<code>filter</code>更复杂的转换操作.使用 <code>transform</code>操作符,可以发射任意值任意次.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">performRequest</span><span class="params">(request: <span class="type">Int</span>)</span></span>: String &#123;</span><br><span class="line">  delay(<span class="number">1000</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;response <span class="variable">$request</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">  (<span class="number">1.</span><span class="number">.3</span>).asFlow()</span><br><span class="line">        .transform&#123; request -&gt;</span><br><span class="line">          emit(<span class="string">&quot;making request <span class="variable">$request</span>&quot;</span>)</span><br><span class="line">          emit(performRequest(request))</span><br><span class="line">        &#125;</span><br><span class="line">        .collect&#123; resposne -&gt; println(response)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="大小限制操作符"><a href="#大小限制操作符" class="headerlink" title="大小限制操作符"></a>大小限制操作符</h3><p>大小限制操作符如<code>take</code>在相应的限制到期时会取消执行.协程里的取消总是会抛出异常,所以所有的资源管理函数如(<code>try&#123;...&#125;finally&#123;...&#125;</code>)和普通的操作类似.</p>
<h3 id="终止flow操作符"><a href="#终止flow操作符" class="headerlink" title="终止flow操作符"></a>终止flow操作符</h3><p>终止操作符是一个启动收集流的挂起函数.<code>collect</code>函数是最长用的一个.其他的有:</p>
<ul>
<li>转换为不同的 collections如: <code>toList</code>,<code>toSet</code></li>
<li>获取第一个值并且确定流只发送了一个值.</li>
<li>使用 <code>reduce</code>和<code>fold</code>把流压缩为一个值.</li>
</ul>
<h3 id="流是连续的"><a href="#流是连续的" class="headerlink" title="流是连续的"></a>流是连续的</h3><p>一个流的每个独立收集都是连续的除非某些特殊操作处理了多个流.协程里的流收集会调用一个终止操作符.默认不会启动新协程.每一个发射的数据都会被从上游到下游的中间处理操作符处理.最后被传送到终止操作符.</p>
<h3 id="Flow-context"><a href="#Flow-context" class="headerlink" title="Flow context"></a>Flow context</h3><p>流的收集操作总是处于正在被调用的协程中,而不是flow所在的协程.</p>
<p>流的这个操作被称为上下文保存.<br>所以默认<code>flow&#123;...&#125;</code>里的代码运行的上下文是由流的相应收集者提供的.对于快速运行或异步代码而言,这是个完美的默认设置,它不关心上下文执行者,也不阻塞调用者.</p>
<h6 id="withContext-发射错误"><a href="#withContext-发射错误" class="headerlink" title="withContext 发射错误"></a>withContext 发射错误</h6><p>长时间消耗CPU的代码需运行在<code>Dispatchers.Default</code>上下文,UI更新代码需运行在<code>Dispatchers.Main</code>上下文中.通常,在协程中使用 <code>withContext</code>切换上下文,但是<code>flow&#123;...&#125;</code>中的代码有上下文保留特性,不允许在其他上下文发射数据.</p>
<h6 id="flowOn-操作符"><a href="#flowOn-操作符" class="headerlink" title="flowOn 操作符"></a>flowOn 操作符</h6><p>指向 flowOn 函数的异常可以用来更改 flow 发射的上下文.改变flow上下文的正确操作如下:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span>:Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123;</span><br><span class="line">  <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">    delay(<span class="number">100</span>)</span><br><span class="line">    emit(i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;.flowOn(Dispatchers.Default)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">  foo().collect&#123; value -&gt;</span><br><span class="line">    log(<span class="string">&quot;llll&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>flowOn</code>操作符改变了流的默认顺序.现在收集者在一个协程,而发射却并发的运行在在另一个线程的一个协程中.当在它的上下文中改变<code>CoroutineDispatcher</code>时<code>flowOn</code>操作符为上游创建了另一个协程.</p>
<h3 id="Buffering"><a href="#Buffering" class="headerlink" title="Buffering"></a>Buffering</h3><p>在涉及长时间运行的异步操作时,在不同协程运行流的不同部分对流收集的总时间很有帮助.<br>使用<code>buffer</code>操作符操作操作正在发射数据的流,并发的收集而不是顺序收集.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">val time = measureTimeMillis &#123;</span><br><span class="line">  foo()</span><br><span class="line">    .buffer()</span><br><span class="line">    .collect &#123; value -&gt;</span><br><span class="line">      delay(300)</span><br><span class="line">      println(value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">println(&quot;Collected in $time ms&quot;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当改变 <code>CoroutineDispatcher</code>时<code>flowOn</code>操作符使用相似的机制,但是此处不需要改变执行上下文.</p>
</blockquote>
<h5 id="异步合并"><a href="#异步合并" class="headerlink" title="异步合并"></a>异步合并</h5><p>当流表示了部分操作结果或参数更新状态,处理每个值可能没必要,但是需要处理最近的一个.当收集者处理太慢时<code>conflate</code>操作符可以跳过某些中间值.</p>
<h5 id="处理最后一个值"><a href="#处理最后一个值" class="headerlink" title="处理最后一个值"></a>处理最后一个值</h5><p>当生产者和消费者处理都很慢时,conflate 是一种加速的方法.它丢弃了一部分数据.另一种方式是取消慢消费者,然后只要生产者发送一个数据就重启.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">foo()</span><br><span class="line">  .follectLastes &#123;value -&gt;</span><br><span class="line">    println(<span class="string">&quot;collection <span class="variable">$value</span>&quot;</span>)</span><br><span class="line">    delay(<span class="number">300</span>)</span><br><span class="line">    pritln(<span class="string">&quot;Done <span class="variable">$value</span>&quot;</span>)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="组合多个流"><a href="#组合多个流" class="headerlink" title="组合多个流"></a>组合多个流</h3><h6 id="Zip"><a href="#Zip" class="headerlink" title="Zip"></a>Zip</h6><p>类似<code>Sequence.zip</code>扩展函数,流也有<code>自拍</code>操作符</p>
<h6 id="Combine"><a href="#Combine" class="headerlink" title="Combine"></a>Combine</h6><p>当流表示某些变量或操作最近的值时(见<code>conflation</code>),它可能需要根据相应流的最新值和上游发射的新数据计算,<code>combine</code>可以实现.使用<code>zip</code>的话就得等时间最长的哪个流收到值才能计算.</p>
<h3 id="展开流"><a href="#展开流" class="headerlink" title="展开流"></a>展开流</h3><p>因为流表示异步接受到的数据流,所以每个值可以转为另一个序列的流.如<code>Flow&lt;Flow&lt;String&gt;&gt;</code></p>
<h6 id="flatMapConcat"><a href="#flatMapConcat" class="headerlink" title="flatMapConcat"></a>flatMapConcat</h6><p><code>flatMapConcat</code>和<code>flattenConcat</code>操作符实现了拼接模式.这是最接近 sequence的操作符.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import kotlinx.coroutines.*</span><br><span class="line">import kotlinx.coroutines.flow.*</span><br><span class="line"></span><br><span class="line">fun requestFlow(i: Int): Flow&lt;String&gt; = flow &#123;</span><br><span class="line">    emit(&quot;$i: First&quot;)</span><br><span class="line">    delay(500) // wait 500 ms</span><br><span class="line">    emit(&quot;$i: Second&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() = runBlocking&lt;Unit&gt; &#123;</span><br><span class="line">//sampleStart</span><br><span class="line">    val startTime = currentTimeMillis() // remember the start time</span><br><span class="line">    (1..3).asFlow().onEach &#123; delay(100) &#125; // a number every 100 ms</span><br><span class="line">        .flatMapConcat &#123; requestFlow(it) &#125;</span><br><span class="line">        .collect &#123; value -&gt; // collect and print</span><br><span class="line">            println(&quot;$value at $&#123;System.currentTimeMillis() - startTime&#125; ms from start&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">//sampleEnd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="flatMapMerge"><a href="#flatMapMerge" class="headerlink" title="flatMapMerge"></a>flatMapMerge</h6><p>另一种展开模式是并发的收集所有进来的流,然后把他们合并为一个单一流,这样值就可以尽快被发出去.<code>flatMapMerge</code>,<code>flattenMerge</code>.它们都接受一个<code>concurrency</code>参数限制并发流的数量.</p>
<h6 id="flatmapLatest"><a href="#flatmapLatest" class="headerlink" title="flatmapLatest"></a>flatmapLatest</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import kotlinx.coroutines.*</span><br><span class="line">import kotlinx.coroutines.flow.*</span><br><span class="line"></span><br><span class="line">fun requestFlow(i: Int): Flow&lt;String&gt; = flow &#123;</span><br><span class="line">    emit(&quot;$i: First&quot;)</span><br><span class="line">    delay(500) // wait 500 ms</span><br><span class="line">    emit(&quot;$i: Second&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() = runBlocking&lt;Unit&gt; &#123;</span><br><span class="line">//sampleStart</span><br><span class="line">    val startTime = currentTimeMillis() // remember the start time</span><br><span class="line">    (1..3).asFlow().onEach &#123; delay(100) &#125; // a number every 100 ms</span><br><span class="line">        .flatMapLatest &#123; requestFlow(it) &#125;</span><br><span class="line">        .collect &#123; value -&gt; // collect and print</span><br><span class="line">            println(&quot;$value at $&#123;System.currentTimeMillis() - startTime&#125; ms from start&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">//sampleEnd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/source/images/avatar.jpeg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/source/images/avatar.jpeg" title="头像" alt="头像"></a><div class="post-copyright__author_name">HumphreyDan</div><div class="post-copyright__author_desc">云青青兮欲雨, 水澹澹兮生烟</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://shuttlespace.github.io/2019/08/26/11/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://shuttlespace.github.io/2019/08/26/11/')">译-Kotlin-Coroutine(1) case)</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="http://picbed.dang8080.cn/site/wechatpay.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="http://picbed.dang8080.cn/site/wechatpay.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="http://picbed.dang8080.cn/site/wechatpay.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="http://picbed.dang8080.cn/site/wechatpay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://shuttlespace.github.io/2019/08/26/11/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://shuttlespace.github.io" target="_blank">HumphreyIO</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E7%BF%BB%E8%AF%91/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>翻译<span class="tagsPageCount">3</span></a></div></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2019/08/26/52/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java 并发和多线程指南</div></div></a></div><div class="next-post pull-right"><a href="/2019/10/23/01/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Dart-Zone</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2019/04/12/33/" title="移动优先的响应式网页设计"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2019-04-12</div><div class="title">移动优先的响应式网页设计</div></div></a></div><div><a href="/2019/02/28/11/" title="[译]-LiveData with SnackBar,Navigation and other events(the SingleLiveEvent case)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2019-02-28</div><div class="title">[译]-LiveData with SnackBar,Navigation and other events(the SingleLiveEvent case)</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)">匿名评论</a><a href="/privacy" style="margin-left: 4px">隐私政策</a></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/source/images/avatar.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description">donot dedicate your life to ignorance,mediocrity,vulgarity.</div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">HumphreyDan</h1><div class="author-info__desc">云青青兮欲雨, 水澹澹兮生烟</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/ShuttleSpace" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E5%8F%96%E5%87%BD%E6%95%B0-%E9%87%8D%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">提取函数-重构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E4%BC%BC%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E7%9A%84-Global-Coroutines"><span class="toc-number">2.</span> <span class="toc-text">类似守护线程的 Global Coroutines</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%96%E6%B6%88%E4%B8%8E%E8%B6%85%E6%97%B6"><span class="toc-number"></span> <span class="toc-text">取消与超时</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%96%E6%B6%88%E5%8D%8F%E7%A8%8B%E7%9A%84%E6%89%A7%E8%A1%8C"><span class="toc-number">1.</span> <span class="toc-text">取消协程的执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%97%B6%E5%8F%96%E6%B6%88"><span class="toc-number">2.</span> <span class="toc-text">同时取消</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF-computation-%E4%BB%A3%E7%A0%81%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%8F%96%E6%B6%88"><span class="toc-number">3.</span> <span class="toc-text">使 computation 代码可以被取消</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-finally-%E5%85%B3%E9%97%AD%E8%B5%84%E6%BA%90"><span class="toc-number">4.</span> <span class="toc-text">使用 finally 关闭资源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E4%B8%8D%E5%8F%AF%E5%8F%96%E6%B6%88%E7%9A%84%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">5.</span> <span class="toc-text">运行不可取消的代码块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B6%85%E6%97%B6"><span class="toc-number">6.</span> <span class="toc-text">超时</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%8C%82%E8%B5%B7%E5%87%BD%E6%95%B0"><span class="toc-number"></span> <span class="toc-text">组合挂起函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.</span> <span class="toc-text">默认顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-async-%E5%B9%B6%E5%8F%91"><span class="toc-number">2.</span> <span class="toc-text">使用 async 并发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-async-%E5%BB%B6%E8%BF%9F%E5%90%AF%E5%8A%A8"><span class="toc-number">3.</span> <span class="toc-text">使用 async 延迟启动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#async-%E9%A3%8E%E6%A0%BC%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">4.</span> <span class="toc-text">async 风格的函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-async-%E8%BF%9B%E8%A1%8C%E7%BB%93%E6%9E%84%E5%8C%96%E5%B9%B6%E5%8F%91"><span class="toc-number">5.</span> <span class="toc-text">使用 async 进行结构化并发</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E5%88%86%E5%8F%91%E5%99%A8"><span class="toc-number"></span> <span class="toc-text">协程上下文和分发器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%8F%91%E5%99%A8%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">分发器和线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E9%99%90%E5%88%B6%E5%92%8C%E5%8F%97%E9%99%90%E5%88%B6%E7%9A%84%E5%88%86%E5%8F%91%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text">无限制和受限制的分发器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E5%8D%8F%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">调试协程和线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E8%B7%B3%E8%BD%AC"><span class="toc-number">4.</span> <span class="toc-text">在线程之间跳转</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E9%87%8C%E7%9A%84-Job"><span class="toc-number">5.</span> <span class="toc-text">上下文里的 Job</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E5%8D%8F%E7%A8%8B"><span class="toc-number">6.</span> <span class="toc-text">子协程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%88%B6%E5%8D%8F%E7%A8%8B%E7%9A%84%E8%81%8C%E8%B4%A3"><span class="toc-number">7.</span> <span class="toc-text">父协程的职责</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E5%8D%8F%E7%A8%8B"><span class="toc-number">8.</span> <span class="toc-text">命名协程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E4%B8%8A%E4%B8%8B%E6%96%87%E5%AF%B9%E8%B1%A1%E5%85%83%E7%B4%A0"><span class="toc-number">9.</span> <span class="toc-text">组合上下文对象元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E8%8C%83%E5%9B%B4"><span class="toc-number">10.</span> <span class="toc-text">协程范围</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%9C%AC%E5%9C%B0%E6%95%B0%E6%8D%AE-Thread-local-data"><span class="toc-number">11.</span> <span class="toc-text">线程本地数据(Thread-local data)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E6%B5%81"><span class="toc-number"></span> <span class="toc-text">异步流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%95%E7%A4%BA%E5%A4%9A%E4%B8%AA%E5%80%BC"><span class="toc-number">1.</span> <span class="toc-text">展示多个值</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#collections"><span class="toc-number">1.0.0.1.</span> <span class="toc-text">collections</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#sequence"><span class="toc-number">1.0.0.2.</span> <span class="toc-text">sequence</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%82%E8%B5%B7%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.1.</span> <span class="toc-text">挂起函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Flows"><span class="toc-number">1.0.2.</span> <span class="toc-text">Flows</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Flows-%E5%B1%9E%E4%BA%8E%E5%86%B7%E5%90%AF%E5%8A%A8"><span class="toc-number">2.</span> <span class="toc-text">Flows 属于冷启动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Flows-%E5%8F%96%E6%B6%88"><span class="toc-number">3.</span> <span class="toc-text">Flows 取消</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Flow-%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">4.</span> <span class="toc-text">Flow 构造器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#flow-%E7%9A%84%E4%B8%AD%E9%97%B4%E6%93%8D%E4%BD%9C"><span class="toc-number">5.</span> <span class="toc-text">flow 的中间操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">6.</span> <span class="toc-text">转换操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E5%B0%8F%E9%99%90%E5%88%B6%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">7.</span> <span class="toc-text">大小限制操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%88%E6%AD%A2flow%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">8.</span> <span class="toc-text">终止flow操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E6%98%AF%E8%BF%9E%E7%BB%AD%E7%9A%84"><span class="toc-number">9.</span> <span class="toc-text">流是连续的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Flow-context"><span class="toc-number">10.</span> <span class="toc-text">Flow context</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#withContext-%E5%8F%91%E5%B0%84%E9%94%99%E8%AF%AF"><span class="toc-number">10.0.0.1.</span> <span class="toc-text">withContext 发射错误</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#flowOn-%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">10.0.0.2.</span> <span class="toc-text">flowOn 操作符</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Buffering"><span class="toc-number">11.</span> <span class="toc-text">Buffering</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%90%88%E5%B9%B6"><span class="toc-number">11.0.1.</span> <span class="toc-text">异步合并</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%80%BC"><span class="toc-number">11.0.2.</span> <span class="toc-text">处理最后一个值</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E5%A4%9A%E4%B8%AA%E6%B5%81"><span class="toc-number">12.</span> <span class="toc-text">组合多个流</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Zip"><span class="toc-number">12.0.0.1.</span> <span class="toc-text">Zip</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Combine"><span class="toc-number">12.0.0.2.</span> <span class="toc-text">Combine</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%95%E5%BC%80%E6%B5%81"><span class="toc-number">13.</span> <span class="toc-text">展开流</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#flatMapConcat"><span class="toc-number">13.0.0.1.</span> <span class="toc-text">flatMapConcat</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#flatMapMerge"><span class="toc-number">13.0.0.2.</span> <span class="toc-text">flatMapMerge</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#flatmapLatest"><span class="toc-number">13.0.0.3.</span> <span class="toc-text">flatmapLatest</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/05/25/" title="每个JS开发者都应该知道的 Unicode">每个JS开发者都应该知道的 Unicode</a><time datetime="2024-08-05T09:55:25.728Z" title="发表于 2024-08-05 17:55:25">2024-08-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/02/26/59/" title="parcel + react">parcel + react</a><time datetime="2023-02-26T07:43:59.000Z" title="发表于 2023-02-26 15:43:59">2023-02-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/02/25/16/" title="nginx(docker) 如何更新 letsencrypt 证书">nginx(docker) 如何更新 letsencrypt 证书</a><time datetime="2023-02-25T15:52:16.000Z" title="发表于 2023-02-25 23:52:16">2023-02-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/02/25/57/" title="macOS Monterey V12 如何共享 sambda">macOS Monterey V12 如何共享 sambda</a><time datetime="2023-02-25T14:55:57.000Z" title="发表于 2023-02-25 22:55:57">2023-02-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/03/26/29/" title="使用 NAPI 或者 Context Aware 在渲染进程中加载 native 模块">使用 NAPI 或者 Context Aware 在渲染进程中加载 native 模块</a><time datetime="2022-03-26T09:19:29.000Z" title="发表于 2022-03-26 17:19:29">2022-03-26</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2024 By HumphreyDan</div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">61</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">29</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">0</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Architecture-Components/" style="font-size: 0.88rem;">Architecture Components<sup>1</sup></a><a href="/tags/Dart/" style="font-size: 0.88rem;">Dart<sup>1</sup></a><a href="/tags/DataFetcher/" style="font-size: 0.88rem;">DataFetcher<sup>1</sup></a><a href="/tags/Kotlin/" style="font-size: 0.88rem;">Kotlin<sup>1</sup></a><a href="/tags/Kotlin-%E5%8D%8F%E7%A8%8B/" style="font-size: 0.88rem;">Kotlin 协程<sup>1</sup></a><a href="/tags/LiveData/" style="font-size: 0.88rem;">LiveData<sup>1</sup></a><a href="/tags/Navigation/" style="font-size: 0.88rem;">Navigation<sup>1</sup></a><a href="/tags/ObjectBox/" style="font-size: 0.88rem;">ObjectBox<sup>18</sup></a><a href="/tags/Room/" style="font-size: 0.88rem;">Room<sup>1</sup></a><a href="/tags/cmake/" style="font-size: 0.88rem;">cmake<sup>1</sup></a><a href="/tags/container/" style="font-size: 0.88rem;">container<sup>1</sup></a><a href="/tags/docker/" style="font-size: 0.88rem;">docker<sup>1</sup></a><a href="/tags/flutter/" style="font-size: 0.88rem;">flutter<sup>1</sup></a><a href="/tags/git/" style="font-size: 0.88rem;">git<sup>1</sup></a><a href="/tags/gradle/" style="font-size: 0.88rem;">gradle<sup>1</sup></a><a href="/tags/hexo/" style="font-size: 0.88rem;">hexo<sup>1</sup></a><a href="/tags/java/" style="font-size: 0.88rem;">java<sup>1</sup></a><a href="/tags/kotlin/" style="font-size: 0.88rem;">kotlin<sup>2</sup></a><a href="/tags/teamcity/" style="font-size: 0.88rem;">teamcity<sup>1</sup></a><a href="/tags/web/" style="font-size: 0.88rem;">web<sup>1</sup></a><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 0.88rem;">多线程<sup>1</sup></a><a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" style="font-size: 0.88rem;">学习笔记<sup>1</sup></a><a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 0.88rem;">并发<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 0.88rem;">数据库<sup>19</sup></a><a href="/tags/%E6%97%A5%E5%B8%B8/" style="font-size: 0.88rem;">日常<sup>1</sup></a><a href="/tags/%E6%9E%84%E5%BB%BA/" style="font-size: 0.88rem;">构建<sup>1</sup></a><a href="/tags/%E7%BF%BB%E8%AF%91/" style="font-size: 0.88rem;">翻译<sup>3</sup></a><a href="/tags/%E7%BF%BB%E8%AF%91-JS-Unicode/" style="font-size: 0.88rem;">翻译,JS,Unicode<sup>1</sup></a><a href="/tags/%E8%AF%91/" style="font-size: 0.88rem;">译<sup>1</sup></a></div></div><hr/></div></div><div id="keyboard-tips"><div class="keyboardTitle">博客快捷键</div><div class="keybordList"><div class="keybordItem"><div class="keyGroup"><div class="key">shift K</div></div><div class="keyContent"><div class="content">关闭快捷键功能</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift A</div></div><div class="keyContent"><div class="content">打开/关闭中控台</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift M</div></div><div class="keyContent"><div class="content">播放/暂停音乐</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift D</div></div><div class="keyContent"><div class="content">深色/浅色显示模式</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift S</div></div><div class="keyContent"><div class="content">站内搜索</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift R</div></div><div class="keyContent"><div class="content">随机访问</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift H</div></div><div class="keyContent"><div class="content">返回首页</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift F</div></div><div class="keyContent"><div class="content">友链鱼塘</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift L</div></div><div class="keyContent"><div class="content">友链页面</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift P</div></div><div class="keyContent"><div class="content">关于本站</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift I</div></div><div class="keyContent"><div class="content">原版/本站右键菜单</div></div></div></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.cbd.int/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("01/01/2018 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2018 By 安知鱼 V1.6.12",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 HumphreyDan 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.cbd.int/mermaid@10.2.4/dist/mermaid.min.js').then(runMermaid)
  }

  anzhiyu.addGlobalFn('themeChange', runMermaid, 'mermaid')

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'WS6xwQjL3YsDPCdcRTqtpdhg-gzGzoHsz',
      appKey: 'NgSfNQLxbzWKBuQROhn56aP5',
      avatar: 'mp',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.cbd.int/valine@1.5.1/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !true) {
    if (true) anzhiyu.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script src="https://cdn.cbd.int/blueimp-md5@2.19.0/js/md5.min.js"></script><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getIcon = (icon, mail) => {
    if (icon) return icon
    let defaultIcon = '?d=mp'
    let iconUrl = `https://gravatar.loli.net/avatar/${md5(mail.toLowerCase()) + defaultIcon}`
    return iconUrl
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }

        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const getComment = () => {
    const serverURL = 'https://WS6xwQjL.api.lncldglobal.com'

    var settings = {
      "method": "GET",
      "headers": {
        "X-LC-Id": 'WS6xwQjL3YsDPCdcRTqtpdhg-gzGzoHsz',
        "X-LC-Key": 'NgSfNQLxbzWKBuQROhn56aP5',
        "Content-Type": "application/json"
      },
    }

    fetch(`${serverURL}/1.1/classes/Comment?limit=6&order=-createdAt`,settings)
      .then(response => response.json())
      .then(data => {
        const valineArray = data.results.map(function (e) {
          return {
            'avatar': getIcon(e.QQAvatar, e.mail),
            'content': changeContent(e.comment),
            'nick': e.nick,
            'url': e.url + '#' + e.objectId,
            'date': e.updatedAt,
          }
        })
        saveToLocal.set('valine-newest-comments', JSON.stringify(valineArray), 10/(60*24))
        generateHtml(valineArray)
      }).catch(e => {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      }) 
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('valine-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/click-heart.min.js" async="async" mobile="true"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>